{"repo": "Tencent/rapidjson", "pull_number": 2300, "instance_id": "Tencent__rapidjson-2300", "issue_numbers": ["2299"], "base_commit": "ab1842a2dae061284c0a62dca1cc6d5e7e37e346", "patch": "diff --git a/include/rapidjson/reader.h b/include/rapidjson/reader.h\nindex 55546601e..f7ef61024 100644\n--- a/include/rapidjson/reader.h\n+++ b/include/rapidjson/reader.h\n@@ -1584,7 +1584,7 @@ class GenericReader {\n         // Parse frac = decimal-point 1*DIGIT\n         int expFrac = 0;\n         size_t decimalPosition;\n-        if (Consume(s, '.')) {\n+        if (!useNanOrInf && Consume(s, '.')) {\n             decimalPosition = s.Length();\n \n             if (RAPIDJSON_UNLIKELY(!(s.Peek() >= '0' && s.Peek() <= '9')))\n@@ -1631,7 +1631,7 @@ class GenericReader {\n \n         // Parse exp = e [ minus / plus ] 1*DIGIT\n         int exp = 0;\n-        if (Consume(s, 'e') || Consume(s, 'E')) {\n+        if (!useNanOrInf && (Consume(s, 'e') || Consume(s, 'E'))) {\n             if (!useDouble) {\n                 d = static_cast<double>(use64bit ? i64 : i);\n                 useDouble = true;\n", "test_patch": "diff --git a/test/unittest/readertest.cpp b/test/unittest/readertest.cpp\nindex f828dbbe2..06c7d7534 100644\n--- a/test/unittest/readertest.cpp\n+++ b/test/unittest/readertest.cpp\n@@ -2338,6 +2338,9 @@ TEST(Reader, ParseNanAndInfinity) {\n     TEST_NAN_INF_ERROR(kParseErrorValueInvalid, \"-nan\", 1u);\n     TEST_NAN_INF_ERROR(kParseErrorValueInvalid, \"NAN\", 1u);\n     TEST_NAN_INF_ERROR(kParseErrorValueInvalid, \"-Infinty\", 6u);\n+    TEST_NAN_INF_ERROR(kParseErrorDocumentRootNotSingular, \"NaN.2e2\", 3u);\n+    TEST_NAN_INF_ERROR(kParseErrorDocumentRootNotSingular, \"Inf.2\", 3u);\n+    TEST_NAN_INF_ERROR(kParseErrorDocumentRootNotSingular, \"-InfE2\", 4u);\n \n #undef TEST_NAN_INF_ERROR\n #undef TEST_NAN_INF\n", "problem_statement": "Bug when parsing NaN, Inf with fractional or exponent parts\n**Description:**\r\nWhen using the `kParseNanAndInfFlag` flag to parse NaN, Inf with fractional or exponent parts. The parser does not correctly report an error when it should, but gives the wrong parsing result.\r\n\r\n**Steps to Reproduce:**\r\n1. Use the `kParseNanAndInfFlag` flag for parsing.\r\n2. Provide the input `\"NaN.2e2\"` to the parser.\r\n\r\n**Expected Behavior:**\r\nThe parser should recognize \"NaN\" as a valid value (since the `kParseNanAndInfFlag` flag is used). Then, upon encountering `.2e2`, it should report a parsing error because this part of the string is not valid JSON.\r\n\r\n**Actual Behavior:**\r\nThe parser does not report an error and return value `20`.\r\n\r\n**Code to Reproduce:**\r\n```cpp\r\n#include \"rapidjson/document.h\"\r\n#include \"rapidjson/error/en.h\"\r\n#include <iostream>\r\n\r\nusing namespace rapidjson;\r\nusing namespace std;\r\n\r\nint main() {\r\n  Document d;\r\n  d.Parse<kParseNanAndInfFlag | kParseStopWhenDoneFlag>(\"NaN.2e2\");\r\n  if (d.HasParseError()) {\r\n    cout << GetParseError_En(d.GetParseError());\r\n  } else {\r\n    cout << d.GetDouble();\r\n  }\r\n  return 0;\r\n}\r\n```\n", "hints_text": "", "created_at": "2024-08-15T10:30:25Z"}
{"repo": "Tencent/rapidjson", "pull_number": 1179, "instance_id": "Tencent__rapidjson-1179", "issue_numbers": ["1152"], "base_commit": "e2d0437a9cd6f73612b155bd4e4150c66a64c678", "patch": "diff --git a/include/rapidjson/writer.h b/include/rapidjson/writer.h\nindex e610ebb60..a97889155 100644\n--- a/include/rapidjson/writer.h\n+++ b/include/rapidjson/writer.h\n@@ -460,9 +460,14 @@ class Writer {\n \n     bool WriteRawValue(const Ch* json, size_t length) {\n         PutReserve(*os_, length);\n-        for (size_t i = 0; i < length; i++) {\n-            RAPIDJSON_ASSERT(json[i] != '\\0');\n-            PutUnsafe(*os_, json[i]);\n+        GenericStringStream<SourceEncoding> is(json);\n+        while (RAPIDJSON_LIKELY(is.Tell() < length)) {\n+            const Ch c = is.Peek();\n+            RAPIDJSON_ASSERT(c != '\\0');\n+            if (RAPIDJSON_UNLIKELY(!(writeFlags & kWriteValidateEncodingFlag ? \n+                Transcoder<SourceEncoding, TargetEncoding>::Validate(is, *os_) :\n+                Transcoder<SourceEncoding, TargetEncoding>::TranscodeUnsafe(is, *os_))))\n+                return false;\n         }\n         return true;\n     }\n", "test_patch": "diff --git a/test/unittest/writertest.cpp b/test/unittest/writertest.cpp\nindex b190c6c28..232b03d18 100644\n--- a/test/unittest/writertest.cpp\n+++ b/test/unittest/writertest.cpp\n@@ -538,6 +538,43 @@ TEST(Writer, RawValue) {\n     EXPECT_STREQ(\"{\\\"a\\\":1,\\\"raw\\\":[\\\"Hello\\\\nWorld\\\", 123.456]}\", buffer.GetString());\n }\n \n+TEST(Write, RawValue_Issue1152) {\n+    {\n+        GenericStringBuffer<UTF32<> > sb;\n+        Writer<GenericStringBuffer<UTF32<> >, UTF8<>, UTF32<> > writer(sb);\n+        writer.RawValue(\"null\", 4, kNullType);\n+        EXPECT_TRUE(writer.IsComplete());\n+        const unsigned *out = sb.GetString();\n+        EXPECT_EQ(static_cast<unsigned>('n'), out[0]);\n+        EXPECT_EQ(static_cast<unsigned>('u'), out[1]);\n+        EXPECT_EQ(static_cast<unsigned>('l'), out[2]);\n+        EXPECT_EQ(static_cast<unsigned>('l'), out[3]);\n+        EXPECT_EQ(static_cast<unsigned>(0  ), out[4]);\n+    }\n+\n+    {\n+        GenericStringBuffer<UTF8<> > sb;\n+        Writer<GenericStringBuffer<UTF8<> >, UTF16<>, UTF8<> > writer(sb);\n+        writer.RawValue(L\"null\", 4, kNullType);\n+        EXPECT_TRUE(writer.IsComplete());\n+        EXPECT_STREQ(\"null\", sb.GetString());\n+    }\n+\n+    {\n+        // Fail in transcoding\n+        GenericStringBuffer<UTF16<> > buffer;\n+        Writer<GenericStringBuffer<UTF16<> >, UTF8<>, UTF16<> > writer(buffer);\n+        EXPECT_FALSE(writer.RawValue(\"\\\"\\xfe\\\"\", 3, kStringType));\n+    }\n+\n+    {\n+        // Fail in encoding validation\n+        StringBuffer buffer;\n+        Writer<StringBuffer, UTF8<>, UTF8<>, CrtAllocator, kWriteValidateEncodingFlag> writer(buffer);\n+        EXPECT_FALSE(writer.RawValue(\"\\\"\\xfe\\\"\", 3, kStringType));\n+    }\n+}\n+\n #if RAPIDJSON_HAS_CXX11_RVALUE_REFS\n static Writer<StringBuffer> WriterGen(StringBuffer &target) {\n     Writer<StringBuffer> writer(target);\n", "problem_statement": "Compile error(sign-conversion) in WriteRawValue with different input and output encoding\nIn commit e7cb2b1cbf5220b614c62d8a3ce1fa45965f1ffe , following line\r\n```cpp\r\nPutUnsafe(*os_, json[i]);    // rapidjson/writer.h, line 369\r\n```\r\nmay cause sign conversion when the input and output encoding is different. e.g. convert UTF8 to AutoUTF: \r\n\r\n> conversion to 'rapidjson::AutoUTFOutputStream<unsigned int, rapidjson::GenericMemoryBuffer<> >::Ch {aka unsigned int}' from 'rapidjson::Writer<rapidjson::AutoUTFOutputStream<unsigned int, rapidjson::GenericMemoryBuffer<> >, rapidjson::UTF8<>, rapidjson::AutoUTF<unsigned int> >::Ch {aka char}' may change the sign of the result [-Werror=sign-conversion]\r\n\r\nSo is it supposed to prevent this situation, or should handle it like `WriteString` ?\n", "hints_text": "Can you provide a minimal, reproducible example code?\n@miloyip \r\n```cpp\r\nGenericStringBuffer<UTF32<> > sb;\r\nWriter<GenericStringBuffer<UTF32<> >, UTF8<>, UTF32<> > writer(sb);\r\nwriter.RawValue(\"null\", 4, kNullType);          // Error here\r\n```\r\n\r\nOutput UTF8<char> from UTF16<wchar_t> will cause compiler warning too: \r\n```cpp\r\nGenericStringBuffer<UTF8<> > sb;\r\nWriter<GenericStringBuffer<UTF8<> >, UTF16<>, UTF8<> > writer(sb);\r\nwriter.RawValue(L\"null\", 4, kNullType);\r\n```", "created_at": "2018-02-13T03:00:32Z"}
{"repo": "Tencent/rapidjson", "pull_number": 909, "instance_id": "Tencent__rapidjson-909", "issue_numbers": ["905"], "base_commit": "b8f0414b9a7cd4c78171363240b581b26d3cf513", "patch": "diff --git a/include/rapidjson/prettywriter.h b/include/rapidjson/prettywriter.h\nindex ef36a8c2a..98dfb3060 100644\n--- a/include/rapidjson/prettywriter.h\n+++ b/include/rapidjson/prettywriter.h\n@@ -47,7 +47,7 @@ enum PrettyFormatOptions {\n template<typename OutputStream, typename SourceEncoding = UTF8<>, typename TargetEncoding = UTF8<>, typename StackAllocator = CrtAllocator, unsigned writeFlags = kWriteDefaultFlags>\n class PrettyWriter : public Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags> {\n public:\n-    typedef Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator> Base;\n+    typedef Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags> Base;\n     typedef typename Base::Ch Ch;\n \n     //! Constructor\n", "test_patch": "diff --git a/test/unittest/prettywritertest.cpp b/test/unittest/prettywritertest.cpp\nindex bfc736f33..1e1ca1ad9 100644\n--- a/test/unittest/prettywritertest.cpp\n+++ b/test/unittest/prettywritertest.cpp\n@@ -258,6 +258,49 @@ TEST(PrettyWriter, InvalidEventSequence) {\n     }\n }\n \n+TEST(PrettyWriter, NaN) {\n+    double nan = std::numeric_limits<double>::quiet_NaN();\n+\n+    EXPECT_TRUE(internal::Double(nan).IsNan());\n+    StringBuffer buffer;\n+    {\n+        PrettyWriter<StringBuffer> writer(buffer);\n+        EXPECT_FALSE(writer.Double(nan));\n+    }\n+    {\n+        PrettyWriter<StringBuffer, UTF8<>, UTF8<>, CrtAllocator, kWriteNanAndInfFlag> writer(buffer);\n+        EXPECT_TRUE(writer.Double(nan));\n+        EXPECT_STREQ(\"NaN\", buffer.GetString());\n+    }\n+    GenericStringBuffer<UTF16<> > buffer2;\n+    PrettyWriter<GenericStringBuffer<UTF16<> > > writer2(buffer2);\n+    EXPECT_FALSE(writer2.Double(nan));\n+}\n+\n+TEST(PrettyWriter, Inf) {\n+    double inf = std::numeric_limits<double>::infinity();\n+\n+    EXPECT_TRUE(internal::Double(inf).IsInf());\n+    StringBuffer buffer;\n+    {\n+        PrettyWriter<StringBuffer> writer(buffer);\n+        EXPECT_FALSE(writer.Double(inf));\n+    }\n+    {\n+        PrettyWriter<StringBuffer> writer(buffer);\n+        EXPECT_FALSE(writer.Double(-inf));\n+    }\n+    {\n+        PrettyWriter<StringBuffer, UTF8<>, UTF8<>, CrtAllocator, kWriteNanAndInfFlag> writer(buffer);\n+        EXPECT_TRUE(writer.Double(inf));\n+    }\n+    {\n+        PrettyWriter<StringBuffer, UTF8<>, UTF8<>, CrtAllocator, kWriteNanAndInfFlag> writer(buffer);\n+        EXPECT_TRUE(writer.Double(-inf));\n+    }\n+    EXPECT_STREQ(\"Infinity-Infinity\", buffer.GetString());\n+}\n+\n TEST(PrettyWriter, Issue_889) {\n     char buf[100] = \"Hello\";\n     \n", "problem_statement": "Truncated output json string with NaN\nSee the next code\r\n```\r\n        Document d(kObjectType);\r\n\tStringBuffer buffer;\r\n\tPrettyWriter<StringBuffer> writer(buffer);\r\n\t\r\n\td.AddMember(\"x\", Value(22), d.GetAllocator());\r\n\td.AddMember(\"y\", Value(23), d.GetAllocator());\r\n\td.AddMember(\"x\", Value(11), d.GetAllocator());\r\n\td.AddMember(\"x\", Value(nan(\"\")), d.GetAllocator());\r\n\td.AddMember(\"Z\", Value(11), d.GetAllocator());\r\n\t\r\n\td.Accept(writer);\r\n\tconst char* output = buffer.GetString();\r\n\tprintf(\"%s\\n\", output);\r\n```\r\nAnd output\r\n```\r\n{\r\n    \"x\": 22,\r\n    \"y\": 23,\r\n    \"x\": 11,\r\n    \"x\": \r\n```\r\n\r\nNothing written after `NaN`. This **bug** here looks like not so bad as empty file. I have spent some time to find it.\n", "hints_text": "This is not a bug. `Accept()` returns `false` when it failed to write a strictly valid JSON. And NaN is invalid in JSON. Use `kWriteNanAndInfFlag` to relax the writer for permitting writing NaN and Inf.\nOh, sorry for the \"bug\". I used to see exceptions in C++. So with rapidjson to catch exceptions user need to go old `C` way like:\r\n\r\n    bool done = doc.Accept(writer);\r\n    assert(done);\r\n    //or\r\n    if(!done)\r\n      throw or go your way to handle error;\r\n\r\nIsn't it?\n    using PrettyWriterWithNanAndInf = \r\n\t\t\t\trj::PrettyWriter<\r\n\t\t\t\t\t\t/*typename OutputStream  */ rj::FileWriteStream,\r\n\t\t\t\t\t\t/*typename SourceEncoding*/ UTF8<>,\r\n\t\t\t\t\t\t/*typename TargetEncoding*/ UTF8<>,\r\n\t\t\t\t\t\t/*typename StackAllocator*/ CrtAllocator,\r\n\t\t\t\t\t\t/*unsigned writeFlags*/     2 //(unsigned)kWriteNanAndInfFlag\r\n\t\t\t\t>;\r\n    PrettyWriterWithNanAndInf  json_writer (os)\r\n\r\nProduces a compile-time error:\r\n\r\n    main.cpp: In constructor 'rapidjson::PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::PrettyWriter(OutputStream&, StackAllocator*, std::size_t) [with OutputStream = rapidjson::FileWriteStream; SourceEncoding = rapidjson::UTF8<>; TargetEncoding = rapidjson::UTF8<>; StackAllocator = rapidjson::CrtAllocator; unsigned int writeFlags = 2u; std::size_t = long long unsigned int]':\r\n    main.cpp:46:45: error: 'const size_t rapidjson::Writer<rapidjson::FileWriteStream, rapidjson::UTF8<>, rapidjson::UTF8<>, rapidjson::CrtAllocator, 0u>::kDefaultLevelDepth' is protected within this context\r\n    PrettyWriterWithNanAndInf  json_writer (os);\r\n                                             ^\r\n   \r\nNo error with `/*unsigned writeFlags*/     0`.", "created_at": "2017-03-27T06:05:57Z"}
{"repo": "Tencent/rapidjson", "pull_number": 1018, "instance_id": "Tencent__rapidjson-1018", "issue_numbers": ["1017"], "base_commit": "1a77513e6d3d4947a060693a9134598a9d5e42df", "patch": "diff --git a/include/rapidjson/schema.h b/include/rapidjson/schema.h\nindex dd57edbc2..abcf1a102 100644\n--- a/include/rapidjson/schema.h\n+++ b/include/rapidjson/schema.h\n@@ -1594,7 +1594,7 @@ class GenericSchemaValidator :\n         ownStateAllocator_(0),\n         schemaStack_(allocator, schemaStackCapacity),\n         documentStack_(allocator, documentStackCapacity),\n-        outputHandler_(CreateNullHandler()),\n+        outputHandler_(0),\n         valid_(true)\n #if RAPIDJSON_SCHEMA_VERBOSE\n         , depth_(0)\n@@ -1622,8 +1622,7 @@ class GenericSchemaValidator :\n         ownStateAllocator_(0),\n         schemaStack_(allocator, schemaStackCapacity),\n         documentStack_(allocator, documentStackCapacity),\n-        outputHandler_(outputHandler),\n-        nullHandler_(0),\n+        outputHandler_(&outputHandler),\n         valid_(true)\n #if RAPIDJSON_SCHEMA_VERBOSE\n         , depth_(0)\n@@ -1634,10 +1633,6 @@ class GenericSchemaValidator :\n     //! Destructor.\n     ~GenericSchemaValidator() {\n         Reset();\n-        if (nullHandler_) {\n-            nullHandler_->~OutputHandler();\n-            StateAllocator::Free(nullHandler_);\n-        }\n         RAPIDJSON_DELETE(ownStateAllocator_);\n     }\n \n@@ -1699,7 +1694,7 @@ RAPIDJSON_MULTILINEMACRO_END\n     }\n \n #define RAPIDJSON_SCHEMA_HANDLE_END_(method, arg2)\\\n-    return valid_ = EndValue() && outputHandler_.method arg2\n+    return valid_ = EndValue() && (!outputHandler_ || outputHandler_->method arg2)\n \n #define RAPIDJSON_SCHEMA_HANDLE_VALUE_(method, arg1, arg2) \\\n     RAPIDJSON_SCHEMA_HANDLE_BEGIN_   (method, arg1);\\\n@@ -1721,7 +1716,7 @@ RAPIDJSON_MULTILINEMACRO_END\n     bool StartObject() {\n         RAPIDJSON_SCHEMA_HANDLE_BEGIN_(StartObject, (CurrentContext()));\n         RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(StartObject, ());\n-        return valid_ = outputHandler_.StartObject();\n+        return valid_ = !outputHandler_ || outputHandler_->StartObject();\n     }\n     \n     bool Key(const Ch* str, SizeType len, bool copy) {\n@@ -1729,7 +1724,7 @@ RAPIDJSON_MULTILINEMACRO_END\n         AppendToken(str, len);\n         if (!CurrentSchema().Key(CurrentContext(), str, len, copy)) return valid_ = false;\n         RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(Key, (str, len, copy));\n-        return valid_ = outputHandler_.Key(str, len, copy);\n+        return valid_ = !outputHandler_ || outputHandler_->Key(str, len, copy);\n     }\n     \n     bool EndObject(SizeType memberCount) { \n@@ -1742,7 +1737,7 @@ RAPIDJSON_MULTILINEMACRO_END\n     bool StartArray() {\n         RAPIDJSON_SCHEMA_HANDLE_BEGIN_(StartArray, (CurrentContext()));\n         RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(StartArray, ());\n-        return valid_ = outputHandler_.StartArray();\n+        return valid_ = !outputHandler_ || outputHandler_->StartArray();\n     }\n     \n     bool EndArray(SizeType elementCount) {\n@@ -1815,7 +1810,7 @@ RAPIDJSON_MULTILINEMACRO_END\n         ownStateAllocator_(0),\n         schemaStack_(allocator, schemaStackCapacity),\n         documentStack_(allocator, documentStackCapacity),\n-        outputHandler_(CreateNullHandler()),\n+        outputHandler_(0),\n         valid_(true)\n #if RAPIDJSON_SCHEMA_VERBOSE\n         , depth_(depth)\n@@ -1929,10 +1924,6 @@ RAPIDJSON_MULTILINEMACRO_END\n     Context& CurrentContext() { return *schemaStack_.template Top<Context>(); }\n     const Context& CurrentContext() const { return *schemaStack_.template Top<Context>(); }\n \n-    OutputHandler& CreateNullHandler() {\n-        return *(nullHandler_ = new (GetStateAllocator().Malloc(sizeof(OutputHandler))) OutputHandler);\n-    }\n-\n     static const size_t kDefaultSchemaStackCapacity = 1024;\n     static const size_t kDefaultDocumentStackCapacity = 256;\n     const SchemaDocumentType* schemaDocument_;\n@@ -1941,8 +1932,7 @@ RAPIDJSON_MULTILINEMACRO_END\n     StateAllocator* ownStateAllocator_;\n     internal::Stack<StateAllocator> schemaStack_;    //!< stack to store the current path of schema (BaseSchemaType *)\n     internal::Stack<StateAllocator> documentStack_;  //!< stack to store the current path of validating document (Ch)\n-    OutputHandler& outputHandler_;\n-    OutputHandler* nullHandler_;\n+    OutputHandler* outputHandler_;\n     bool valid_;\n #if RAPIDJSON_SCHEMA_VERBOSE\n     unsigned depth_;\n", "test_patch": "diff --git a/test/unittest/schematest.cpp b/test/unittest/schematest.cpp\nindex e79fec288..9b99ba896 100644\n--- a/test/unittest/schematest.cpp\n+++ b/test/unittest/schematest.cpp\n@@ -1329,6 +1329,25 @@ TEST(SchemaValidator, Issue825) {\n     VALIDATE(s, \"{ \\\"item\\\": \\\"hello\\\" }\", true);\n }\n \n+TEST(SchemaValidator, Issue1017_allOfHandler) {\n+    Document sd;\n+    sd.Parse(\"{\\\"allOf\\\": [{\\\"type\\\": \\\"object\\\",\\\"properties\\\": {\\\"cyanArray2\\\": {\\\"type\\\": \\\"array\\\",\\\"items\\\": { \\\"type\\\": \\\"string\\\" }}}},{\\\"type\\\": \\\"object\\\",\\\"properties\\\": {\\\"blackArray\\\": {\\\"type\\\": \\\"array\\\",\\\"items\\\": { \\\"type\\\": \\\"string\\\" }}},\\\"required\\\": [ \\\"blackArray\\\" ]}]}\");\n+    SchemaDocument s(sd);\n+    StringBuffer sb;\n+    Writer<StringBuffer> writer(sb);\n+    GenericSchemaValidator<SchemaDocument, Writer<StringBuffer> > validator(s, writer);\n+    EXPECT_TRUE(validator.StartObject());\n+    EXPECT_TRUE(validator.Key(\"cyanArray2\", 10, false));\n+    EXPECT_TRUE(validator.StartArray());    \n+    EXPECT_TRUE(validator.EndArray(0));    \n+    EXPECT_TRUE(validator.Key(\"blackArray\", 10, false));\n+    EXPECT_TRUE(validator.StartArray());    \n+    EXPECT_TRUE(validator.EndArray(0));    \n+    EXPECT_TRUE(validator.EndObject(0));\n+    EXPECT_TRUE(validator.IsValid());\n+    EXPECT_STREQ(\"{\\\"cyanArray2\\\":[],\\\"blackArray\\\":[]}\", sb.GetString());\n+}\n+\n #ifdef __clang__\n RAPIDJSON_DIAG_POP\n #endif\n", "problem_statement": "Segfault with schema validator and allOf\nHi,\r\ni am getting a segfault if i use a schema validator, a prettywriter and the schema file contains allOf.\r\nCan you help me to investigate if i am doing something wrong?\r\nI modified the schema validator example to reproduce it. Just pass schema.json as argument to the program.\r\n\r\nRegards\r\n[schema.json.txt](https://github.com/miloyip/rapidjson/files/1142733/schema.json.txt)\r\n[schemavalidator.cpp.txt](https://github.com/miloyip/rapidjson/files/1142732/schemavalidator.cpp.txt)\r\n\r\nStacktrace:\r\n```\r\n#0  0x00007f4f7e149d9e in rapidjson::internal::Stack<rapidjson::CrtAllocator>::Reserve<char> (this=0x0, count=1)\r\n    at /home/developer/ext/rapidjson/include/rapidjson/internal/stack.h:117\r\n#1  0x00007f4f7e145f51 in rapidjson::internal::Stack<rapidjson::CrtAllocator>::Push<char> (this=0x0, count=1)\r\n    at /home/developer/ext/rapidjson/include/rapidjson/internal/stack.h:123\r\n#2  0x00007f4f7e1727a8 in rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::CrtAllocator>::Put (this=0x0, c=123 '{')\r\n    at /home/developer/ext/rapidjson/include/rapidjson/stringbuffer.h:56\r\n#3  0x00007f4f7e17232a in rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::CrtAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::CrtAllocator, 0u>::WriteStartObject (this=0x7f4f340024f0)\r\n    at /home/developer/ext/rapidjson/include/rapidjson/writer.h:456\r\n#4  0x00007f4f7e16f216 in rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::CrtAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::CrtAllocator, 0u>::StartObject (this=0x7f4f340024f0)\r\n    at /home/developer/ext/rapidjson/include/rapidjson/prettywriter.h:126\r\n    \r\n    \r\n#5  0x00007f4f7e16ef4b in rapidjson::GenericSchemaValidator<rapidjson::GenericSchemaDocument<rapidjson::GenericValue<rapidjson::UTF8<char>, rapidjson::MemoryPoolAllocator<rapidjson::CrtAllocator> >, rapidjson::CrtAllocator>, rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::CrtAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::CrtAllocator, 0u>, rapidjson::CrtAllocator>::StartObject (\r\n    this=0x7f4f34003650) at /home/developer/ext/rapidjson/include/rapidjson/schema.h:1724\r\n#6  0x00007f4f7e16ee9c in rapidjson::GenericSchemaValidator<rapidjson::GenericSchemaDocument<rapidjson::GenericValue<rapidjson::UTF8<char>, rapidjson::MemoryPoolAllocator<rapidjson::CrtAllocator> >, rapidjson::CrtAllocator>, rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>, rapidjson::CrtAllocator>, rapidjson::UTF8<char>, rapidjson::UTF8<char>, rapidjson::CrtAllocator, 0u>, rapidjson::CrtAllocator>::StartObject (\r\n    this=0x7f4f340035a0) at /home/developer/ext/rapidjson/include/rapidjson/schema.h:1723\r\n```\n", "hints_text": "I cannot reproduce the problem with the schemavalidator example:\r\n~~~bash\r\necho \"{\\\"cyanArray2\\\":[], \\\"blackArray\\\":[] }\" | ./schemavalidator ~/Downloads/schema.json.txt \r\n~~~\r\n~~~\r\nInput JSON is valid.\r\n~~~\nOh. I found that this is a bug when using outputHandler.\r\nThe bug can be reproduced.", "created_at": "2017-07-13T08:14:59Z"}
{"repo": "Tencent/rapidjson", "pull_number": 1065, "instance_id": "Tencent__rapidjson-1065", "issue_numbers": ["1064"], "base_commit": "4c0f0036b54776dfc48ad76eca685caea0a1dc82", "patch": "diff --git a/include/rapidjson/schema.h b/include/rapidjson/schema.h\nindex abcf1a102..e51b3692b 100644\n--- a/include/rapidjson/schema.h\n+++ b/include/rapidjson/schema.h\n@@ -349,6 +349,7 @@ class Schema {\n \n     Schema(SchemaDocumentType* schemaDocument, const PointerType& p, const ValueType& value, const ValueType& document, AllocatorType* allocator) :\n         allocator_(allocator),\n+        pointer_(p),\n         typeless_(schemaDocument->GetTypeless()),\n         enum_(),\n         enumCount_(),\n@@ -596,6 +597,10 @@ class Schema {\n #endif\n     }\n \n+    const PointerType& GetPointer() const {\n+        return pointer_;\n+    }\n+\n     bool BeginValue(Context& context) const {\n         if (context.inArray) {\n             if (uniqueItems_)\n@@ -1215,6 +1220,7 @@ class Schema {\n     };\n \n     AllocatorType* allocator_;\n+    PointerType pointer_;\n     const SchemaType* typeless_;\n     uint64_t* enum_;\n     SizeType enumCount_;\n@@ -1650,7 +1656,7 @@ class GenericSchemaValidator :\n \n     //! Gets the JSON pointer pointed to the invalid schema.\n     PointerType GetInvalidSchemaPointer() const {\n-        return schemaStack_.Empty() ? PointerType() : schemaDocument_->GetPointer(&CurrentSchema());\n+        return schemaStack_.Empty() ? PointerType() : CurrentSchema().GetPointer();\n     }\n \n     //! Gets the keyword of invalid schema.\n", "test_patch": "diff --git a/test/unittest/schematest.cpp b/test/unittest/schematest.cpp\nindex 9b99ba896..6c395d13c 100644\n--- a/test/unittest/schematest.cpp\n+++ b/test/unittest/schematest.cpp\n@@ -124,14 +124,20 @@ TEST(SchemaValidator, Hasher) {\n \n #define INVALIDATE(schema, json, invalidSchemaPointer, invalidSchemaKeyword, invalidDocumentPointer) \\\n {\\\n-    SchemaValidator validator(schema);\\\n+    INVALIDATE_(schema, json, invalidSchemaPointer, invalidSchemaKeyword, invalidDocumentPointer, SchemaValidator, Pointer) \\\n+}\n+\n+#define INVALIDATE_(schema, json, invalidSchemaPointer, invalidSchemaKeyword, invalidDocumentPointer,\\\n+    SchemaValidatorType, PointerType) \\\n+{\\\n+    SchemaValidatorType validator(schema);\\\n     Document d;\\\n     /*printf(\"\\n%s\\n\", json);*/\\\n     d.Parse(json);\\\n     EXPECT_FALSE(d.HasParseError());\\\n     EXPECT_FALSE(d.Accept(validator));\\\n     EXPECT_FALSE(validator.IsValid());\\\n-    if (validator.GetInvalidSchemaPointer() != Pointer(invalidSchemaPointer)) {\\\n+    if (validator.GetInvalidSchemaPointer() != PointerType(invalidSchemaPointer)) {\\\n         StringBuffer sb;\\\n         validator.GetInvalidSchemaPointer().Stringify(sb);\\\n         printf(\"GetInvalidSchemaPointer() Expected: %s Actual: %s\\n\", invalidSchemaPointer, sb.GetString());\\\n@@ -142,7 +148,7 @@ TEST(SchemaValidator, Hasher) {\n         printf(\"GetInvalidSchemaKeyword() Expected: %s Actual %s\\n\", invalidSchemaKeyword, validator.GetInvalidSchemaKeyword());\\\n         ADD_FAILURE();\\\n     }\\\n-    if (validator.GetInvalidDocumentPointer() != Pointer(invalidDocumentPointer)) {\\\n+    if (validator.GetInvalidDocumentPointer() != PointerType(invalidDocumentPointer)) {\\\n         StringBuffer sb;\\\n         validator.GetInvalidDocumentPointer().Stringify(sb);\\\n         printf(\"GetInvalidDocumentPointer() Expected: %s Actual: %s\\n\", invalidDocumentPointer, sb.GetString());\\\n@@ -1348,6 +1354,17 @@ TEST(SchemaValidator, Issue1017_allOfHandler) {\n     EXPECT_STREQ(\"{\\\"cyanArray2\\\":[],\\\"blackArray\\\":[]}\", sb.GetString());\n }\n \n+TEST(SchemaValidator, Ref_remote) {\n+    typedef GenericSchemaDocument<Value, MemoryPoolAllocator<> > SchemaDocumentType;\n+    RemoteSchemaDocumentProvider<SchemaDocumentType> provider;\n+    Document sd;\n+    sd.Parse(\"{\\\"$ref\\\": \\\"http://localhost:1234/subSchemas.json#/integer\\\"}\");\n+    SchemaDocumentType s(sd, &provider);\n+    typedef GenericSchemaValidator<SchemaDocumentType, BaseReaderHandler<UTF8<> >, MemoryPoolAllocator<> > SchemaValidatorType;\n+    typedef GenericPointer<Value, MemoryPoolAllocator<> > PointerType;\n+    INVALIDATE_(s, \"null\", \"/integer\", \"type\", \"\", SchemaValidatorType, PointerType);\n+}\n+\n #ifdef __clang__\n RAPIDJSON_DIAG_POP\n #endif\n", "problem_statement": "Schema: GetInvalidSchemaPointer returns empty pointer when a remote schema is violated\nA schema can include another schema from a different file, via the `$ref` keyword where the URI includes anything other than the fragment identifier.\r\n\r\nWhen that included schema is violated, the schema pointer returned by `GetInvalidSchemaPointer()` is always the empty pointer.\r\n\r\nA simplified test case: Validate `null` against the schema\r\n\r\n```json\r\n{\"$ref\": \"foo#/integer\"}\r\n```\r\n\r\nwhere `foo` refers (via a suitable `RemoteSchemaDocumentProvider`) to\r\n\r\n```json\r\n{\"integer\": {\"type\": \"integer\"}}\r\n```\r\n\r\nExpected: `GetInvalidSchemaPointer()` returns `Pointer(\"/integer\")`.\r\n\r\nObserved: `GetInvalidSchemaPointer()` returns `Pointer()`.\n", "hints_text": "", "created_at": "2017-09-16T10:12:56Z"}
{"repo": "CLIUtils/CLI11", "pull_number": 1161, "instance_id": "CLIUtils__CLI11-1161", "issue_numbers": ["1156"], "base_commit": "f6328ccc7a5dc3e8c64c68c1a6de445bab7f4725", "patch": "diff --git a/include/CLI/App.hpp b/include/CLI/App.hpp\nindex ffbe986fc..0e23a06c5 100644\n--- a/include/CLI/App.hpp\n+++ b/include/CLI/App.hpp\n@@ -733,6 +733,9 @@ class App {\n         auto *ptr = option_group.get();\n         // move to App_p for overload resolution on older gcc versions\n         App_p app_ptr = std::dynamic_pointer_cast<App>(option_group);\n+        // don't inherit the footer in option groups and clear the help flag by default\n+        app_ptr->footer_ = \"\";\n+        app_ptr->set_help_flag();\n         add_subcommand(std::move(app_ptr));\n         return ptr;\n     }\n", "test_patch": "diff --git a/tests/HelpTest.cpp b/tests/HelpTest.cpp\nindex 1ef795021..dcdebce6e 100644\n--- a/tests/HelpTest.cpp\n+++ b/tests/HelpTest.cpp\n@@ -85,6 +85,25 @@ TEST_CASE(\"THelp: FooterCallbackBoth\", \"[help]\") {\n     CHECK_THAT(help, Contains(\"foot!!!!\"));\n }\n \n+/// @brief from github issue #1156\n+TEST_CASE(\"THelp: FooterOptionGroup\", \"[help]\") {\n+    CLI::App app{\"My prog\"};\n+\n+    app.footer(\"Report bugs to bugs@example.com\");\n+\n+    app.add_option_group(\"group-a\", \"\");\n+\n+    app.add_option_group(\"group-b\", \"\");\n+\n+    std::string help = app.help();\n+\n+    auto footer_loc = help.find(\"bugs@example.com\");\n+    auto footer_loc2 = help.find(\"bugs@example.com\", footer_loc + 10);\n+    CHECK(footer_loc != std::string::npos);\n+    // should only see the footer once\n+    CHECK(footer_loc2 == std::string::npos);\n+}\n+\n TEST_CASE(\"THelp: OptionalPositional\", \"[help]\") {\n     CLI::App app{\"My prog\", \"program\"};\n \n", "problem_statement": "The new help formatter prints the footer and the help flag multiple times\nHello,\n\nI\u2019m experiencing an issue with the new help formatter #866. The help option and footer are being printed multiple times for each instance of an option group.\n\n```C++\n#include <CLI/CLI.hpp>\n\nint main(int argc, char **argv) {\n  CLI::App app;\n\n  app.footer(\"This used to appear only once at the bottom\");\n\n  auto group_a = app.add_option_group(\"group-a\", \"\");\n\n  auto group_b = app.add_option_group(\"group-b\", \"\");\n\n  try {\n    app.parse(argc, argv);\n\n  } catch (const CLI::ParseError &e) {\n    return app.exit(e);\n  }\n\n  return 0;\n}\n```\n\n> ./a --help\n\n```bash\nOPTIONS:\n  -h,     --help              Print this help message and exit \n[Option Group: group-a]\n  \nOPTIONS:\n  -h,     --help              Print this help message and exit \n\nThis used to appear only once at the bottom \n\n\n[Option Group: group-b]\n  \nOPTIONS:\n  -h,     --help              Print this help message and exit \n\nThis used to appear only once at the bottom \n\n\n\nThis used to appear only once at the bottom \n```\n\n\n", "hints_text": "", "created_at": "2025-05-07T12:42:54Z"}
{"repo": "CLIUtils/CLI11", "pull_number": 1073, "instance_id": "CLIUtils__CLI11-1073", "issue_numbers": ["1022"], "base_commit": "79b14300197b10a5f7bb7c9ebeac1f956ab41f98", "patch": "diff --git a/.github/actions/quick_cmake/action.yml b/.github/actions/quick_cmake/action.yml\nindex d2b3825fe..9889e24dd 100644\n--- a/.github/actions/quick_cmake/action.yml\n+++ b/.github/actions/quick_cmake/action.yml\n@@ -13,7 +13,7 @@ runs:\n   using: composite\n   steps:\n     - name: CMake ${{ inputs.cmake-version }}\n-      uses: jwlawson/actions-setup-cmake@v1.14\n+      uses: jwlawson/actions-setup-cmake@v2.0.2\n       with:\n         cmake-version: \"${{ inputs.cmake-version }}\"\n     - run: |\ndiff --git a/README.md b/README.md\nindex 4a84885f9..c3ae26fb6 100644\n--- a/README.md\n+++ b/README.md\n@@ -905,10 +905,15 @@ option_groups. These are:\n   options are specified in the `add_option` calls or the ability to process\n   options in the form of `-s --long --file=file_name.ext`.\n - `.fallthrough()`: Allow extra unmatched options and positionals to \"fall\n-  through\" and be matched on a parent option. Subcommands always are allowed to\n-  \"fall through\" as in they will first attempt to match on the current\n+  through\" and be matched on a parent option. Subcommands by default are allowed\n+  to \"fall through\" as in they will first attempt to match on the current\n   subcommand and if they fail will progressively check parents for matching\n-  subcommands.\n+  subcommands. This can be disabled through `subcommand_fallthrough(false)` \ud83d\udea7.\n+- `.subcommand_fallthrough()`: \ud83d\udea7 Allow subcommands to \"fall through\" and be\n+  matched on a parent option. Disabling this prevents additional subcommands at\n+  the same level from being matched. It can be useful in certain circumstances\n+  where there might be ambiguity between subcommands and positionals. The\n+  default is true.\n - `.configurable()`: Allow the subcommand to be triggered from a configuration\n   file. By default subcommand options in a configuration file do not trigger a\n   subcommand but will just update default values.\ndiff --git a/book/chapters/subcommands.md b/book/chapters/subcommands.md\nindex 7a0c41c7e..0f621b867 100644\n--- a/book/chapters/subcommands.md\n+++ b/book/chapters/subcommands.md\n@@ -132,7 +132,21 @@ gitbook:code $ ./my_program my_model_1 --model_flag --shared_flag\n ```\n \n Here, `--shared_flag` was set on the main app, and on the command line it \"falls\n-through\" `my_model_1` to match on the main app.\n+through\" `my_model_1` to match on the main app. This is set through\n+`->fallthrough()` on a subcommand.\n+\n+#### Subcommand fallthrough\n+\n+Subcommand fallthrough allows additional subcommands to be triggered after the\n+first subcommand. By default subcommand fallthrough is enabled, but it can be\n+turned off through `->subcommand_fallthrough(false)` on a subcommand. This will\n+prevent additional subcommands at the same inheritance level from triggering,\n+the strings would then be treated as positional values. As a technical note if\n+fallthrough is enabled but subcommand fallthrough disabled (this is not the\n+default in both cases), then subcommands on grandparents can still be triggered\n+from the grandchild subcommand, unless subcommand fallthrough is also disabled\n+on the parent. This is an unusual circumstance but may arise in some very\n+particular situations.\n \n ### Prefix command\n \ndiff --git a/include/CLI/App.hpp b/include/CLI/App.hpp\nindex f98463f97..dd8b37227 100644\n--- a/include/CLI/App.hpp\n+++ b/include/CLI/App.hpp\n@@ -224,9 +224,13 @@ class App {\n     /// If true, the program should ignore underscores INHERITABLE\n     bool ignore_underscore_{false};\n \n-    /// Allow subcommand fallthrough, so that parent commands can collect commands after subcommand.  INHERITABLE\n+    /// Allow options or other arguments to fallthrough, so that parent commands can collect options after subcommand.\n+    /// INHERITABLE\n     bool fallthrough_{false};\n \n+    /// Allow subcommands to fallthrough, so that parent commands can trigger other subcommands after subcommand.\n+    bool subcommand_fallthrough_{true};\n+\n     /// Allow '/' for options for Windows like options. Defaults to true on Windows, false otherwise. INHERITABLE\n     bool allow_windows_style_options_{\n #ifdef _WIN32\n@@ -828,13 +832,19 @@ class App {\n         return this;\n     }\n \n-    /// Stop subcommand fallthrough, so that parent commands cannot collect commands after subcommand.\n+    /// Set fallthrough, set to true so that options will fallthrough to parent if not recognized in a subcommand\n     /// Default from parent, usually set on parent.\n     App *fallthrough(bool value = true) {\n         fallthrough_ = value;\n         return this;\n     }\n \n+    /// Set subcommand fallthrough, set to true so that subcommands on parents are recognized\n+    App *subcommand_fallthrough(bool value = true) {\n+        subcommand_fallthrough_ = value;\n+        return this;\n+    }\n+\n     /// Check to see if this subcommand was parsed, true only if received on command line.\n     /// This allows the subcommand to be directly checked.\n     explicit operator bool() const { return parsed_ > 0; }\n@@ -1084,6 +1094,9 @@ class App {\n     /// Check the status of fallthrough\n     CLI11_NODISCARD bool get_fallthrough() const { return fallthrough_; }\n \n+    /// Check the status of subcommand fallthrough\n+    CLI11_NODISCARD bool get_subcommand_fallthrough() const { return subcommand_fallthrough_; }\n+\n     /// Check the status of the allow windows style options\n     CLI11_NODISCARD bool get_allow_windows_style_options() const { return allow_windows_style_options_; }\n \ndiff --git a/include/CLI/impl/App_inl.hpp b/include/CLI/impl/App_inl.hpp\nindex b66bab7c9..f4325dce3 100644\n--- a/include/CLI/impl/App_inl.hpp\n+++ b/include/CLI/impl/App_inl.hpp\n@@ -1038,7 +1038,8 @@ CLI11_INLINE void App::run_callback(bool final_mode, bool suppress_final_callbac\n \n CLI11_NODISCARD CLI11_INLINE bool App::_valid_subcommand(const std::string &current, bool ignore_used) const {\n     // Don't match if max has been reached - but still check parents\n-    if(require_subcommand_max_ != 0 && parsed_subcommands_.size() >= require_subcommand_max_) {\n+    if(require_subcommand_max_ != 0 && parsed_subcommands_.size() >= require_subcommand_max_ &&\n+       subcommand_fallthrough_) {\n         return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);\n     }\n     auto *com = _find_subcommand(current, true, ignore_used);\n@@ -1046,7 +1047,10 @@ CLI11_NODISCARD CLI11_INLINE bool App::_valid_subcommand(const std::string &curr\n         return true;\n     }\n     // Check parent if exists, else return false\n-    return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);\n+    if(subcommand_fallthrough_) {\n+        return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);\n+    }\n+    return false;\n }\n \n CLI11_NODISCARD CLI11_INLINE detail::Classifier App::_recognize(const std::string &current,\n@@ -1743,9 +1747,9 @@ CLI11_INLINE bool App::_parse_positional(std::vector<std::string> &args, bool ha\n         }\n     }\n     // let the parent deal with it if possible\n-    if(parent_ != nullptr && fallthrough_)\n+    if(parent_ != nullptr && fallthrough_) {\n         return _get_fallthrough_parent()->_parse_positional(args, static_cast<bool>(parse_complete_callback_));\n-\n+    }\n     /// Try to find a local subcommand that is repeated\n     auto *com = _find_subcommand(args.back(), true, false);\n     if(com != nullptr && (require_subcommand_max_ == 0 || require_subcommand_max_ > parsed_subcommands_.size())) {\n@@ -1756,15 +1760,16 @@ CLI11_INLINE bool App::_parse_positional(std::vector<std::string> &args, bool ha\n         com->_parse(args);\n         return true;\n     }\n-    /// now try one last gasp at subcommands that have been executed before, go to root app and try to find a\n-    /// subcommand in a broader way, if one exists let the parent deal with it\n-    auto *parent_app = (parent_ != nullptr) ? _get_fallthrough_parent() : this;\n-    com = parent_app->_find_subcommand(args.back(), true, false);\n-    if(com != nullptr && (com->parent_->require_subcommand_max_ == 0 ||\n-                          com->parent_->require_subcommand_max_ > com->parent_->parsed_subcommands_.size())) {\n-        return false;\n+    if(subcommand_fallthrough_) {\n+        /// now try one last gasp at subcommands that have been executed before, go to root app and try to find a\n+        /// subcommand in a broader way, if one exists let the parent deal with it\n+        auto *parent_app = (parent_ != nullptr) ? _get_fallthrough_parent() : this;\n+        com = parent_app->_find_subcommand(args.back(), true, false);\n+        if(com != nullptr && (com->parent_->require_subcommand_max_ == 0 ||\n+                              com->parent_->require_subcommand_max_ > com->parent_->parsed_subcommands_.size())) {\n+            return false;\n+        }\n     }\n-\n     if(positionals_at_end_) {\n         throw CLI::ExtrasError(name_, args);\n     }\n", "test_patch": "diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml\nindex 86e61e734..98b963557 100644\n--- a/.github/workflows/tests.yml\n+++ b/.github/workflows/tests.yml\n@@ -292,10 +292,10 @@ jobs:\n           cmake-version: \"3.13\"\n         if: success() || failure()\n \n-      - name: Check CMake 3.14\n+      - name: Check CMake 3.14.7\n         uses: ./.github/actions/quick_cmake\n         with:\n-          cmake-version: \"3.14\"\n+          cmake-version: \"3.14.7\"\n           args: -DCLI11_SANITIZERS=ON -DCLI11_BUILD_EXAMPLES_JSON=ON\n         if: success() || failure()\n \n@@ -387,6 +387,6 @@ jobs:\n       - name: Check CMake 3.28 (full)\n         uses: ./.github/actions/quick_cmake\n         with:\n-          cmake-version: \"3.28\"\n+          cmake-version: \"3.28.X\"\n           args: -DCLI11_SANITIZERS=ON -DCLI11_BUILD_EXAMPLES_JSON=ON\n         if: success() || failure()\ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\nindex 6724fca04..53404bc3a 100644\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -4,7 +4,7 @@ if(CLI11_SANITIZERS AND ${CMAKE_VERSION} VERSION_GREATER \"3.13.0\")\n     sanitizers\n     GIT_REPOSITORY https://github.com/arsenm/sanitizers-cmake.git\n     GIT_SHALLOW 1\n-    GIT_TAG 3f0542e)\n+    GIT_TAG 0573e2e)\n \n   FetchContent_GetProperties(sanitizers)\n \ndiff --git a/tests/SubcommandTest.cpp b/tests/SubcommandTest.cpp\nindex b7a8bb97c..dc98a7742 100644\n--- a/tests/SubcommandTest.cpp\n+++ b/tests/SubcommandTest.cpp\n@@ -719,12 +719,25 @@ TEST_CASE_METHOD(TApp, \"Required1SubCom\", \"[subcom]\") {\n     CHECK_THROWS_AS(run(), CLI::RequiredError);\n \n     args = {\"sub1\"};\n-    run();\n+    CHECK_NOTHROW(run());\n \n     args = {\"sub1\", \"sub2\"};\n     CHECK_THROWS_AS(run(), CLI::ExtrasError);\n }\n \n+TEST_CASE_METHOD(TApp, \"subcomNoSubComfallthrough\", \"[subcom]\") {\n+    auto *sub1 = app.add_subcommand(\"sub1\");\n+    std::vector<std::string> pos;\n+    sub1->add_option(\"args\", pos);\n+    app.add_subcommand(\"sub2\");\n+    app.add_subcommand(\"sub3\");\n+    sub1->subcommand_fallthrough(false);\n+    CHECK_FALSE(sub1->get_subcommand_fallthrough());\n+    args = {\"sub1\", \"sub2\", \"sub3\"};\n+    run();\n+    CHECK(pos.size() == 2);\n+}\n+\n TEST_CASE_METHOD(TApp, \"BadSubcommandSearch\", \"[subcom]\") {\n \n     auto *one = app.add_subcommand(\"one\");\n", "problem_statement": "Positional is treated as a sub-command\nCLI11: Version 2.4.1\r\n\r\nI have this setup:\r\n\r\n```c++\r\nint main() {\r\n    CLI::App cli{};\r\n    cli.set_help_flag();\r\n    cli.add_subcommand(\"foo\", \"Does foo\")->parse_complete_callback([&](){std::cout << \"=== Foo doing foo\" << std::endl;});\r\n    cli.add_subcommand(\"bar\", \"Does bar\")->parse_complete_callback([&](){std::cout << \"=== Bar doing bar\" << std::endl;});\r\n    auto *help_cmd = cli.add_subcommand(\"help\", \"Does help\");\r\n    std::string help_for_command;\r\n    auto *help_opt = help_cmd->add_option(\"command\", help_for_command, \"Command to print help for\")->expected(0, 1);\r\n    help_cmd->parse_complete_callback([&]() {\r\n            if (*help_opt) {\r\n                std::cout << \"Print help for \" << help_for_command << std::endl;\r\n            } else {\r\n                CLI::Formatter fmt{};\r\n                std::cout << fmt.make_help(&cli, \"\", CLI::AppFormatMode::Normal) << std::endl;\r\n            }\r\n    });\r\n\r\n    std::cout << \"=> \" << std::flush;\r\n    for (std::string line; std::getline(std::cin, line);) {\r\n        try {\r\n            cli.parse(line);\r\n        } catch (const CLI::ParseError &e) {\r\n            std::cout << e.what() << std::endl;\r\n            std::cout << cli.help();\r\n        }\r\n        std::cout << \"=> \" << std::flush;\r\n    }\r\n}\r\n```\r\n\r\nGiven the above setup, here are some behaviors that I expect:\r\n```\r\nScenario 1\r\nWhen help is called without arguments\r\nThen the help string of all commands is printed\r\n\r\nScenario 2\r\nWhen help is called with one argument\r\nAnd   the argument is a registered (sub)command\r\nThen the help string of this command is printed\r\n\r\nScenario 3\r\nWhen help is called with one argument\r\nAnd   the argument is not a registered (sub)command\r\nThen the help string of all commands is printed\r\n```\r\n\r\nHowever, I get the below output for each scenario:\r\n\r\nScenario 1 \ud83d\udfe2 \r\n```shell\r\n=>help\r\n help\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\n=>\r\n```\r\n\r\nScenario 2 \ud83d\udd34 \r\nNot only the positional is not recognised, it is executed as a sucommand.\r\n```shell\r\n=>help foo\r\n help foo\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\n=== Foo doing foo\r\n=>\r\n```\r\n\r\n```shell\r\n=>help help\r\n help help\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\n=>\r\n```\r\n\r\nScenario 3 \ud83d\udd34 \r\n```shell\r\n=>help other\r\n help other\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\nThe following argument was not expected: other\r\nDoes help\r\nUsage: help [command]\r\n\r\nPositionals:\r\n  command TEXT                Command to print help for\r\n```\r\n\r\n\r\nI've tried using `fallthrough(false)` for `help` command, but with no luck.\r\nHow could I implement my use case?\n", "hints_text": "I think what you want here is to use `prefix_command()` on the help subcommand.  That will force everything that comes after it to be a positional argument.  \r\n\r\nOtherwise subcommands would take precedence over positionals \nThanks for your timely response.\r\n\r\nI've tried it as such, but it didn't help:\r\n\r\n```c++\r\nint main() {\r\n    CLI::App cli{};\r\n    cli.set_help_flag();\r\n    cli.add_subcommand(\"foo\", \"Does foo\")->parse_complete_callback([&](){std::cout << \"=== Foo doing foo\" << std::endl;});\r\n    cli.add_subcommand(\"bar\", \"Does bar\")->parse_complete_callback([&](){std::cout << \"=== Bar doing bar\" << std::endl;});\r\n    auto *help_cmd = cli.add_subcommand(\"help\", \"Does help\");\r\n    std::string help_for_command;\r\n    auto *help_opt = help_cmd->add_option(\"command\", help_for_command, \"Command to print help for\")->expected(0, 1);\r\n    help_cmd\r\n        ->prefix_command()\r\n        ->parse_complete_callback([&]() {\r\n            if (*help_opt) {\r\n                std::cout << \"Print help for \" << help_for_command << std::endl;\r\n            } else {\r\n                CLI::Formatter fmt{};\r\n                std::cout << fmt.make_help(&cli, \"\", CLI::AppFormatMode::Normal) << std::endl;\r\n            }\r\n    });\r\n    ...\r\n}\r\n```\r\n\r\nIs there anything that I'm missing on the above snippet?\nI played with it a bit.   There does seem to be a gap in configuration capability for this scenario.\r\nI believe this code does what you want\r\n```C++\r\nint main() {\r\n    CLI::App cli{};\r\n    cli.set_help_flag();\r\n    cli.add_subcommand(\"foo\", \"Does foo\")->parse_complete_callback([&](){std::cout << \"=== Foo doing foo\" << std::endl;});\r\n    cli.add_subcommand(\"bar\", \"Does bar\")->parse_complete_callback([&](){std::cout << \"=== Bar doing bar\" << std::endl;});\r\n    auto *help_cmd = cli.add_subcommand(\"help\", \"Does help\");\r\n    std::string help_for_command;\r\n    auto *help_opt = help_cmd->add_option(\"command\", help_for_command, \"Command to print help for\");\r\n    help_cmd\r\n        ->preparse_callback([&](size_t values){help_opt->required(values>0);})\r\n        ->parse_complete_callback([&]() {\r\n        if (*help_opt) {\r\n            std::cout << \"Print help for \" << help_for_command << std::endl;\r\n        } else {\r\n            CLI::Formatter fmt{};\r\n            std::cout << fmt.make_help(&cli, \"\", CLI::AppFormatMode::Normal) << std::endl;\r\n        }\r\n            });\r\n    std::cout << \"=> \" << std::flush;\r\n    for (std::string line; std::getline(std::cin, line);) {\r\n        try {\r\n            cli.parse(line);\r\n        } catch (const CLI::ParseError &e) {\r\n            std::cout << e.what() << std::endl;\r\n            std::cout << cli.help();\r\n        }\r\n        std::cout << \"=> \" << std::flush;\r\n    }\r\n    return 0;\r\n}\r\n```\r\nbut it isn't obvious, so there might be a missing option on subcommands that needs to get added for situations like this.  The use for prefix_command is slightly different, so doesn't work in this case.  What the above code does is take advantage of the preparse callback and the fact that required positionals take precedence over subcommands.  \nThank you very much. That seemed to do the trick.\r\n\r\nAn option that does this exact thing would be quite handy.", "created_at": "2024-10-07T16:06:38Z"}

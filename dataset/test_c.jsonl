{"repo": "dunst-project/dunst", "pull_number": 1215, "instance_id": "dunst-project__dunst-1215", "issue_numbers": ["1173"], "base_commit": "5ef093c3e2d4d42a73b84b28231f28e9314d902e", "patch": "diff --git a/.valgrind.suppressions b/.valgrind.suppressions\nindex ce954e3a7..e2515facd 100644\n--- a/.valgrind.suppressions\n+++ b/.valgrind.suppressions\n@@ -6,6 +6,19 @@\n    obj:/lib/ld-musl-x86_64.so.1\n }\n \n+# Ignore another musls' weird error\n+{\n+   musl_alpine_libc\n+   Memcheck:Leak\n+   match-leak-kinds: definite\n+   fun:malloc\n+   fun:realloc\n+   fun:getdelim\n+   obj:*\n+   fun:vgMemCheck_new_block\n+   obj:*\n+}\n+\n # rsvg_error_handle_close got fixed in\n # - GNOME/librsvg@7bf1014\n # (2018-11-12, first tags: v2.45.0, v2.44.9)\ndiff --git a/docs/dunst.5.pod b/docs/dunst.5.pod\nindex 3f4f2acb2..62e9a29b9 100644\n--- a/docs/dunst.5.pod\n+++ b/docs/dunst.5.pod\n@@ -911,7 +911,8 @@ If B<icon_position> is set to off, this setting is ignored.\n \n Updates the icon of the notification, it should be a path or a name for a valid\n image. This overrides the icon that was sent with dunstify or another notification\n-tool.\n+tool. Expansion of the argument is carried out using wordexp(3)\n+with command substitution disabled.\n \n =item C<icon_position> (values: [left/right/top/off], default: left)\n \n@@ -922,7 +923,8 @@ disables icons.\n \n Sets the default icon of the notification, it should be a path or a name for a\n valid image. This does B<not> override the icon that was sent with dunstify or\n-another notification tool.\n+another notification tool. Expansion of the argument is carried out using\n+wordexp(3) with command substitution disabled.\n \n =item C<set_stack_tag>\n \n@@ -1087,9 +1089,10 @@ Note that some variables may be empty.\n If the notification is suppressed, the script will not be run unless\n B<always_run_script> is set to true.\n \n-If '~/' occurs at the beginning of the script parameter, it will get replaced by the\n-users' home directory. If the value is not an absolute path, the directories in the\n-PATH variable will be searched for an executable of the same name.\n+The script parameter is expanded according to wordexp(3) with command\n+substitution disabled. If the expanded value is not an absolute path, the\n+directories in the PATH variable will be searched for an executable of the same\n+name.\n \n =head1 COLORS\n \ndiff --git a/src/utils.c b/src/utils.c\nindex 61bc43d83..e47945717 100644\n--- a/src/utils.c\n+++ b/src/utils.c\n@@ -13,6 +13,7 @@\n #include <sys/stat.h>\n #include <time.h>\n #include <unistd.h>\n+#include <wordexp.h>\n \n #include \"log.h\"\n #include \"settings_data.h\"\n@@ -179,16 +180,34 @@ int string_array_length(char **s)\n /* see utils.h */\n char *string_to_path(char *string)\n {\n-\n-        if (string && STRN_EQ(string, \"~/\", 2)) {\n-                char *home = g_strconcat(user_get_home(), \"/\", NULL);\n-\n-                string = string_replace_at(string, 0, 2, home);\n-\n-                g_free(home);\n+        ASSERT_OR_RET(string, string);\n+\n+        wordexp_t we;\n+        switch (wordexp(string, &we, WRDE_NOCMD | WRDE_UNDEF)) {\n+                case 0:\n+                        break;\n+                case WRDE_BADCHAR:\n+                        LOG_W(\"Expansion of \\\"%s\\\" failed. It contains invalid characters.\", string);\n+                        return string;\n+                case WRDE_BADVAL:\n+                        LOG_W(\"Expansion of \\\"%s\\\" failed. It contains an undefined variable.\", string);\n+                        return string;\n+                case WRDE_CMDSUB:\n+                        LOG_W(\"Expansion of \\\"%s\\\" failed. The requested command substitution is currently not supported.\", string);\n+                        return string;\n+                case WRDE_NOSPACE:\n+                        LOG_W(\"Expansion of \\\"%s\\\" failed. We ran out of memory.\", string);\n+                        return string;\n+                case WRDE_SYNTAX:\n+                        LOG_W(\"Expansion of \\\"%s\\\" failed. It contains invalid syntax.\", string);\n+                        return string;\n         }\n+        g_free(string);\n+\n+        char *res = g_strjoinv(\" \", we.we_wordv);\n+        wordfree(&we);\n \n-        return string;\n+        return res;\n }\n \n /* see utils.h */\n", "test_patch": "diff --git a/test/option_parser.c b/test/option_parser.c\nindex 8773fad10..72d31a67f 100644\n--- a/test/option_parser.c\n+++ b/test/option_parser.c\n@@ -521,9 +521,14 @@ TEST test_string_to_path(void)\n                 \"/path/p argument\",\n                 \"p with multiple arguments\",\n                 \"~/p/p\",\n+                \"$HOME/p/p\",\n+                \"$TEST_ENV/p/p\",\n         };\n \n+        setenv(\"TEST_ENV\", \"foobar\", 1);\n+\n         char *expanded_home = g_strconcat(user_get_home(), \"/\", \"p/p\", NULL);\n+        char *expanded_env = g_strconcat(\"foobar\", \"/p/p\", NULL);\n         const char* results[] = {\n                 \"/bin/something\",\n                 \"something\",\n@@ -531,6 +536,8 @@ TEST test_string_to_path(void)\n                 \"/path/p argument\",\n                 \"p with multiple arguments\",\n                 expanded_home,\n+                expanded_home,\n+                expanded_env,\n         };\n \n         const char* results2[][5] = {\n@@ -540,6 +547,8 @@ TEST test_string_to_path(void)\n                 {\"/path/p\", \"argument\", NULL},\n                 {\"p\", \"with\", \"multiple\", \"arguments\", NULL},\n                 {expanded_home},\n+                {expanded_home},\n+                {expanded_env},\n         };\n \n         ARRAY_SAME_LENGTH(inputs, results);\n@@ -557,6 +566,7 @@ TEST test_string_to_path(void)\n         }\n \n         g_free(val);\n+        g_free(expanded_env);\n         g_free(expanded_home);\n         g_strfreev(val2);\n         PASS();\ndiff --git a/test/utils.c b/test/utils.c\nindex cca574b25..938ebde2a 100644\n--- a/test/utils.c\n+++ b/test/utils.c\n@@ -1,3 +1,5 @@\n+#include <features.h>\n+\n #include \"../src/utils.c\"\n #include \"greatest.h\"\n \n@@ -152,6 +154,7 @@ TEST test_string_to_path(void)\n         ASSERT_STR_EQ(exp, (ptr = string_to_path(g_strdup(exp))));\n         free(ptr);\n \n+        // This might fail, when a user named path exists on the host running the tests.\n         exp = \"~path/with/wrong/tilde\";\n         ASSERT_STR_EQ(exp, (ptr = string_to_path(g_strdup(exp))));\n         free(ptr);\n@@ -166,6 +169,19 @@ TEST test_string_to_path(void)\n         free(exp);\n         free(ptr);\n \n+        ASSERT_STR_EQ((exp = g_strconcat(home, \"/.path/with/HOME environment variable\", NULL)),\n+                      (ptr = string_to_path(g_strdup(\"$HOME/.path/with/HOME environment variable\"))));\n+        free(exp);\n+        free(ptr);\n+\n+// Just glibc properly returns an error when using `WRDE_UNDEF` and an\n+// undefined variable is found. musl accepts this flag and ignores it.\n+#ifdef __GLIBC__\n+        exp = \"/some/$UNDEFINED/variable\";\n+        ASSERT_STR_EQ(exp, (ptr = string_to_path(g_strdup(exp))));\n+        free(ptr);\n+#endif\n+\n         PASS();\n }\n \n", "problem_statement": "Can't set default_icon path with environment variable ($HOME or ~)\n### Issue description\r\n\r\nThe `default_icon` path cannot use the `$HOME` or `~` environment variables. The full path must be specified to for it to work. E.x.: `/home/user/.local/share/icons/my-icon.svg`\r\n\r\n### Installation info\r\n\r\n- Version: `1.91`\r\n- Install type: [Arch package](https://archlinux.org/packages/community/x86_64/dunst/)\r\n- Window manager / Desktop environment: `i3`\r\n- Distro: `Arch Linux`\r\n\r\n<details>\r\n<summary>Minimal dunstrc</summary>\r\n<!-- Try creating a minimal dunstrc that still reproduces the issue and paste it below -->\r\n\r\n```ini\r\n[urgency_low]\r\n    # IMPORTANT: colors have to be defined in quotation marks.\r\n    # Otherwise the \"#\" and following would be interpreted as a comment.\r\n    background = \"#222222\"\r\n    foreground = \"#888888\"\r\n    timeout = 10\r\n    # Icon for notifications with low urgency, uncomment to enable\r\n    default_icon = $HOME/.local/share/icons/urg-low.svg\r\n\r\n[urgency_normal]\r\n    background = \"#285577\"\r\n    foreground = \"#ffffff\"\r\n    timeout = 10\r\n    # Icon for notifications with normal urgency, uncomment to enable\r\n    default_icon = ~/.local/share/icons/urg-norm.svg\r\n\r\n[urgency_critical]\r\n    background = \"#900000\"\r\n    foreground = \"#ffffff\"\r\n    frame_color = \"#ff0000\"\r\n    timeout = 0\r\n    # Icon for notifications with critical urgency, uncomment to enable\r\n    default_icon = $HOME/.local/share/icons/urg-crit.svg\r\n```\r\n</details>\r\n\r\n### Additional information\r\n\r\nThe config above is copied from the example config: lines 313-335. This is identical to my `dunstrc`, minus the actual `default_icon` path and colors.\r\n\r\nTo resolve this issue, I have tried things such as replacing `default_icon` with `new_icon` and `icon`. I have also tried changing the `icon_path`, which points to the directory holding the images for the icons.\r\n\r\nAccording to #520 this issue was fixed and merged 4 years ago, so I'm not sure why I can't get it working.\r\n\r\nI can confirm that the environment variables work in a shell script using `dunstify`.\r\n\n", "hints_text": "", "created_at": "2023-10-23T14:13:45Z"}
{"repo": "dunst-project/dunst", "pull_number": 914, "instance_id": "dunst-project__dunst-914", "issue_numbers": ["900"], "base_commit": "82c8c06907df9cc653fd108adca9a84ca5de36e0", "patch": "diff --git a/src/utils.c b/src/utils.c\nindex f1d5fd52c..031d285cc 100644\n--- a/src/utils.c\n+++ b/src/utils.c\n@@ -124,14 +124,25 @@ void string_strip_delimited(char *str, char a, char b)\n         assert(str);\n \n         int iread=-1, iwrite=0, copen=0;\n+        int cskip = 0;\n         while (str[++iread] != 0) {\n                 if (str[iread] == a) {\n                         ++copen;\n                 } else if (str[iread] == b && copen > 0) {\n                         --copen;\n                 } else if (copen == 0) {\n+                        cskip = 0;\n                         str[iwrite++] = str[iread];\n                 }\n+                if (copen > 0){\n+                        cskip++;\n+                }\n+        }\n+        if (copen > 0) {\n+                iread -= cskip;\n+                for (int i = 0; i < cskip; i++) {\n+                        str[iwrite++] = str[iread++];\n+                }\n         }\n         str[iwrite] = 0;\n }\n", "test_patch": "diff --git a/test/markup.c b/test/markup.c\nindex 0644dd2d5..da6521acf 100644\n--- a/test/markup.c\n+++ b/test/markup.c\n@@ -15,7 +15,7 @@ TEST test_markup_strip(void)\n         g_free(ptr);\n         ASSERT_STR_EQ(\"&amp;\", (ptr=markup_strip(g_strdup(\"&amp;amp;\"))));\n         g_free(ptr);\n-        ASSERT_STR_EQ(\">A  \", (ptr=markup_strip(g_strdup(\">A <img> <string\"))));\n+        ASSERT_STR_EQ(\">A  <string\", (ptr=markup_strip(g_strdup(\">A <img> <string\"))));\n         g_free(ptr);\n \n         PASS();\ndiff --git a/test/utils.c b/test/utils.c\nindex bb793752d..ade0e298d 100644\n--- a/test/utils.c\n+++ b/test/utils.c\n@@ -119,10 +119,6 @@ TEST test_string_strip_delimited(void)\n         string_strip_delimited(text, '<', '>');\n         ASSERT_STR_EQ(\"Remove html tags\", text);\n \n-        strcpy(text, \"Calls|with|identical|delimiters|are|handled|properly\");\n-        string_strip_delimited(text, '|', '|');\n-        ASSERT_STR_EQ(\"Calls\", text);\n-\n         strcpy(text, \"<Return empty string if there is nothing left>\");\n         string_strip_delimited(text, '<', '>');\n         ASSERT_STR_EQ(\"\", text);\n@@ -131,6 +127,18 @@ TEST test_string_strip_delimited(void)\n         string_strip_delimited(text, '<', '>');\n         ASSERT_STR_EQ(\"Nothing is done if there are no delimiters in the string\", text);\n \n+        strcpy(text, \"We <3 dunst\");\n+        string_strip_delimited(text, '<', '>');\n+        ASSERT_STR_EQ(\"We <3 dunst\", text);\n+\n+        strcpy(text, \"<b>We</b> <3 dunst\");\n+        string_strip_delimited(text, '<', '>');\n+        ASSERT_STR_EQ(\"We <3 dunst\", text);\n+\n+        strcpy(text, \"dunst > the rest\");\n+        string_strip_delimited(text, '<', '>');\n+        ASSERT_STR_EQ(\"dunst > the rest\", text);\n+\n         g_free(text);\n         PASS();\n }\n", "problem_statement": "Opening angle bracket \"<\" breaks rendering\n`notify-send  \"title\"  \"We <3 dunst\"` shows up as:  \r\n\r\n![image](https://user-images.githubusercontent.com/1058151/132224981-c97cc72d-fefd-4264-bbf9-b413a85de8fb.png)\r\n\r\n`notify-send  \"title\"  \"We <3> dunst\"`:  \r\n\r\n![image](https://user-images.githubusercontent.com/1058151/132225032-4c4525ea-b4a1-408c-a2a0-104530fe368e.png)\r\n\r\nEven a mere `notify-send  \"title\"  \"We < dunst\"` shows up cut off at <.\r\n\r\nI have activated markup support in my dunstrc, but I think dunst should ignore these strings because they are incomplete and do not collide with supported tags (b, i, s, u).\r\n### Installation info\r\n- Version: `v1.6.1`\r\n- Install type: `manual`\r\n- Distro and version: `Xubuntu 18.04+i3-gaps `\r\n\n", "hints_text": "Pretty sure this is caused by the markup setting in the config\r\n```\r\n    # Possible values are:\r\n    # full: Allow a small subset of html markup in notifications:\r\n    #        <b>bold</b>\r\n    #        <i>italic</i>\r\n    #        <s>strikethrough</s>\r\n    #        <u>underline</u>\r\n    #\r\n    #        For a complete reference see\r\n    #        <https://developer.gnome.org/pango/stable/pango-Markup.html>.\r\n    #\r\n    # strip: This setting is provided for compatibility with some broken\r\n    #        clients that send markup even though it's not enabled on the\r\n    #        server. Dunst will try to strip the markup but the parsing is\r\n    #        simplistic so using this option outside of matching rules for\r\n    #        specific applications *IS GREATLY DISCOURAGED*.\r\n    #\r\n    # no:    Disable markup parsing, incoming notifications will be treated as\r\n    #        plain text. Dunst will not advertise that it has the body-markup\r\n    #        capability if this is set as a global setting.\r\n    #\r\n    # It's important to note that markup inside the format option will be parsed\r\n    # regardless of what this is set to.\r\n    markup = full\r\n\r\n```\r\nTurning this to no should fix it but it is still a problem... \r\n\r\n`notify-send \"title\" \"We \\<3 dunst\"` doesn't fix it also.\nIf you're using markup=full, the markup is completely handled by pango, so you should report a bug there. If you use markup=strip you can see there's a warning in the documentation that it's not perfect and this would not be considered a bug.\nEither way, I believe this issue can be closed on our side. \n[Link to the issues page of pango](https://gitlab.gnome.org/GNOME/pango/-/issues?scope=all&state=opened&search=%3C)\nI created a pango issue [here](https://gitlab.gnome.org/GNOME/pango/-/issues/612)\nTurns out, this is not a pango bug, but intended behaviour It's just plain xml. We should encode `<` with `&lt;` and to prevent accidental encodings, replace `&` with `&amp;`.\n@fwSmit You mean dunst should respect HTML entities? It seems pango is not implementing [all html entities](https://dev.w3.org/html5/html-author/charref). I didn't find relevant info on what chars to escape in [pango docs](https://docs.gtk.org/Pango).  \r\n\r\nSo at this point, I think our best bet is `sed`ing `<` with `&lt;` before piping the string to `notify-send`\n> @fwSmit You mean dunst should respect HTML entities? It seems pango is not implementing [all html entities](https://dev.w3.org/html5/html-author/charref). I didn't find relevant info on what chars to escape in [pango docs](https://docs.gtk.org/Pango).  \n\nThe docs aren't clear on this, but at least & and < have to be encoded. I think I'll encode \", ' and > too just to be safe. \n\n\n> So at this point, I think our best bet is `sed`ing `<` with `&lt;` before piping the string to `notify-send`\n\nNo I'll implement it inside of dunst. Then it won't matter what is passed via notify-send\n\nI wasn't entirely correct here. Since you're allowed to put markup in the notification body, we can't just escape all markup symbols. The right solution is indeed to make sure you escape any markup symbols you want to send.\nWe can, however improve the way incorrect notifications are handled. Too much of the notification is stripped away, resulting in what you've noticed ", "created_at": "2021-09-21T10:15:23Z"}
{"repo": "redis/hiredis", "pull_number": 427, "instance_id": "redis__hiredis-427", "issue_numbers": ["426"], "base_commit": "e93c05a7aa64736c91e455322c83181e8e67cd0e", "patch": "diff --git a/hiredis.c b/hiredis.c\nindex 2b876d913..18bdfc99c 100644\n--- a/hiredis.c\n+++ b/hiredis.c\n@@ -507,7 +507,7 @@ int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,\n     cmd = sdscatfmt(cmd, \"*%i\\r\\n\", argc);\n     for (j=0; j < argc; j++) {\n         len = argvlen ? argvlen[j] : strlen(argv[j]);\n-        cmd = sdscatfmt(cmd, \"$%T\\r\\n\", len);\n+        cmd = sdscatfmt(cmd, \"$%u\\r\\n\", len);\n         cmd = sdscatlen(cmd, argv[j], len);\n         cmd = sdscatlen(cmd, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n     }\n", "test_patch": "diff --git a/test.c b/test.c\nindex 538d37658..a23d60676 100644\n--- a/test.c\n+++ b/test.c\n@@ -224,6 +224,22 @@ static void test_format_commands(void) {\n     test_cond(strncmp(cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n         len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n     free(cmd);\n+\n+    sds sds_cmd;\n+\n+    sds_cmd = sdsempty();\n+    test(\"Format command into sds by passing argc/argv without lengths: \");\n+    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,NULL);\n+    test_cond(strncmp(sds_cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n+        len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n+    sdsfree(sds_cmd);\n+\n+    sds_cmd = sdsempty();\n+    test(\"Format command into sds by passing argc/argv with lengths: \");\n+    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,lens);\n+    test_cond(strncmp(sds_cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n\",len) == 0 &&\n+        len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n+    sdsfree(sds_cmd);\n }\n \n static void test_append_formatted_commands(struct config config) {\n", "problem_statement": "Typo format in redisFormatSdsCommandArgv function\nthis issue is very significant, because not allow the proper execution of the \"function redisCommandArgv\". The server returns \"invalid bulk length\".\nThanks!\n\n", "hints_text": "", "created_at": "2016-05-14T09:26:51Z"}
{"repo": "redis/hiredis", "pull_number": 819, "instance_id": "redis__hiredis-819", "issue_numbers": ["815"], "base_commit": "c8999c66024b0de347adecb774d14963c08a66db", "patch": "diff --git a/async.c b/async.c\nindex 6990e86cb..68a656ffd 100644\n--- a/async.c\n+++ b/async.c\n@@ -374,7 +374,7 @@ static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply,\n \n     /* Custom reply functions are not supported for pub/sub. This will fail\n      * very hard when they are used... */\n-    if (reply->type == REDIS_REPLY_ARRAY) {\n+    if (reply->type == REDIS_REPLY_ARRAY || reply->type == REDIS_REPLY_PUSH) {\n         assert(reply->elements >= 2);\n         assert(reply->element[0]->type == REDIS_REPLY_STRING);\n         stype = reply->element[0]->str;\ndiff --git a/hiredis.c b/hiredis.c\nindex deb65a929..1c9e8ae5a 100644\n--- a/hiredis.c\n+++ b/hiredis.c\n@@ -97,6 +97,7 @@ void freeReplyObject(void *reply) {\n     case REDIS_REPLY_ARRAY:\n     case REDIS_REPLY_MAP:\n     case REDIS_REPLY_SET:\n+    case REDIS_REPLY_PUSH:\n         if (r->element != NULL) {\n             for (j = 0; j < r->elements; j++)\n                 freeReplyObject(r->element[j]);\n@@ -155,7 +156,8 @@ static void *createStringObject(const redisReadTask *task, char *str, size_t len\n         parent = task->parent->obj;\n         assert(parent->type == REDIS_REPLY_ARRAY ||\n                parent->type == REDIS_REPLY_MAP ||\n-               parent->type == REDIS_REPLY_SET);\n+               parent->type == REDIS_REPLY_SET ||\n+               parent->type == REDIS_REPLY_PUSH);\n         parent->element[task->idx] = r;\n     }\n     return r;\n@@ -201,7 +203,8 @@ static void *createIntegerObject(const redisReadTask *task, long long value) {\n         parent = task->parent->obj;\n         assert(parent->type == REDIS_REPLY_ARRAY ||\n                parent->type == REDIS_REPLY_MAP ||\n-               parent->type == REDIS_REPLY_SET);\n+               parent->type == REDIS_REPLY_SET ||\n+               parent->type == REDIS_REPLY_PUSH);\n         parent->element[task->idx] = r;\n     }\n     return r;\ndiff --git a/read.c b/read.c\nindex 835eb65fb..4924014d7 100644\n--- a/read.c\n+++ b/read.c\n@@ -250,7 +250,8 @@ static void moveToNextTask(redisReader *r) {\n         prv = r->task[r->ridx-1];\n         assert(prv->type == REDIS_REPLY_ARRAY ||\n                prv->type == REDIS_REPLY_MAP ||\n-               prv->type == REDIS_REPLY_SET);\n+               prv->type == REDIS_REPLY_SET ||\n+               prv->type == REDIS_REPLY_PUSH);\n         if (cur->idx == prv->elements-1) {\n             r->ridx--;\n         } else {\n@@ -562,6 +563,9 @@ static int processItem(redisReader *r) {\n             case '=':\n                 cur->type = REDIS_REPLY_VERB;\n                 break;\n+            case '>':\n+                cur->type = REDIS_REPLY_PUSH;\n+                break;\n             default:\n                 __redisReaderSetErrorProtocolByte(r,*p);\n                 return REDIS_ERR;\n@@ -587,6 +591,7 @@ static int processItem(redisReader *r) {\n     case REDIS_REPLY_ARRAY:\n     case REDIS_REPLY_MAP:\n     case REDIS_REPLY_SET:\n+    case REDIS_REPLY_PUSH:\n         return processAggregateItem(r);\n     default:\n         assert(NULL);\n", "test_patch": "diff --git a/test.c b/test.c\nindex 8e45e78d8..1d38caa6f 100644\n--- a/test.c\n+++ b/test.c\n@@ -488,6 +488,21 @@ static void test_reply_reader(void) {\n          !memcmp(((redisReply*)reply)->str,\"LOLWUT\", 6));\n     freeReplyObject(reply);\n     redisReaderFree(reader);\n+\n+    /* RESP3 push messages (Github issue #815) */\n+    test(\"Can parse RESP3 push messages: \");\n+    reader = redisReaderCreate();\n+    redisReaderFeed(reader,(char*)\">2\\r\\n$6\\r\\nLOLWUT\\r\\n:42\\r\\n\",21);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret == REDIS_OK &&\n+        ((redisReply*)reply)->type == REDIS_REPLY_PUSH &&\n+        ((redisReply*)reply)->elements == 2 &&\n+        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STRING &&\n+        !memcmp(((redisReply*)reply)->element[0]->str,\"LOLWUT\",6) &&\n+        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&\n+        ((redisReply*)reply)->element[1]->integer == 42);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n }\n \n static void test_free_null(void) {\n", "problem_statement": "Asynchronous PSUBSCRIBE command fails when using RESP3\nThe following toy implementation shows how execution of asynchronous `PSUBSCRIBE` command using current `RESP3` support in master (i.e. https://github.com/redis/hiredis/pull/805 already merged) fails with error `Protocol error, got \">\" as reply type byte`. This has been tested using Redis Server 6.0.3. Same logic using RESP2 works as expected.\r\n\r\n```\r\n// gcc test.c -o test -Wall -lhiredis -lev\r\n// redis-server --port 6400\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <assert.h>\r\n#include <hiredis/hiredis.h>\r\n#include <hiredis/async.h>\r\n#include <hiredis/adapters/libev.h>\r\n\r\n#define HOST \"127.0.0.1\"\r\n#define PORT 6400\r\n#define PROTOCOL 3\r\n\r\nstatic void\r\nconnectCallback(const redisAsyncContext *ctx, int status)\r\n{\r\n    if (status != REDIS_OK) {\r\n        printf(\"CONNECT CB: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        exit(1);\r\n    }\r\n}\r\n\r\nstatic void\r\ndisconnectCallback(const redisAsyncContext *ctx, int status)\r\n{\r\n    if (status != REDIS_OK) {\r\n        printf(\"DISCONNECT CB: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        exit(1);\r\n    }\r\n}\r\n\r\nstatic void\r\nhelloCallback(redisAsyncContext *context, void *r, void *s)\r\n{\r\n    redisReply *reply = r;\r\n    assert(\r\n        reply != NULL &&\r\n        (reply->type == REDIS_REPLY_ARRAY ||\r\n         reply->type == REDIS_REPLY_MAP));\r\n    printf(\"HELLO CB: %d\\n\", reply->type);\r\n}\r\n\r\nstatic void\r\npsubscribeCallback(redisAsyncContext *context, void *r, void *s)\r\n{\r\n    redisReply *reply = r;\r\n    if (reply != NULL) {\r\n        printf(\"PSUBSCRIBE CB: %d\\n\", reply->type);\r\n    }\r\n}\r\n\r\nstatic redisAsyncContext *\r\nconnect(unsigned version, struct ev_loop *loop)\r\n{\r\n    redisAsyncContext *ctx = redisAsyncConnect(HOST, PORT);\r\n    assert(ctx != NULL);\r\n    if (ctx->err) {\r\n        printf(\"CONNECT: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        exit(1);\r\n    }\r\n\r\n    redisLibevAttach(loop, ctx);\r\n    redisAsyncSetConnectCallback(ctx, connectCallback);\r\n    redisAsyncSetDisconnectCallback(ctx, disconnectCallback);\r\n\r\n    if (redisAsyncCommand(ctx, helloCallback, NULL, \"HELLO %d\", version) != REDIS_OK) {\r\n        if (ctx->err) {\r\n            printf(\"HELLO: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        }\r\n        exit(1);\r\n    }\r\n\r\n    if (redisAsyncCommand(ctx, psubscribeCallback, NULL, \"PSUBSCRIBE foo bar\") != REDIS_OK) {\r\n        if (ctx->err) {\r\n            printf(\"PSUBSCRIBE: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        }\r\n        exit(1);\r\n    }\r\n\r\n    return ctx;\r\n}\r\n\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\n    struct ev_loop *loop = ev_loop_new(EVFLAG_AUTO);\r\n    assert(loop != NULL);\r\n    assert(connect(PROTOCOL, loop) != NULL);\r\n    while (1) {\r\n        ev_loop(loop, EVRUN_NOWAIT);\r\n        usleep(500000);\r\n    }\r\n}\r\n```\n", "hints_text": "Thanks, I'll take a look.\r\n\r\nActually I think `>` is RESP3 for out-of-band \"push\" notifications.  This might be a non-trivial change.\r\n\r\nWe should probably do it but it will warrant discussion around whether it's out of scope for a \"minimalist\" Redis library.\r\n\r\nEdit:  The bug also exists in `redis-cli` on current unstable:\r\n\r\n```bash\r\n$ redis-cli \r\n127.0.0.1:6379> hello 3\r\n1# \"server\" => \"redis\"\r\n2# \"version\" => \"999.999.999\"\r\n3# \"proto\" => (integer) 3\r\n4# \"id\" => (integer) 5\r\n5# \"mode\" => \"standalone\"\r\n6# \"role\" => \"master\"\r\n7# \"modules\" => (empty array)\r\n127.0.0.1:6379> subscribe foo\r\nReading messages... (press Ctrl-C to quit)\r\nError: Protocol error, got \">\" as reply type byte\r\n```", "created_at": "2020-05-21T16:17:44Z"}
{"repo": "redis/hiredis", "pull_number": 1215, "instance_id": "redis__hiredis-1215", "issue_numbers": ["1185"], "base_commit": "e07ae7d3b6248be8be842eca3e1e97595a17aa1a", "patch": "diff --git a/.gitignore b/.gitignore\nindex 056959ffe..c223f299a 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -7,3 +7,4 @@\n /*.pc\n *.dSYM\n tags\n+compile_commands.json\ndiff --git a/net.c b/net.c\nindex c7d827139..8b7831e35 100644\n--- a/net.c\n+++ b/net.c\n@@ -173,6 +173,10 @@ int redisKeepAlive(redisContext *c, int interval) {\n     int val = 1;\n     redisFD fd = c->fd;\n \n+    /* TCP_KEEPALIVE makes no sense with AF_UNIX connections */\n+    if (c->connection_type == REDIS_CONN_UNIX)\n+        return REDIS_ERR;\n+\n #ifndef _WIN32\n     if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1){\n         __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));\n", "test_patch": "diff --git a/test.c b/test.c\nindex 45914af42..897daf8fe 100644\n--- a/test.c\n+++ b/test.c\n@@ -431,6 +431,24 @@ static void test_tcp_options(struct config cfg) {\n     redisFree(c);\n }\n \n+static void test_unix_keepalive(struct config cfg) {\n+    redisContext *c;\n+    redisReply *r;\n+\n+    c = do_connect(cfg);\n+\n+    test(\"Setting TCP_KEEPALIVE on a unix socket returns an error: \");\n+    test_cond(redisEnableKeepAlive(c) == REDIS_ERR && c->err == 0);\n+\n+    test(\"Setting TCP_KEEPALIVE on a unix socket doesn't break the connection: \");\n+    r = redisCommand(c, \"PING\");\n+    test_cond(r != NULL && r->type == REDIS_REPLY_STATUS && r->len == 4 &&\n+              !memcmp(r->str, \"PONG\", 4));\n+    freeReplyObject(r);\n+\n+    redisFree(c);\n+}\n+\n static void test_reply_reader(void) {\n     redisReader *reader;\n     void *reply, *root;\n@@ -2363,6 +2381,7 @@ int main(int argc, char **argv) {\n         test_blocking_connection_timeouts(cfg);\n         test_blocking_io_errors(cfg);\n         test_invalid_timeout_errors(cfg);\n+        test_unix_keepalive(cfg);\n         if (throughput) test_throughput(cfg);\n     } else {\n         test_skipped();\n", "problem_statement": "Improvement: More specific error message when calling redisEnableKeepAlive() with unix socket\nUnix sockets don't support setsockopt `TCP_KEEPALIVE` and currently the error message is set to `strerror(errno)`: \"Operation not supported\". While this is totally valid I suggest to explicitly catch this case and return a more specific error message. E.g.:\r\n\r\n```\r\ndiff --git a/net.c b/net.c\r\nindex ec96412..114f597 100644\r\n--- a/net.c\r\n+++ b/net.c\r\n@@ -172,6 +172,11 @@ int redisKeepAlive(redisContext *c, int interval) {\r\n     int val = 1;\r\n     redisFD fd = c->fd;\r\n \r\n+    if (c->connection_type == REDIS_CONN_UNIX) {\r\n+        __redisSetError(c,REDIS_ERR_OTHER,\"Keepalive not supported for unix socket\");\r\n+        return REDIS_ERR;\r\n+    }\r\n+\r\n #ifndef _WIN32\r\n     if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1){\r\n         __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));\r\n```\r\n\r\nOr maybe it would also be an option to only print a warning in this case. What do you think?\n", "hints_text": "It's actually a good question.\r\n\r\nTypically I handle this in the application logic, but I don't see any harm in providing a more helpful error message.  I don't think we really have the option to print an error though.  We'd need to stay consistent and set the error in the context like you're suggesting.\r\n\r\nEdit:  An alternative approach would be to treat the operation as a no-op if it's an `AF_UNIX` connection.", "created_at": "2023-07-31T22:54:21Z"}
{"repo": "redis/hiredis", "pull_number": 1097, "instance_id": "redis__hiredis-1097", "issue_numbers": ["956"], "base_commit": "eaae7321c2c84c45f40ccb01233d299644f4e786", "patch": "diff --git a/fuzzing/format_command_fuzzer.c b/fuzzing/format_command_fuzzer.c\nindex 91adeac58..de125e08d 100644\n--- a/fuzzing/format_command_fuzzer.c\n+++ b/fuzzing/format_command_fuzzer.c\n@@ -48,10 +48,9 @@ int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n     memcpy(new_str, data, size);\n     new_str[size] = '\\0';\n \n-    redisFormatCommand(&cmd, new_str);\n-\n-    if (cmd != NULL)\n+    if (redisFormatCommand(&cmd, new_str) != -1)\n         hi_free(cmd);\n+\n     free(new_str);\n     return 0;\n }\ndiff --git a/hiredis.c b/hiredis.c\nindex 91086f6f6..b2b4d1f58 100644\n--- a/hiredis.c\n+++ b/hiredis.c\n@@ -399,6 +399,11 @@ int redisvFormatCommand(char **target, const char *format, va_list ap) {\n                     /* Copy va_list before consuming with va_arg */\n                     va_copy(_cpy,ap);\n \n+                    /* Make sure we have more characters otherwise strchr() accepts\n+                     * '\\0' as an integer specifier. This is checked after above\n+                     * va_copy() to avoid UB in fmt_invalid's call to va_end(). */\n+                    if (*_p == '\\0') goto fmt_invalid;\n+\n                     /* Integer conversion (without modifiers) */\n                     if (strchr(intfmts,*_p) != NULL) {\n                         va_arg(ap,int);\n", "test_patch": "diff --git a/test.c b/test.c\nindex b90175214..3b98dda96 100644\n--- a/test.c\n+++ b/test.c\n@@ -330,10 +330,14 @@ static void test_format_commands(void) {\n     FLOAT_WIDTH_TEST(float);\n     FLOAT_WIDTH_TEST(double);\n \n-    test(\"Format command with invalid printf format: \");\n+    test(\"Format command with unhandled printf format (specifier 'p' not supported): \");\n     len = redisFormatCommand(&cmd,\"key:%08p %b\",(void*)1234,\"foo\",(size_t)3);\n     test_cond(len == -1);\n \n+    test(\"Format command with invalid printf format (specifier missing): \");\n+    len = redisFormatCommand(&cmd,\"%-\");\n+    test_cond(len == -1);\n+\n     const char *argv[3];\n     argv[0] = \"SET\";\n     argv[1] = \"foo\\0xxx\";\n", "problem_statement": "\u3010fuzz\u3011heap-buffer-overflow\n\r\n1\u3001python infra/helper.py build_fuzzers --sanitizer address hiredis\r\n2\u3001python infra/helper.py run_fuzzer hiredis format_command_fuzzer -rss_limit_mb=0\r\n\r\n==13==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000024715 at pc 0x00000054f1bb bp 0x7ffc63cf1490 sp 0x7ffc63cf1488\r\nREAD of size 1 at 0x602000024715 thread T0\r\nSCARINESS: 12 (1-byte-read-heap-buffer-overflow)\r\n    #0 0x54f1ba in redisvFormatCommand /src/hiredis/hiredis.c:231:11\r\n    #1 0x54f45e in redisFormatCommand /src/hiredis/hiredis.c:460:11\r\n    #2 0x54d599 in LLVMFuzzerTestOneInput /src/hiredis/format_command_fuzzer.c:51:5\r\n    #3 0x458241 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:556:15\r\n    #4 0x457985 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:470:3\r\n    #5 0x459a57 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:698:19\r\n    #6 0x45a4d5 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:832:5\r\n    #7 0x4494ae in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:826:6\r\n    #8 0x471c82 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10\r\n    #9 0x7ff76646882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\r\n    #10 0x41dbb8 in _start (/out/format_command_fuzzer+0x41dbb8)\r\n\r\n0x602000024715 is located 0 bytes to the right of 5-byte region [0x602000024710,0x602000024715)\r\nallocated by thread T0 here:\r\n    #0 0x51d8fd in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3\r\n    #1 0x54d54a in LLVMFuzzerTestOneInput /src/hiredis/format_command_fuzzer.c:44:15\r\n    #2 0x458241 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:556:15\r\n    #3 0x457985 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:470:3\r\n    #4 0x459a57 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:698:19\r\n    #5 0x45a4d5 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:832:5\r\n    #6 0x4494ae in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:826:6\r\n    #7 0x471c82 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10\r\n    #8 0x7ff76646882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)\r\nSUMMARY: AddressSanitizer: heap-buffer-overflow /src/hiredis/hiredis.c:231:11 in redisvFormatCommand\r\nShadow bytes around the buggy address:\r\n  0x0c047fffc890: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd\r\n  0x0c047fffc8a0: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd\r\n  0x0c047fffc8b0: fa fa fd fa fa fa fd fd fa fa fd fd fa fa fd fd\r\n  0x0c047fffc8c0: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd\r\n  0x0c047fffc8d0: fa fa fd fa fa fa fd fd fa fa fd fd fa fa 04 fa\r\n=>0x0c047fffc8e0: fa fa[05]fa fa fa fd fd fa fa 00 03 fa fa 00 fa\r\n  0x0c047fffc8f0: fa fa 00 01 fa fa fd fd fa fa fa fa fa fa fa fa\r\n  0x0c047fffc900: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c047fffc910: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c047fffc920: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c047fffc930: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\nHeap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n  Shadow gap:              cc\r\n==13==ABORTING\r\nMS: 4 InsertByte-ChangeByte-CopyPart-CrossOver-; base unit: 3b14a47b85ca3137afa69b9a883507a1bb29eeb8\r\n0x23,0x20,0x25,0x20,\r\n# %\r\nartifact_prefix='./'; Test unit written to ./crash-9178db74f1ab7d2b70b823088539af55ad353c9d\r\n\n", "hints_text": "", "created_at": "2022-09-01T15:31:31Z"}
{"repo": "nanomsg/nng", "pull_number": 1082, "instance_id": "nanomsg__nng-1082", "issue_numbers": ["1080"], "base_commit": "0ab3403ef9407db4604cbb451c42a179ab807342", "patch": "diff --git a/docs/man/CMakeLists.txt b/docs/man/CMakeLists.txt\nindex ad397314d..f357d60ac 100644\n--- a/docs/man/CMakeLists.txt\n+++ b/docs/man/CMakeLists.txt\n@@ -9,417 +9,421 @@\n # found online at https://opensource.org/licenses/MIT.\n \n # We default to off here.\n-option (NNG_ENABLE_DOC \"Enable building documentation.\" OFF)\n+option(NNG_ENABLE_DOC \"Enable building documentation.\" OFF)\n \n if (NNG_ENABLE_DOC)\n-    find_program (ASCIIDOCTOR asciidoctor)\n+    find_program(ASCIIDOCTOR asciidoctor)\n     if (NOT ASCIIDOCTOR)\n-        message (WARNING \"Could not find asciidoctor: skipping docs\")\n-        set (NNG_ENABLE_DOC OFF)\n+        message(WARNING \"Could not find asciidoctor: skipping docs\")\n+        set(NNG_ENABLE_DOC OFF)\n     else ()\n-        message (STATUS \"Using asciidoctor at ${ASCIIDOCTOR}\")\n+        message(STATUS \"Using asciidoctor at ${ASCIIDOCTOR}\")\n     endif ()\n endif ()\n \n if (NNG_ENABLE_DOC)\n-    set (NNG_DOCDIR ${CMAKE_CURRENT_SOURCE_DIR})\n+    set(NNG_DOCDIR ${CMAKE_CURRENT_SOURCE_DIR})\n \n-    set (NNG_A2M ${ASCIIDOCTOR} -b manpage -amanmanual='NNG Reference Manual')\n-    set (NNG_A2H ${ASCIIDOCTOR} -a nofooter -atoc=left -aicons=font -d manpage -b html5)\n+    set(NNG_A2M ${ASCIIDOCTOR} -b manpage -amanmanual='NNG Reference Manual')\n+    set(NNG_A2H ${ASCIIDOCTOR} -a nofooter -atoc=left -aicons=font -d manpage -b html5)\n \n-    macro (nng_man NAME SECT)\n+    macro(nng_man NAME SECT)\n \n-    add_custom_command (\n-        OUTPUT ${NAME}.${SECT}\n-        COMMAND ${NNG_A2M} -o ${NAME}.${SECT} ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n-        MAIN_DEPENDENCY ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n-    )\n+        add_custom_command(\n+                OUTPUT ${NAME}.${SECT}\n+                COMMAND ${NNG_A2M} -o ${NAME}.${SECT} ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n+                MAIN_DEPENDENCY ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n+        )\n \n-    add_custom_command (\n-        OUTPUT ${NAME}.${SECT}.html\n-        COMMAND ${NNG_A2H} -o ${NAME}.${SECT}.html ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n-        MAIN_DEPENDENCY ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n-    )\n+        add_custom_command(\n+                OUTPUT ${NAME}.${SECT}.html\n+                COMMAND ${NNG_A2H} -o ${NAME}.${SECT}.html ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n+                MAIN_DEPENDENCY ${NNG_DOCDIR}/${NAME}.${SECT}.adoc\n+        )\n \n-    set(NNG_MANS ${NNG_MANS} ${NAME}.${SECT})\n-    set(NNG_HTMLS ${NNG_HTMLS} ${NAME}.${SECT}.html)\n+        set(NNG_MANS ${NNG_MANS} ${NAME}.${SECT})\n+        set(NNG_HTMLS ${NNG_HTMLS} ${NAME}.${SECT}.html)\n \n-    install (\n-        FILES ${CMAKE_CURRENT_BINARY_DIR}/${NAME}.${SECT}.html\n-        DESTINATION ${CMAKE_INSTALL_DOCDIR}\n-    )\n-    install (\n-        FILES ${CMAKE_CURRENT_BINARY_DIR}/${NAME}.${SECT}\n-        DESTINATION ${CMAKE_INSTALL_MANDIR}/man${SECT}\n-    )\n+        install(\n+                FILES ${CMAKE_CURRENT_BINARY_DIR}/${NAME}.${SECT}.html\n+                DESTINATION ${CMAKE_INSTALL_DOCDIR}\n+        )\n+        install(\n+                FILES ${CMAKE_CURRENT_BINARY_DIR}/${NAME}.${SECT}\n+                DESTINATION ${CMAKE_INSTALL_MANDIR}/man${SECT}\n+        )\n \n-    endmacro (nng_man)\n+    endmacro(nng_man)\n \n-    set (NNG_MAN1\n-\tnngcat\n-    )\n+    set(NNG_MAN1\n+            nngcat\n+            )\n \n-    set (NNG_MAN3\n-\tlibnng\n-\tnng_aio_abort\n-\tnng_aio_alloc\n-\tnng_aio_begin\n-\tnng_aio_cancel\n-\tnng_aio_count\n-\tnng_aio_defer\n-\tnng_aio_finish\n-\tnng_aio_free\n-\tnng_aio_get_input\n-\tnng_aio_get_msg\n-\tnng_aio_get_output\n-\tnng_aio_result\n-\tnng_aio_set_input\n-\tnng_aio_set_iov\n-\tnng_aio_set_msg\n-\tnng_aio_set_output\n-\tnng_aio_set_timeout\n-\tnng_aio_stop\n-\tnng_aio_wait\n-\tnng_alloc\n-\tnng_bus_open\n-\tnng_close\n-\tnng_ctx_close\n-\tnng_ctx_get\n-\tnng_ctx_getopt\n-\tnng_ctx_id\n-\tnng_ctx_open\n-\tnng_ctx_recv\n-\tnng_ctx_send\n-\tnng_ctx_set\n-\tnng_ctx_setopt\n-\tnng_device\n-\tnng_dial\n-\tnng_dialer_close\n-\tnng_dialer_create\n-\tnng_dialer_get\n-\tnng_dialer_getopt\n-\tnng_dialer_id\n-\tnng_dialer_set\n-\tnng_dialer_setopt\n-\tnng_dialer_start\n-\tnng_free\n-\tnng_getopt\n-\tnng_inproc_register\n-\tnng_ipc_register\n-\tnng_listen\n-\tnng_listener_close\n-\tnng_listener_create\n-\tnng_listener_get\n-\tnng_listener_getopt\n-\tnng_listener_id\n-\tnng_listener_set\n-\tnng_listener_setopt\n-\tnng_listener_start\n-\tnng_msg_alloc\n-\tnng_msg_append\n-\tnng_msg_body\n-\tnng_msg_chop\n-\tnng_msg_clear\n-\tnng_msg_dup\n-\tnng_msg_free\n-\tnng_msg_get_pipe\n-\tnng_msg_header\n-\tnng_msg_header_append\n-\tnng_msg_header_chop\n-\tnng_msg_header_clear\n-\tnng_msg_header_insert\n-\tnng_msg_header_len\n-\tnng_msg_header_trim\n-\tnng_msg_insert\n-\tnng_msg_len\n-\tnng_msg_realloc\n-\tnng_msg_set_pipe\n-\tnng_msg_trim\n-\tnng_pair_open\n-\tnng_pipe_close\n-\tnng_pipe_dialer\n-\tnng_pipe_get\n-\tnng_pipe_getopt\n-\tnng_pipe_id\n-\tnng_pipe_listener\n-\tnng_pipe_notify\n-\tnng_pipe_socket\n-\tnng_pub_open\n-\tnng_pull_open\n-\tnng_push_open\n-\tnng_recv\n-\tnng_recv_aio\n-\tnng_recvmsg\n-\tnng_rep_open\n-\tnng_req_open\n-\tnng_respondent_open\n-\tnng_send\n-\tnng_send_aio\n-\tnng_sendmsg\n-\tnng_setopt\n-\tnng_sleep_aio\n-\tnng_socket_id\n-\tnng_socket_get\n-\tnng_socket_set\n-\tnng_stats_free\n-\tnng_stats_get\n-\tnng_stat_child\n-\tnng_stat_desc\n-\tnng_stat_name\n-\tnng_stat_next\n-\tnng_stat_string\n-\tnng_stat_timestamp\n-\tnng_stat_type\n-\tnng_stat_unit\n-\tnng_stat_value\n-\tnng_strdup\n-\tnng_strerror\n-\tnng_strfree\n-\tnng_sub_open\n-\tnng_surveyor_open\n-\tnng_tcp_register\n-\tnng_tls_register\n-\tnng_url_clone\n-\tnng_url_free\n-\tnng_url_parse\n-\tnng_version\n-\tnng_ws_register\n-\tnng_wss_register\n-\tnng_zt_register\n-    )\n+    set(NNG_MAN3\n+            libnng\n+            nng_aio_abort\n+            nng_aio_alloc\n+            nng_aio_begin\n+            nng_aio_cancel\n+            nng_aio_count\n+            nng_aio_defer\n+            nng_aio_finish\n+            nng_aio_free\n+            nng_aio_get_input\n+            nng_aio_get_msg\n+            nng_aio_get_output\n+            nng_aio_result\n+            nng_aio_set_input\n+            nng_aio_set_iov\n+            nng_aio_set_msg\n+            nng_aio_set_output\n+            nng_aio_set_timeout\n+            nng_aio_stop\n+            nng_aio_wait\n+            nng_alloc\n+            nng_bus_open\n+            nng_close\n+            nng_ctx_close\n+            nng_ctx_get\n+            nng_ctx_getopt\n+            nng_ctx_id\n+            nng_ctx_open\n+            nng_ctx_recv\n+            nng_ctx_send\n+            nng_ctx_set\n+            nng_ctx_setopt\n+            nng_device\n+            nng_dial\n+            nng_dialer_close\n+            nng_dialer_create\n+            nng_dialer_get\n+            nng_dialer_getopt\n+            nng_dialer_id\n+            nng_dialer_set\n+            nng_dialer_setopt\n+            nng_dialer_start\n+            nng_free\n+            nng_getopt\n+            nng_inproc_register\n+            nng_ipc_register\n+            nng_listen\n+            nng_listener_close\n+            nng_listener_create\n+            nng_listener_get\n+            nng_listener_getopt\n+            nng_listener_id\n+            nng_listener_set\n+            nng_listener_setopt\n+            nng_listener_start\n+            nng_msg_alloc\n+            nng_msg_append\n+            nng_msg_body\n+            nng_msg_chop\n+            nng_msg_clear\n+            nng_msg_dup\n+            nng_msg_free\n+            nng_msg_get_pipe\n+            nng_msg_header\n+            nng_msg_header_append\n+            nng_msg_header_chop\n+            nng_msg_header_clear\n+            nng_msg_header_insert\n+            nng_msg_header_len\n+            nng_msg_header_trim\n+            nng_msg_insert\n+            nng_msg_len\n+            nng_msg_realloc\n+            nng_msg_set_pipe\n+            nng_msg_trim\n+            nng_pair_open\n+            nng_pipe_close\n+            nng_pipe_dialer\n+            nng_pipe_get\n+            nng_pipe_getopt\n+            nng_pipe_id\n+            nng_pipe_listener\n+            nng_pipe_notify\n+            nng_pipe_socket\n+            nng_pub_open\n+            nng_pull_open\n+            nng_push_open\n+            nng_recv\n+            nng_recv_aio\n+            nng_recvmsg\n+            nng_rep_open\n+            nng_req_open\n+            nng_respondent_open\n+            nng_send\n+            nng_send_aio\n+            nng_sendmsg\n+            nng_setopt\n+            nng_sleep_aio\n+            nng_socket_id\n+            nng_socket_get\n+            nng_socket_set\n+            nng_stats_free\n+            nng_stats_get\n+            nng_stat_child\n+            nng_stat_desc\n+            nng_stat_find\n+            nng_stat_find_dialer\n+            nng_stat_find_listener\n+            nng_stat_find_socket\n+            nng_stat_name\n+            nng_stat_next\n+            nng_stat_string\n+            nng_stat_timestamp\n+            nng_stat_type\n+            nng_stat_unit\n+            nng_stat_value\n+            nng_strdup\n+            nng_strerror\n+            nng_strfree\n+            nng_sub_open\n+            nng_surveyor_open\n+            nng_tcp_register\n+            nng_tls_register\n+            nng_url_clone\n+            nng_url_free\n+            nng_url_parse\n+            nng_version\n+            nng_ws_register\n+            nng_wss_register\n+            nng_zt_register\n+            )\n \n     set(NNG_MAN3COMPAT\n-\tnn_allocmsg\n-\tnn_bind\n-\tnn_close\n-\tnn_cmsg\n-\tnn_connect\n-\tnn_device\n-\tnn_errno\n-\tnn_freemsg\n-\tnn_get_statistic\n-\tnn_getsockopt\n-\tnn_poll\n-\tnn_reallocmsg\n-\tnn_recv\n-\tnn_recvmsg\n-\tnn_send\n-\tnn_sendmsg\n-\tnn_setsockopt\n-\tnn_shutdown\n-\tnn_socket\n-\tnn_strerror\n-\tnn_term\n-\tnng_compat\n-    )\n+            nn_allocmsg\n+            nn_bind\n+            nn_close\n+            nn_cmsg\n+            nn_connect\n+            nn_device\n+            nn_errno\n+            nn_freemsg\n+            nn_get_statistic\n+            nn_getsockopt\n+            nn_poll\n+            nn_reallocmsg\n+            nn_recv\n+            nn_recvmsg\n+            nn_send\n+            nn_sendmsg\n+            nn_setsockopt\n+            nn_shutdown\n+            nn_socket\n+            nn_strerror\n+            nn_term\n+            nng_compat\n+            )\n \n     set(NNG_MAN3HTTP\n-\tnng_http_client_alloc\n-\tnng_http_client_connect\n-\tnng_http_client_free\n-\tnng_http_client_get_tls\n-\tnng_http_client_set_tls\n-\tnng_http_client_transact\n-\tnng_http_conn_close\n-\tnng_http_conn_read\n-\tnng_http_conn_read_all\n-\tnng_http_conn_read_req\n-\tnng_http_conn_read_res\n-\tnng_http_conn_transact\n-\tnng_http_conn_write\n-\tnng_http_conn_write_all\n-\tnng_http_conn_write_req\n-\tnng_http_conn_write_res\n-\tnng_http_handler_alloc\n-\tnng_http_handler_free\n-\tnng_http_handler_get_data\n-\tnng_http_handler_set_data\n-\tnng_http_handler_set_host\n-\tnng_http_handler_set_method\n-\tnng_http_handler_set_tree\n-\tnng_http_hijack\n-\tnng_http_req_add_header\n-\tnng_http_req_alloc\n-\tnng_http_req_copy_data\n-\tnng_http_req_del_header\n-\tnng_http_req_free\n-\tnng_http_req_get_data\n-\tnng_http_req_get_header\n-\tnng_http_req_get_method\n-\tnng_http_req_get_uri\n-\tnng_http_req_get_version\n-\tnng_http_req_reset\n-\tnng_http_req_set_data\n-\tnng_http_req_set_header\n-\tnng_http_req_set_method\n-\tnng_http_req_set_uri\n-\tnng_http_req_set_version\n-\tnng_http_res_add_header\n-\tnng_http_res_alloc\n-\tnng_http_res_alloc_error\n-\tnng_http_res_copy_data\n-\tnng_http_res_del_header\n-\tnng_http_res_free\n-\tnng_http_res_get_data\n-\tnng_http_res_get_header\n-\tnng_http_res_get_reason\n-\tnng_http_res_get_status\n-\tnng_http_res_get_version\n-\tnng_http_res_reset\n-\tnng_http_res_set_data\n-\tnng_http_res_set_header\n-\tnng_http_res_set_reason\n-\tnng_http_res_set_status\n-\tnng_http_res_set_version\n-\tnng_http_server_add_handler\n-\tnng_http_server_del_handler\n-\tnng_http_server_get_addr\n-\tnng_http_server_get_tls\n-\tnng_http_server_hold\n-\tnng_http_server_release\n-\tnng_http_server_set_tls\n-\tnng_http_server_start\n-\tnng_http_server_stop\n-    )\n+            nng_http_client_alloc\n+            nng_http_client_connect\n+            nng_http_client_free\n+            nng_http_client_get_tls\n+            nng_http_client_set_tls\n+            nng_http_client_transact\n+            nng_http_conn_close\n+            nng_http_conn_read\n+            nng_http_conn_read_all\n+            nng_http_conn_read_req\n+            nng_http_conn_read_res\n+            nng_http_conn_transact\n+            nng_http_conn_write\n+            nng_http_conn_write_all\n+            nng_http_conn_write_req\n+            nng_http_conn_write_res\n+            nng_http_handler_alloc\n+            nng_http_handler_free\n+            nng_http_handler_get_data\n+            nng_http_handler_set_data\n+            nng_http_handler_set_host\n+            nng_http_handler_set_method\n+            nng_http_handler_set_tree\n+            nng_http_hijack\n+            nng_http_req_add_header\n+            nng_http_req_alloc\n+            nng_http_req_copy_data\n+            nng_http_req_del_header\n+            nng_http_req_free\n+            nng_http_req_get_data\n+            nng_http_req_get_header\n+            nng_http_req_get_method\n+            nng_http_req_get_uri\n+            nng_http_req_get_version\n+            nng_http_req_reset\n+            nng_http_req_set_data\n+            nng_http_req_set_header\n+            nng_http_req_set_method\n+            nng_http_req_set_uri\n+            nng_http_req_set_version\n+            nng_http_res_add_header\n+            nng_http_res_alloc\n+            nng_http_res_alloc_error\n+            nng_http_res_copy_data\n+            nng_http_res_del_header\n+            nng_http_res_free\n+            nng_http_res_get_data\n+            nng_http_res_get_header\n+            nng_http_res_get_reason\n+            nng_http_res_get_status\n+            nng_http_res_get_version\n+            nng_http_res_reset\n+            nng_http_res_set_data\n+            nng_http_res_set_header\n+            nng_http_res_set_reason\n+            nng_http_res_set_status\n+            nng_http_res_set_version\n+            nng_http_server_add_handler\n+            nng_http_server_del_handler\n+            nng_http_server_get_addr\n+            nng_http_server_get_tls\n+            nng_http_server_hold\n+            nng_http_server_release\n+            nng_http_server_set_tls\n+            nng_http_server_start\n+            nng_http_server_stop\n+            )\n \n     set(NNG_MAN3SUPP\n-\tnng_clock\n-\tnng_cv_alloc\n-\tnng_cv_free\n-\tnng_cv_until\n-\tnng_cv_wait\n-\tnng_cv_wake\n-\tnng_cv_wake1\n-\tnng_msleep\n-\tnng_mtx_alloc\n-\tnng_mtx_free\n-\tnng_mtx_lock\n-\tnng_mtx_unlock\n-\tnng_opts_parse\n-\tnng_random\n-\tnng_thread_create\n-\tnng_thread_destroy\n-    )\n+            nng_clock\n+            nng_cv_alloc\n+            nng_cv_free\n+            nng_cv_until\n+            nng_cv_wait\n+            nng_cv_wake\n+            nng_cv_wake1\n+            nng_msleep\n+            nng_mtx_alloc\n+            nng_mtx_free\n+            nng_mtx_lock\n+            nng_mtx_unlock\n+            nng_opts_parse\n+            nng_random\n+            nng_thread_create\n+            nng_thread_destroy\n+            )\n \n     set(NNG_MAN3STR\n-        nng_stream_close\n-\tnng_stream_free\n-\tnng_stream_get\n-\tnng_stream_recv\n-\tnng_stream_send\n-\tnng_stream_set\n-    \tnng_stream_dialer_alloc\n-\tnng_stream_dialer_close\n-\tnng_stream_dialer_dial\n-\tnng_stream_dialer_free\n-\tnng_stream_dialer_get\n-\tnng_stream_dialer_set\n-\tnng_stream_listener_accept\n-\tnng_stream_listener_alloc\n-\tnng_stream_listener_close\n-\tnng_stream_listener_free\n-\tnng_stream_listener_get\n-\tnng_stream_listener_listen\n-\tnng_stream_listener_set\n-    )\n+            nng_stream_close\n+            nng_stream_free\n+            nng_stream_get\n+            nng_stream_recv\n+            nng_stream_send\n+            nng_stream_set\n+            nng_stream_dialer_alloc\n+            nng_stream_dialer_close\n+            nng_stream_dialer_dial\n+            nng_stream_dialer_free\n+            nng_stream_dialer_get\n+            nng_stream_dialer_set\n+            nng_stream_listener_accept\n+            nng_stream_listener_alloc\n+            nng_stream_listener_close\n+            nng_stream_listener_free\n+            nng_stream_listener_get\n+            nng_stream_listener_listen\n+            nng_stream_listener_set\n+            )\n \n     set(NNG_MAN3TLS\n-\tnng_tls_config_alloc\n-\tnng_tls_config_auth_mode\n-\tnng_tls_config_ca_chain\n-\tnng_tls_config_ca_file\n-\tnng_tls_config_cert_key_file\n-\tnng_tls_config_free\n-\tnng_tls_config_hold\n-\tnng_tls_config_own_cert\n-\tnng_tls_config_server_name\n-    )\n+            nng_tls_config_alloc\n+            nng_tls_config_auth_mode\n+            nng_tls_config_ca_chain\n+            nng_tls_config_ca_file\n+            nng_tls_config_cert_key_file\n+            nng_tls_config_free\n+            nng_tls_config_hold\n+            nng_tls_config_own_cert\n+            nng_tls_config_server_name\n+            )\n \n     set(NNG_MAN5\n-\tnng_aio\n-\tnng_ctx\n-\tnng_dialer\n-\tnng_duration\n-\tnng_iov\n-\tnng_listener\n-\tnng_msg\n-\tnng_options\n-\tnng_pipe\n-\tnng_sockaddr\n-\tnng_sockaddr_in\n-\tnng_sockaddr_in6\n-\tnng_sockaddr_inproc\n-\tnng_sockaddr_ipc\n-\tnng_sockaddr_zt\n-\tnng_socket\n-\tnng_stat\n+            nng_aio\n+            nng_ctx\n+            nng_dialer\n+            nng_duration\n+            nng_iov\n+            nng_listener\n+            nng_msg\n+            nng_options\n+            nng_pipe\n+            nng_sockaddr\n+            nng_sockaddr_in\n+            nng_sockaddr_in6\n+            nng_sockaddr_inproc\n+            nng_sockaddr_ipc\n+            nng_sockaddr_zt\n+            nng_socket\n+            nng_stat\n \n-\tnng_stream\n-\tnng_stream_dialer\n-\tnng_stream_listener\n+            nng_stream\n+            nng_stream_dialer\n+            nng_stream_listener\n \n-\tnng_tcp_options\n-\tnng_ipc_options\n-\tnng_tls_config\n-\tnng_tls_options\n-    )\n+            nng_tcp_options\n+            nng_ipc_options\n+            nng_tls_config\n+            nng_tls_options\n+            )\n \n     set(NNG_MAN7\n-\tnng\n-\tnng_bus\n-\tnng_inproc\n-\tnng_ipc\n-\tnng_pair\n-\tnng_pub\n-\tnng_pull\n-\tnng_push\n-\tnng_rep\n-\tnng_req\n-\tnng_respondent\n-\tnng_sub\n-\tnng_surveyor\n-\tnng_tcp\n-\tnng_tls\n-\tnng_ws\n-\tnng_zerotier\n-    )\n+            nng\n+            nng_bus\n+            nng_inproc\n+            nng_ipc\n+            nng_pair\n+            nng_pub\n+            nng_pull\n+            nng_push\n+            nng_rep\n+            nng_req\n+            nng_respondent\n+            nng_sub\n+            nng_surveyor\n+            nng_tcp\n+            nng_tls\n+            nng_ws\n+            nng_zerotier\n+            )\n \n-    foreach(F ${NNG_MAN1})\n+    foreach (F ${NNG_MAN1})\n         nng_man(${F} 1)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN3})\n+    foreach (F ${NNG_MAN3})\n         nng_man(${F} 3)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN3COMPAT})\n+    foreach (F ${NNG_MAN3COMPAT})\n         nng_man(${F} 3compat)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN3HTTP})\n+    foreach (F ${NNG_MAN3HTTP})\n         nng_man(${F} 3http)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN3STR})\n+    foreach (F ${NNG_MAN3STR})\n         nng_man(${F} 3str)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN3SUPP})\n+    foreach (F ${NNG_MAN3SUPP})\n         nng_man(${F} 3supp)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN3TLS})\n+    foreach (F ${NNG_MAN3TLS})\n         nng_man(${F} 3tls)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN5})\n+    foreach (F ${NNG_MAN5})\n         nng_man(${F} 5)\n-    endforeach()\n+    endforeach ()\n \n-    foreach(F ${NNG_MAN7})\n+    foreach (F ${NNG_MAN7})\n         nng_man(${F} 7)\n-    endforeach()\n+    endforeach ()\n \n-    add_custom_target (man ALL DEPENDS ${NNG_MANS})\n-    add_custom_target (html ALL DEPENDS ${NNG_HTMLS})\n+    add_custom_target(man ALL DEPENDS ${NNG_MANS})\n+    add_custom_target(html ALL DEPENDS ${NNG_HTMLS})\n endif ()\ndiff --git a/docs/man/libnng.3.adoc b/docs/man/libnng.3.adoc\nindex 35c9b0f4a..4e59890f5 100644\n--- a/docs/man/libnng.3.adoc\n+++ b/docs/man/libnng.3.adoc\n@@ -240,6 +240,10 @@ to observe program behaviors and as an aid in troubleshooting.\n |===\n |xref:nng_stat_child.3.adoc[nng_stat_child()]|get child statistic\n |xref:nng_stat_desc.3.adoc[nng_stat_name()]|get statistic description\n+|xref:nng_stat_find.3.adoc[nng_stat_find()]|find statistic by name\n+|xref:nng_stat_find_dialer.3.adoc[nng_stat_find_dialer()]|find dialer statistics\n+|xref:nng_stat_find_listener.3.adoc[nng_stat_find_listener()]|find listener statistics\n+|xref:nng_stat_find_socket.3.adoc[nng_stat_find_socket()]|find socket statistics\n |xref:nng_stat_name.3.adoc[nng_stat_name()]|get statistic name\n |xref:nng_stat_next.3.adoc[nng_stat_next()]|get next statistic\n |xref:nng_stat_string.3.adoc[nng_stat_string()]|get statistic string value\ndiff --git a/docs/man/nng_stat.5.adoc b/docs/man/nng_stat.5.adoc\nindex 4382e4b03..0b6493080 100644\n--- a/docs/man/nng_stat.5.adoc\n+++ b/docs/man/nng_stat.5.adoc\n@@ -68,6 +68,10 @@ xref:nng_stats_free.3.adoc[nng_stats_free(3)],\n xref:nng_stats_get.3.adoc[nng_stats_get(3)],\n xref:nng_stat_child.3.adoc[nng_stat_child(3)],\n xref:nng_stat_desc.3.adoc[nng_stat_desc(3)],\n+xref:nng_stat_find.3.adoc[nng_stat_find(3)],\n+xref:nng_stat_find_dialer.3.adoc[nng_stat_find_dialer(3)],\n+xref:nng_stat_find_listener.3.adoc[nng_stat_find_listener(3)],\n+xref:nng_stat_find_socket.3.adoc[nng_stat_find_socket(3)],\n xref:nng_stat_name.3.adoc[nng_stat_name(3)],\n xref:nng_stat_next.3.adoc[nng_stat_next(3)],\n xref:nng_stat_string.3.adoc[nng_stat_string(3)],\ndiff --git a/docs/man/nng_stat_find.adoc b/docs/man/nng_stat_find.adoc\nnew file mode 100644\nindex 000000000..4f4103eaf\n--- /dev/null\n+++ b/docs/man/nng_stat_find.adoc\n@@ -0,0 +1,52 @@\n+= nng_stat_find(3)\n+//\n+// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+//\n+// This document is supplied under the terms of the MIT License, a\n+// copy of which should be located in the distribution where this\n+// file was obtained (LICENSE.txt).  A copy of the license may also be\n+// found online at https://opensource.org/licenses/MIT.\n+//\n+\n+== NAME\n+\n+nng_stat_find - find statistic by name\n+\n+== SYNOPSIS\n+\n+[source,c]\n+----\n+#include <nng/nng.h>\n+\n+typedef struct nng_stat nng_stat;\n+\n+nng_stat *nng_stat_find(nng_stat *stat, const char *name);\n+----\n+\n+== DESCRIPTION\n+\n+The `nng_stat_find()` function searches the statistics tree _stat_, looking for a statistic whose name is _name_.\n+If it finds one, it returns it.\n+Otherwise `NULL` is returned.\n+\n+NOTE: If multiple statistics have that name, then only the first match is returned.\n+\n+== RETURN VALUES\n+\n+The matching statistic, or NULL if no match is found.\n+\n+== ERRORS\n+\n+None.\n+\n+== SEE ALSO\n+\n+[.text-left]\n+xref:libnng.3.adoc[libnng(3)],\n+xref:nng_stat_child.3.adoc[nng_stat_child(3)],\n+xref:nng_stat_find_dialer.3.adoc[nng_stat_find_dialer(3)],\n+xref:nng_stat_find_listener.3.adoc[nng_stat_find_listner(3)],\n+xref:nng_stat_find_socket.3.adoc[nng_stat_find_socket(3)],\n+xref:nng_stats_get.3.adoc[nng_stats_get(3)],\n+xref:nng_stat.5.adoc[nng_stat(5)],\n+xref:nng.7.adoc[nng(7)]\ndiff --git a/docs/man/nng_stat_find_dialer.adoc b/docs/man/nng_stat_find_dialer.adoc\nnew file mode 100644\nindex 000000000..b0df247aa\n--- /dev/null\n+++ b/docs/man/nng_stat_find_dialer.adoc\n@@ -0,0 +1,56 @@\n+= nng_stat_find_socket(3)\n+//\n+// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+//\n+// This document is supplied under the terms of the MIT License, a\n+// copy of which should be located in the distribution where this\n+// file was obtained (LICENSE.txt).  A copy of the license may also be\n+// found online at https://opensource.org/licenses/MIT.\n+//\n+\n+== NAME\n+\n+nng_stat_find_dialer - find dialer statistics\n+\n+== SYNOPSIS\n+\n+[source,c]\n+----\n+#include <nng/nng.h>\n+\n+typedef struct nng_stat nng_stat;\n+typedef struct nng_dialer nng_dialer;\n+\n+nng_stat *nng_stat_find_dialer(nng_stat *stat, nng_dialer dialer);\n+----\n+\n+== DESCRIPTION\n+\n+The `nng_stat_find_dialer()` function returns the statistics tree within _stat_ associated with the dialer _dialer_, if such a tree exists.\n+Otherwise `NULL` is returned.\n+\n+Generally, there will be child statistics of the returned value, each corresponding to a specific metric.\n+These can be further scanned using either\n+xref:nng_stat_find.3.adoc[nng_stat_find(3)]\n+or by walking the tree with\n+xref:nng_stat_child.3.adoc[nng_stat_child(3)].\n+\n+== RETURN VALUES\n+\n+The matching statistic, or NULL if no match is found.\n+\n+== ERRORS\n+\n+None.\n+\n+== SEE ALSO\n+\n+[.text-left]\n+xref:libnng.3.adoc[libnng(3)],\n+xref:nng_stat_child.3.adoc[nng_stat_child(3)],\n+xref:nng_stat_find.3.adoc[nng_stat_find(3)],\n+xref:nng_stat_find_listener.3.adoc[nng_stat_find_listener(3)],\n+xref:nng_stat_find_socket.3.adoc[nng_stat_find_socket(3)],\n+xref:nng_stats_get.3.adoc[nng_stats_get(3)],\n+xref:nng_stat.5.adoc[nng_stat(5)],\n+xref:nng.7.adoc[nng(7)]\ndiff --git a/docs/man/nng_stat_find_listener.adoc b/docs/man/nng_stat_find_listener.adoc\nnew file mode 100644\nindex 000000000..2a099b1b9\n--- /dev/null\n+++ b/docs/man/nng_stat_find_listener.adoc\n@@ -0,0 +1,56 @@\n+= nng_stat_find_listener(3)\n+//\n+// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+//\n+// This document is supplied under the terms of the MIT License, a\n+// copy of which should be located in the distribution where this\n+// file was obtained (LICENSE.txt).  A copy of the license may also be\n+// found online at https://opensource.org/licenses/MIT.\n+//\n+\n+== NAME\n+\n+nng_stat_find_listener - find listener statistics\n+\n+== SYNOPSIS\n+\n+[source,c]\n+----\n+#include <nng/nng.h>\n+\n+typedef struct nng_stat nng_stat;\n+typedef struct nng_listener nng_listener;\n+\n+nng_stat *nng_stat_find_listener(nng_stat *stat, nng_listener listener);\n+----\n+\n+== DESCRIPTION\n+\n+The `nng_stat_find_listener()` function returns the statistics tree within _stat_ associated with the listener _listener_, if such a tree exists.\n+Otherwise `NULL` is returned.\n+\n+Generally, there will be child statistics of the returned value, each corresponding to a specific metric.\n+These can be further scanned using either\n+xref:nng_stat_find.3.adoc[nng_stat_find(3)]\n+or by walking the tree with\n+xref:nng_stat_child.3.adoc[nng_stat_child(3)].\n+\n+== RETURN VALUES\n+\n+The matching statistic, or NULL if no match is found.\n+\n+== ERRORS\n+\n+None.\n+\n+== SEE ALSO\n+\n+[.text-left]\n+xref:libnng.3.adoc[libnng(3)],\n+xref:nng_stat_child.3.adoc[nng_stat_child(3)],\n+xref:nng_stat_find.3.adoc[nng_stat_find(3)],\n+xref:nng_stat_find_dialer.3.adoc[nng_stat_find_dialer(3)],\n+xref:nng_stat_find_socket.3.adoc[nng_stat_find_socket(3)],\n+xref:nng_stats_get.3.adoc[nng_stats_get(3)],\n+xref:nng_stat.5.adoc[nng_stat(5)],\n+xref:nng.7.adoc[nng(7)]\ndiff --git a/docs/man/nng_stat_find_socket.adoc b/docs/man/nng_stat_find_socket.adoc\nnew file mode 100644\nindex 000000000..eb03d5ea5\n--- /dev/null\n+++ b/docs/man/nng_stat_find_socket.adoc\n@@ -0,0 +1,56 @@\n+= nng_stat_find_socket(3)\n+//\n+// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+//\n+// This document is supplied under the terms of the MIT License, a\n+// copy of which should be located in the distribution where this\n+// file was obtained (LICENSE.txt).  A copy of the license may also be\n+// found online at https://opensource.org/licenses/MIT.\n+//\n+\n+== NAME\n+\n+nng_stat_find_socket - find socket statistics\n+\n+== SYNOPSIS\n+\n+[source,c]\n+----\n+#include <nng/nng.h>\n+\n+typedef struct nng_stat nng_stat;\n+typedef struct nng_socket nng_socket;\n+\n+nng_stat *nng_stat_find_socket(nng_stat *stat, nng_socket socket);\n+----\n+\n+== DESCRIPTION\n+\n+The `nng_stat_find_socket()` function returns the statistics tree within _stat_ associated with the socket _socket_, if such a tree exists.\n+Otherwise `NULL` is returned.\n+\n+Generally, there will be child statistics of the returned value, each corresponding to a specific metric.\n+These can be further scanned using either\n+xref:nng_stat_find.3.adoc[nng_stat_find(3)]\n+or by walking the tree with\n+xref:nng_stat_child.3.adoc[nng_stat_child(3)].\n+\n+== RETURN VALUES\n+\n+The matching statistic, or NULL if no match is found.\n+\n+== ERRORS\n+\n+None.\n+\n+== SEE ALSO\n+\n+[.text-left]\n+xref:libnng.3.adoc[libnng(3)],\n+xref:nng_stat_child.3.adoc[nng_stat_child(3)],\n+xref:nng_stat_find.3.adoc[nng_stat_find(3)],\n+xref:nng_stat_find_dialer.3.adoc[nng_stat_find_dialer(3)],\n+xref:nng_stat_find_listener.3.adoc[nng_stat_find_listener(3)],\n+xref:nng_stats_get.3.adoc[nng_stats_get(3)],\n+xref:nng_stat.5.adoc[nng_stat(5)],\n+xref:nng.7.adoc[nng(7)]\ndiff --git a/include/nng/nng.h b/include/nng/nng.h\nindex 0db81ef59..2c9dd8c3e 100644\n--- a/include/nng/nng.h\n+++ b/include/nng/nng.h\n@@ -915,7 +915,7 @@ enum nng_flag_enum {\n // This can be useful when a handler supports an entire directory tree.\n #define NNG_OPT_WS_REQUEST_URI \"ws:request-uri\"\n \n-// NNG_OPT_WS_TXFRAMESZ is used to configure the fragmentation size\n+// NNG_OPT_WS_SENDMAXFRAME is used to configure the fragmentation size\n // used for frames.  This has a default value of 64k.  Large values\n // are good for throughput, but penalize latency.  They also require\n // additional buffering on the peer.  This value must not be larger\n@@ -923,7 +923,7 @@ enum nng_flag_enum {\n // to negotiate this.\n #define NNG_OPT_WS_SENDMAXFRAME \"ws:txframe-max\"\n \n-// NNG_OPT_WS_RXFRAMESZ is the largest frame we will accept.  This should\n+// NNG_OPT_WS_RECVMAXFRAME is the largest frame we will accept.  This should\n // probably not be larger than NNG_OPT_RECVMAXSZ. If the sender attempts\n // to send more data than this in a single message, it will be dropped.\n #define NNG_OPT_WS_RECVMAXFRAME \"ws:rxframe-max\"\n@@ -943,7 +943,7 @@ enum nng_flag_enum {\n // nng_stats_get takes a snapshot of the entire set of statistics.\n // While the operation can be somewhat expensive (allocations), it\n // is done in a way that minimizes impact to running operations.\n-// Note that the statistics are provided as tree, with parents\n+// Note that the statistics are provided as a tree, with parents\n // used for grouping, and with child statistics underneath.  The\n // top stat returned will be of type NNG_STAT_SCOPE with name \"\".\n // Applications may choose to consider this root scope as \"root\", if\n@@ -973,13 +973,25 @@ NNG_DECL nng_stat *nng_stat_child(nng_stat *);\n NNG_DECL const char *nng_stat_name(nng_stat *);\n \n // nng_stat_type is used to determine the type of the statistic.\n-// At present, only NNG_STAT_TYPE_LEVEL and and NNG_STAT_TYPE_COUNTER\n-// are defined.  Counters generally increment, and therefore changes in the\n-// value over time are likely more interesting than the actual level.  Level\n+// Counters generally increment, and therefore changes in the value over\n+// time are likely more interesting than the actual level.  Level\n // values reflect some absolute state however, and should be presented to the\n // user as is.\n NNG_DECL int nng_stat_type(nng_stat *);\n \n+// nng_stat_find is used to find a specific named statistic within\n+// a statistic tree.  NULL is returned if no such statistic exists.\n+NNG_DECL nng_stat *nng_stat_find(nng_stat *, const char *);\n+\n+// nng_stat_find_socket is used to find the stats for the given socket.\n+NNG_DECL nng_stat *nng_stat_find_socket(nng_stat *, nng_socket);\n+\n+// nng_stat_find_dialer is used to find the stats for the given dialer.\n+NNG_DECL nng_stat *nng_stat_find_dialer(nng_stat *, nng_dialer);\n+\n+// nng_stat_find_listener is used to find the stats for the given listener.\n+NNG_DECL nng_stat *nng_stat_find_listener(nng_stat *, nng_listener);\n+\n enum nng_stat_type_enum {\n \tNNG_STAT_SCOPE   = 0, // Stat is for scoping, and carries no value\n \tNNG_STAT_LEVEL   = 1, // Numeric \"absolute\" value, diffs meaningless\ndiff --git a/src/core/stats.c b/src/core/stats.c\nindex 3c200fecd..f9b56858f 100644\n--- a/src/core/stats.c\n+++ b/src/core/stats.c\n@@ -1,5 +1,5 @@\n //\n-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n //\n // This software is supplied under the terms of the MIT License, a\n@@ -17,8 +17,8 @@ typedef struct nng_stat nni_stat;\n \n struct nng_stat {\n \tchar *         s_name;\n-\tconst char *   s_desc;\n-\tconst char *   s_string;\n+\tchar *         s_desc;\n+\tchar *         s_string;\n \tuint64_t       s_value;\n \tnni_time       s_time;\n \tnni_stat_type  s_type;\n@@ -181,17 +181,6 @@ nni_stat_set_value(nni_stat_item *stat, uint64_t v)\n #endif\n }\n \n-void\n-nni_stat_set_string(nni_stat_item *stat, const char *str)\n-{\n-#ifdef NNG_ENABLE_STATS\n-\tstat->si_string = str;\n-#else\n-\tNNI_ARG_UNUSED(stat);\n-\tNNI_ARG_UNUSED(str);\n-#endif\n-}\n-\n void\n nni_stat_set_lock(nni_stat_item *stat, nni_mtx *mtx)\n {\n@@ -241,6 +230,8 @@ nng_stats_free(nni_stat *st)\n \t\tnng_stats_free(child);\n \t}\n \tnni_strfree(st->s_name);\n+\tnni_strfree(st->s_desc);\n+\tnni_strfree(st->s_string);\n \tNNI_FREE_STRUCT(st);\n #else\n \tNNI_ARG_UNUSED(st);\n@@ -257,15 +248,21 @@ stat_make_tree(nni_stat_item *item, nni_stat **sp)\n \tif ((stat = NNI_ALLOC_STRUCT(stat)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tif ((stat->s_name = nni_strdup(item->si_name)) == NULL) {\n-\t\tNNI_FREE_STRUCT(stat);\n+\tNNI_LIST_INIT(&stat->s_children, nni_stat, s_node);\n+\n+\tif (((stat->s_name = nni_strdup(item->si_name)) == NULL) ||\n+\t    ((stat->s_desc = nni_strdup(item->si_desc)) == NULL)) {\n+\t\tnng_stats_free(stat);\n+\t\treturn (NNG_ENOMEM);\n+\t}\n+\tif ((item->si_type == NNG_STAT_STRING) &&\n+\t    ((stat->s_string = nni_strdup(item->si_string)) == NULL)) {\n+\t\tnng_stats_free(stat);\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tNNI_LIST_INIT(&stat->s_children, nni_stat, s_node);\n \tstat->s_item   = item;\n \tstat->s_type   = item->si_type;\n \tstat->s_unit   = item->si_unit;\n-\tstat->s_desc   = item->si_desc;\n \tstat->s_parent = NULL;\n \n \tNNI_LIST_FOREACH (&item->si_children, child) {\n@@ -300,9 +297,8 @@ stat_update(nni_stat *stat)\n \tif (item->si_update != NULL) {\n \t\titem->si_update(item, item->si_private);\n \t}\n-\tstat->s_value  = item->si_number;\n-\tstat->s_string = item->si_string;\n-\tstat->s_time   = nni_clock();\n+\tstat->s_value = item->si_number;\n+\tstat->s_time  = nni_clock();\n }\n \n static void\n@@ -418,6 +414,49 @@ nng_stat_desc(nng_stat *stat)\n \treturn (stat->s_desc);\n }\n \n+nng_stat *\n+nng_stat_find(nng_stat *stat, const char *name)\n+{\n+\tnng_stat *child;\n+\tif (stat == NULL) {\n+\t\treturn (NULL);\n+\t}\n+\tif (strcmp(name, stat->s_name) == 0) {\n+\t\treturn (stat);\n+\t}\n+\tNNI_LIST_FOREACH(&stat->s_children, child) {\n+\t\tnng_stat *result;\n+\t\tif ((result = nng_stat_find(child, name)) != NULL) {\n+\t\t\treturn (result);\n+\t\t}\n+\t}\n+\treturn (NULL);\n+}\n+\n+nng_stat *\n+nng_stat_find_socket(nng_stat *stat, nng_socket s)\n+{\n+\tchar name[16];\n+\t(void) snprintf(name, sizeof (name), \"socket%d\", nng_socket_id(s));\n+\treturn (nng_stat_find(stat, name));\n+}\n+\n+nng_stat *\n+nng_stat_find_dialer(nng_stat *stat, nng_dialer d)\n+{\n+\tchar name[16];\n+\t(void) snprintf(name, sizeof (name), \"dialer%d\", nng_dialer_id(d));\n+\treturn (nng_stat_find(stat, name));\n+}\n+\n+nng_stat *\n+nng_stat_find_listener(nng_stat *stat, nng_listener l)\n+{\n+\tchar name[16];\n+\t(void) snprintf(name, sizeof (name), \"listener%d\", nng_listener_id(l));\n+\treturn (nng_stat_find(stat, name));\n+}\n+\n int\n nni_stat_sys_init(void)\n {\n@@ -427,7 +466,6 @@ nni_stat_sys_init(void)\n \tstats_root.si_name = \"\";\n \tstats_root.si_desc = \"all statistics\";\n #endif\n-\n \treturn (0);\n }\n \ndiff --git a/src/core/stats.h b/src/core/stats.h\nindex 12dbbbdd7..a9ea6e13e 100644\n--- a/src/core/stats.h\n+++ b/src/core/stats.h\n@@ -1,5 +1,5 @@\n //\n-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n //\n // This software is supplied under the terms of the MIT License, a\n@@ -66,7 +66,6 @@ void nni_stat_register(nni_stat_item *);\n void nni_stat_unregister(nni_stat_item *);\n \n void nni_stat_set_value(nni_stat_item *, uint64_t);\n-void nni_stat_set_string(nni_stat_item *, const char *);\n void nni_stat_set_lock(nni_stat_item *, nni_mtx *);\n void nni_stat_set_update(nni_stat_item *, nni_stat_update, void *);\n \ndiff --git a/src/platform/windows/win_udp.c b/src/platform/windows/win_udp.c\nindex e3e5a3691..95ff2eb8c 100644\n--- a/src/platform/windows/win_udp.c\n+++ b/src/platform/windows/win_udp.c\n@@ -1,5 +1,5 @@\n //\n-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n //\n // This software is supplied under the terms of the MIT License, a\n@@ -307,10 +307,9 @@ nni_plat_udp_sockname(nni_plat_udp *udp, nni_sockaddr *sa)\n {\n \tSOCKADDR_STORAGE ss;\n \tint              sz;\n-\tint              rv;\n \n \tsz = sizeof(ss);\n-\tif ((rv = getsockname(udp->s, (SOCKADDR *) &ss, &sz)) < 0) {\n+\tif (getsockname(udp->s, (SOCKADDR *) &ss, &sz) < 0) {\n \t\treturn (nni_win_error(GetLastError()));\n \t}\n \treturn (nni_win_sockaddr2nn(sa, &ss));\ndiff --git a/src/protocol/pair1/pair.c b/src/protocol/pair1/pair.c\nindex 70654d6db..051bc8f36 100644\n--- a/src/protocol/pair1/pair.c\n+++ b/src/protocol/pair1/pair.c\n@@ -1,5 +1,5 @@\n //\n-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n //\n // This software is supplied under the terms of the MIT License, a\n@@ -267,7 +267,6 @@ pair1_pipe_recv_cb(void *arg)\n \tnni_msg *   msg;\n \tuint32_t    hdr;\n \tnni_pipe *  npipe = p->npipe;\n-\tint         rv;\n \tsize_t      len;\n \n \tif (nni_aio_result(p->aio_recv) != 0) {\n@@ -305,7 +304,7 @@ pair1_pipe_recv_cb(void *arg)\n \t}\n \n \t// Store the hop count in the header.\n-\tif ((rv = nni_msg_header_append_u32(msg, hdr)) != 0) {\n+\tif (nni_msg_header_append_u32(msg, hdr) != 0) {\n \t\t// STAT: bump allocfail\n \t\tnni_msg_free(msg);\n \t\tnni_pipe_recv(npipe, p->aio_recv);\ndiff --git a/src/supplemental/http/http_client.c b/src/supplemental/http/http_client.c\nindex 503008464..3c60bd468 100644\n--- a/src/supplemental/http/http_client.c\n+++ b/src/supplemental/http/http_client.c\n@@ -1,5 +1,5 @@\n //\n-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n // Copyright 2019 Devolutions <info@devolutions.net>\n //\n@@ -34,9 +34,7 @@ struct nng_http_client {\n static void\n http_dial_start(nni_http_client *c)\n {\n-\tnni_aio *aio;\n-\n-\tif ((aio = nni_list_first(&c->aios)) == NULL) {\n+\tif (nni_list_empty(&c->aios)) {\n \t\treturn;\n \t}\n \tnng_stream_dialer_dial(c->dialer, c->aio);\ndiff --git a/src/supplemental/util/platform.c b/src/supplemental/util/platform.c\nindex 138e8b0bb..468582bd2 100644\n--- a/src/supplemental/util/platform.c\n+++ b/src/supplemental/util/platform.c\n@@ -155,5 +155,6 @@ nng_cv_wake1(nng_cv *cv)\n uint32_t\n nng_random(void)\n {\n+\t(void) nni_init();\n \treturn (nni_random());\n }\ndiff --git a/src/supplemental/websocket/websocket.c b/src/supplemental/websocket/websocket.c\nindex 55f4e9e4a..c7d3622c4 100644\n--- a/src/supplemental/websocket/websocket.c\n+++ b/src/supplemental/websocket/websocket.c\n@@ -1,5 +1,5 @@\n //\n-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n // Copyright 2019 Devolutions <info@devolutions.net>\n //\n@@ -1012,15 +1012,15 @@ ws_read_cb(void *arg)\n \n \tif (frame->hlen == 0) {\n \t\tframe->hlen   = 2;\n-\t\tframe->op     = frame->head[0] & 0x7f;\n-\t\tframe->final  = (frame->head[0] & 0x80) ? 1 : 0;\n-\t\tframe->masked = (frame->head[1] & 0x80) ? 1 : 0;\n+\t\tframe->op     = frame->head[0] & 0x7fu;\n+\t\tframe->final  = (frame->head[0] & 0x80u) ? 1 : 0;\n+\t\tframe->masked = (frame->head[1] & 0x80u) ? 1 : 0;\n \t\tif (frame->masked) {\n \t\t\tframe->hlen += 4;\n \t\t}\n-\t\tif ((frame->head[1] & 0x7F) == 127) {\n+\t\tif ((frame->head[1] & 0x7Fu) == 127) {\n \t\t\tframe->hlen += 8;\n-\t\t} else if ((frame->head[1] & 0x7F) == 126) {\n+\t\t} else if ((frame->head[1] & 0x7Fu) == 126) {\n \t\t\tframe->hlen += 2;\n \t\t}\n \n@@ -1047,7 +1047,7 @@ ws_read_cb(void *arg)\n \tif (frame->buf == NULL) {\n \n \t\t// Determine expected frame size.\n-\t\tswitch ((frame->len = (frame->head[1] & 0x7F))) {\n+\t\tswitch ((frame->len = (frame->head[1] & 0x7Fu))) {\n \t\tcase 127:\n \t\t\tNNI_GET64(frame->head + 2, frame->len);\n \t\t\tif (frame->len < 65536) {\ndiff --git a/src/transport/zerotier/zerotier.c b/src/transport/zerotier/zerotier.c\nindex 552db5276..027d46c29 100644\n--- a/src/transport/zerotier/zerotier.c\n+++ b/src/transport/zerotier/zerotier.c\n@@ -1,5 +1,5 @@\n //\n-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n //\n // This software is supplied under the terms of the MIT License, a\n@@ -1675,7 +1675,7 @@ zt_pipe_alloc(\n \tzt_node *ztn = ep->ze_ztn;\n \tint      i;\n \tsize_t   maxfrag;\n-\tsize_t   maxfrags;\n+\tsize_t   maxfrags = 0;\n \n \tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n", "test_patch": "diff --git a/src/protocol/reqrep0/reqrep_test.c b/src/protocol/reqrep0/reqrep_test.c\nindex b68c08cb4..f46179368 100644\n--- a/src/protocol/reqrep0/reqrep_test.c\n+++ b/src/protocol/reqrep0/reqrep_test.c\n@@ -387,6 +387,37 @@ test_req_context_not_pollable(void)\n \tTEST_NNG_PASS(nng_close(req));\n }\n \n+void\n+test_req_validate_peer(void)\n+{\n+\tnng_socket s1, s2;\n+\tnng_stat * stats;\n+\tnng_stat * reject;\n+\tchar       addr[64];\n+\n+\ttestutil_scratch_addr(\"inproc\", sizeof(addr), addr);\n+\n+\tTEST_NNG_PASS(nng_req0_open(&s1));\n+\tTEST_NNG_PASS(nng_req0_open(&s2));\n+\n+\tTEST_NNG_PASS(nng_listen(s1, addr, NULL, 0));\n+\tTEST_NNG_PASS(nng_dial(s2, addr, NULL, NNG_FLAG_NONBLOCK));\n+\n+\ttestutil_sleep(100);\n+\tTEST_NNG_PASS(nng_stats_get(&stats));\n+\n+\tTEST_CHECK(stats != NULL);\n+\tTEST_CHECK((reject = nng_stat_find_socket(stats, s1)) != NULL);\n+\tTEST_CHECK((reject = nng_stat_find(reject, \"reject\")) != NULL);\n+\n+\tTEST_CHECK(nng_stat_type(reject) == NNG_STAT_COUNTER);\n+\tTEST_CHECK(nng_stat_value(reject) > 0);\n+\n+\tTEST_NNG_PASS(nng_close(s1));\n+\tTEST_NNG_PASS(nng_close(s2));\n+\tnng_stats_free(stats);\n+}\n+\n TEST_LIST = {\n \t{ \"req rep identity\", test_req_rep_identity },\n \t{ \"resend option\", test_resend_option },\n@@ -398,5 +429,6 @@ TEST_LIST = {\n \t{ \"req poll writable\", test_req_poll_writeable },\n \t{ \"req poll readable\", test_req_poll_readable },\n \t{ \"req context not pollable\", test_req_context_not_pollable },\n+\t{ \"req validate peer\", test_req_validate_peer },\n \t{ NULL, NULL },\n };\ndiff --git a/tests/testutil.c b/tests/testutil.c\nindex 1c65c9960..36999448b 100644\n--- a/tests/testutil.c\n+++ b/tests/testutil.c\n@@ -127,14 +127,63 @@ uint32_t\n testutil_htonl(uint32_t in)\n {\n #ifdef NNG_LITTLE_ENDIAN\n-\tin = ((in >> 24u) & 0xffu) |\n-\t    ((in >> 8u) & 0xff00u) |\n-\t    ((in << 8u) & 0xff0000u) |\n-\t    ((in << 24u) & 0xff000000u);\n+\tin = ((in >> 24u) & 0xffu) | ((in >> 8u) & 0xff00u) |\n+\t    ((in << 8u) & 0xff0000u) | ((in << 24u) & 0xff000000u);\n #endif\n \treturn (in);\n }\n \n+void\n+testutil_scratch_addr(const char *scheme, size_t sz, char *addr)\n+{\n+\tif (strcmp(scheme, \"inproc\") == 0) {\n+\t\t(void) snprintf(addr, sz, \"%s://testutil%04x%04x%04x%04x\",\n+\t\t    scheme, nng_random(), nng_random(), nng_random(),\n+\t\t    nng_random());\n+\t\treturn;\n+\t}\n+\n+\tif ((strncmp(scheme, \"tcp\", 3) == 0) ||\n+\t    (strncmp(scheme, \"tls\", 3) == 0)) {\n+\t\t(void) snprintf(addr, sz, \"%s://127.0.0.1:%u\", scheme,\n+\t\t    testutil_next_port());\n+\t\treturn;\n+\t}\n+\n+\tif (strncmp(scheme, \"ws\", 2) == 0) {\n+\t\t(void) snprintf(addr, sz,\n+\t\t    \"%s://127.0.0.1:%u/testutil%04x%04x%04x%04x\", scheme,\n+\t\t    testutil_next_port(), nng_random(), nng_random(),\n+\t\t    nng_random(), nng_random());\n+\t\treturn;\n+\t}\n+\n+\tif (strncmp(scheme, \"ipc\", 3) == 0) {\n+#ifdef _WIN32\n+\t\t// Windows doesn't place IPC names in the filesystem.\n+\t\t(void) snprintf(addr, sz, \"%s://testutil%04x%04x%04x%04x\",\n+\t\t    scheme, nng_random(), nng_random(), nng_random(),\n+\t\t    nng_random());\n+#else\n+\t\tchar *tmpdir;\n+\n+\t\tif (((tmpdir = getenv(\"TMPDIR\")) == NULL) &&\n+\t\t    ((tmpdir = getenv(\"TEMP\")) == NULL) &&\n+\t\t    ((tmpdir = getenv(\"TMP\")) == NULL)) {\n+\t\t\ttmpdir = \"/tmp\";\n+\t\t}\n+\n+\t\t(void) snprintf(addr, sz, \"%s://%s/testutil%04x%04x%04x%04x\",\n+\t\t    scheme, tmpdir, nng_random(), nng_random(), nng_random(),\n+\t\t    nng_random());\n+\t\treturn;\n+#endif\n+\t}\n+\n+\t// We should not be here.\n+\tabort();\n+}\n+\n // testutil_next_port returns a \"next\" allocation port.\n // Ports are chosen by starting from a random point within a\n // range (normally 38000-40000, but other good places to choose\ndiff --git a/tests/testutil.h b/tests/testutil.h\nindex b9acfedff..14cc17127 100644\n--- a/tests/testutil.h\n+++ b/tests/testutil.h\n@@ -40,6 +40,11 @@ extern void testutil_sleep(int);\n // testutil_next_port returns a new port number (presumably unique)\n extern uint16_t testutil_next_port(void);\n \n+// testutil_scratch_addr makes a scratch address for the given scheme.\n+// The address buffer must be supplied, and the size should be at least\n+// 64 bytes to ensure no truncation occurs.\n+extern void testutil_scratch_addr(const char *, size_t, char *);\n+\n // testutil_marry connects two sockets using inproc.  It uses socket\n // pipe hooks to ensure that it does not return before both sockets\n // are fully connected.\n", "problem_statement": "Desire better way to access statistics for NNG objects\nThis is mostly going to be useful in the test framework.\r\n\r\nWe would like to be able to find a specific statistics tree for a dialer, listener, or socket.\r\n\r\nWe might also like to find a named statistic, generically.\n", "hints_text": "", "created_at": "2020-01-01T02:24:11Z"}
{"repo": "nanomsg/nng", "pull_number": 613, "instance_id": "nanomsg__nng-613", "issue_numbers": ["616"], "base_commit": "ccc24a8e508131a2226474642a038baaa2cbcc8c", "patch": "diff --git a/src/core/aio.c b/src/core/aio.c\nindex 40638bced..294a0b923 100644\n--- a/src/core/aio.c\n+++ b/src/core/aio.c\n@@ -217,11 +217,17 @@ void\n nni_aio_stop(nni_aio *aio)\n {\n \tif (aio != NULL) {\n+\t\tnni_aio_cancelfn cancelfn;\n+\n \t\tnni_mtx_lock(&nni_aio_lk);\n-\t\taio->a_stop = true;\n+\t\tcancelfn           = aio->a_prov_cancel;\n+\t\taio->a_prov_cancel = NULL;\n+\t\taio->a_stop        = true;\n \t\tnni_mtx_unlock(&nni_aio_lk);\n \n-\t\tnni_aio_abort(aio, NNG_ECANCELED);\n+\t\tif (cancelfn != NULL) {\n+\t\t\tcancelfn(aio, NNG_ECANCELED);\n+\t\t}\n \n \t\tnni_aio_wait(aio);\n \t}\ndiff --git a/src/core/dialer.c b/src/core/dialer.c\nindex 34e908917..4b2f105db 100644\n--- a/src/core/dialer.c\n+++ b/src/core/dialer.c\n@@ -232,24 +232,18 @@ dialer_timer_cb(void *arg)\n static void\n dialer_connect_cb(void *arg)\n {\n-\tnni_dialer *d = arg;\n-\tnni_pipe *  p;\n+\tnni_dialer *d   = arg;\n \tnni_aio *   aio = d->d_con_aio;\n \tint         rv;\n \tbool        synch;\n \n-\tif ((rv = nni_aio_result(aio)) == 0) {\n-\t\tvoid *data = nni_aio_get_output(aio, 0);\n-\t\tNNI_ASSERT(data != NULL);\n-\t\trv = nni_pipe_create(&p, d->d_sock, d->d_tran, data);\n-\t}\n \tnni_mtx_lock(&d->d_mtx);\n \tsynch = d->d_synch;\n \tnni_mtx_unlock(&d->d_mtx);\n \n-\tswitch (rv) {\n+\tswitch ((rv = nni_aio_result(aio))) {\n \tcase 0:\n-\t\tnni_dialer_add_pipe(d, p);\n+\t\tnni_dialer_add_pipe(d, nni_aio_get_output(aio, 0));\n \t\tbreak;\n \tcase NNG_ECLOSED:   // No further action.\n \tcase NNG_ECANCELED: // No further action.\ndiff --git a/src/core/listener.c b/src/core/listener.c\nindex debfa5f1c..17062d6eb 100644\n--- a/src/core/listener.c\n+++ b/src/core/listener.c\n@@ -181,6 +181,8 @@ nni_listener_close(nni_listener *l)\n \t}\n \tl->l_closed = true;\n \tnni_mtx_unlock(&listeners_lk);\n+\tnni_aio_close(l->l_acc_aio);\n+\tnni_aio_close(l->l_tmo_aio);\n \n \t// Remove us from the table so we cannot be found.\n \t// This is done fairly early in the teardown process.\n@@ -228,28 +230,25 @@ listener_timer_cb(void *arg)\n static void\n listener_accept_cb(void *arg)\n {\n-\tnni_listener *l = arg;\n-\tnni_pipe *    p;\n+\tnni_listener *l   = arg;\n \tnni_aio *     aio = l->l_acc_aio;\n-\tint           rv;\n \n-\tif ((rv = nni_aio_result(aio)) == 0) {\n-\t\tvoid *data = nni_aio_get_output(aio, 0);\n-\t\tNNI_ASSERT(data != NULL);\n-\t\trv = nni_pipe_create(&p, l->l_sock, l->l_tran, data);\n-\t}\n-\tswitch (rv) {\n+\tswitch (nni_aio_result(aio)) {\n \tcase 0:\n-\t\tnni_listener_add_pipe(l, p);\n+\t\tnni_listener_add_pipe(l, nni_aio_get_output(aio, 0));\n \t\tlistener_accept_start(l);\n \t\tbreak;\n \tcase NNG_ECONNABORTED: // remote condition, no cooldown\n \tcase NNG_ECONNRESET:   // remote condition, no cooldown\n+\tcase NNG_EPEERAUTH:    // peer validation failure\n \t\tlistener_accept_start(l);\n \t\tbreak;\n \tcase NNG_ECLOSED:   // no further action\n \tcase NNG_ECANCELED: // no further action\n \t\tbreak;\n+\tcase NNG_ENOMEM:\n+\tcase NNG_ENOFILES:\n+\tcase NNG_ENOSPC:\n \tdefault:\n \t\t// We don't really know why we failed, but we backoff\n \t\t// here. This is because errors here are probably due\ndiff --git a/src/core/pipe.c b/src/core/pipe.c\nindex 4f50ac7c4..374c45c84 100644\n--- a/src/core/pipe.c\n+++ b/src/core/pipe.c\n@@ -75,9 +75,6 @@ pipe_destroy(nni_pipe *p)\n \t}\n \tnni_mtx_unlock(&nni_pipe_lk);\n \n-\t// Wait for neg callbacks to finish. (Already closed).\n-\tnni_aio_stop(p->p_start_aio);\n-\n \tif (p->p_proto_data != NULL) {\n \t\tp->p_proto_ops.pipe_stop(p->p_proto_data);\n \t}\n@@ -93,7 +90,6 @@ pipe_destroy(nni_pipe *p)\n \tif (p->p_tran_data != NULL) {\n \t\tp->p_tran_ops.p_fini(p->p_tran_data);\n \t}\n-\tnni_aio_fini(p->p_start_aio);\n \tnni_cv_fini(&p->p_cv);\n \tnni_mtx_fini(&p->p_mtx);\n \tNNI_FREE_STRUCT(p);\n@@ -154,9 +150,6 @@ nni_pipe_send(nni_pipe *p, nni_aio *aio)\n void\n nni_pipe_close(nni_pipe *p)\n {\n-\t// abort any pending negotiation/start process.\n-\tnni_aio_close(p->p_start_aio);\n-\n \tnni_mtx_lock(&p->p_mtx);\n \tif (p->p_closed) {\n \t\t// We already did a close.\n@@ -178,49 +171,12 @@ nni_pipe_close(nni_pipe *p)\n \tnni_reap(&p->p_reap, (nni_cb) pipe_destroy, p);\n }\n \n-bool\n-nni_pipe_closed(nni_pipe *p)\n-{\n-\tbool rv;\n-\tnni_mtx_lock(&p->p_mtx);\n-\trv = p->p_closed;\n-\tnni_mtx_unlock(&p->p_mtx);\n-\treturn (rv);\n-}\n-\n uint16_t\n nni_pipe_peer(nni_pipe *p)\n {\n \treturn (p->p_tran_ops.p_peer(p->p_tran_data));\n }\n \n-static void\n-nni_pipe_start_cb(void *arg)\n-{\n-\tnni_pipe *p   = arg;\n-\tnni_sock *s   = p->p_sock;\n-\tnni_aio * aio = p->p_start_aio;\n-\n-\tif (nni_aio_result(aio) != 0) {\n-\t\tnni_pipe_close(p);\n-\t\treturn;\n-\t}\n-\n-\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_PRE);\n-\tif (nni_pipe_closed(p)) {\n-\t\tnni_pipe_close(p);\n-\t\treturn;\n-\t}\n-\n-\tif ((p->p_proto_ops.pipe_start(p->p_proto_data) != 0) ||\n-\t    nni_sock_closing(s)) {\n-\t\tnni_pipe_close(p);\n-\t\treturn;\n-\t}\n-\n-\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_POST);\n-}\n-\n int\n nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n {\n@@ -228,6 +184,7 @@ nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n \tint                 rv;\n \tvoid *              sdata = nni_sock_proto_data(sock);\n \tnni_proto_pipe_ops *pops  = nni_sock_proto_pipe_ops(sock);\n+\tuint64_t            id;\n \n \tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n \t\t// In this case we just toss the pipe...\n@@ -236,7 +193,6 @@ nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n \t}\n \n \t// Make a private copy of the transport ops.\n-\tp->p_start_aio  = NULL;\n \tp->p_tran_ops   = *tran->tran_pipe;\n \tp->p_tran_data  = tdata;\n \tp->p_proto_ops  = *pops;\n@@ -253,14 +209,11 @@ nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n \tnni_mtx_init(&p->p_mtx);\n \tnni_cv_init(&p->p_cv, &nni_pipe_lk);\n \n-\tif ((rv = nni_aio_init(&p->p_start_aio, nni_pipe_start_cb, p)) == 0) {\n-\t\tuint64_t id;\n-\t\tnni_mtx_lock(&nni_pipe_lk);\n-\t\tif ((rv = nni_idhash_alloc(nni_pipes, &id, p)) == 0) {\n-\t\t\tp->p_id = (uint32_t) id;\n-\t\t}\n-\t\tnni_mtx_unlock(&nni_pipe_lk);\n+\tnni_mtx_lock(&nni_pipe_lk);\n+\tif ((rv = nni_idhash_alloc(nni_pipes, &id, p)) == 0) {\n+\t\tp->p_id = (uint32_t) id;\n \t}\n+\tnni_mtx_unlock(&nni_pipe_lk);\n \n \tif ((rv != 0) ||\n \t    ((rv = pops->pipe_init(&p->p_proto_data, p, sdata)) != 0)) {\n@@ -296,16 +249,6 @@ nni_pipe_getopt(\n \treturn (NNG_ENOTSUP);\n }\n \n-void\n-nni_pipe_start(nni_pipe *p)\n-{\n-\tif (p->p_tran_ops.p_start == NULL) {\n-\t\tnni_aio_finish(p->p_start_aio, 0, 0);\n-\t} else {\n-\t\tp->p_tran_ops.p_start(p->p_tran_data, p->p_start_aio);\n-\t}\n-}\n-\n void *\n nni_pipe_get_proto_data(nni_pipe *p)\n {\ndiff --git a/src/core/pipe.h b/src/core/pipe.h\nindex 1d73ce517..1e2f2b5d6 100644\n--- a/src/core/pipe.h\n+++ b/src/core/pipe.h\n@@ -59,11 +59,6 @@ extern uint32_t nni_pipe_listener_id(nni_pipe *);\n // nni_pipe_dialer_id returns the dialer id for the pipe (or 0 if none).\n extern uint32_t nni_pipe_dialer_id(nni_pipe *);\n \n-// nni_pipe_closed returns true if nni_pipe_close was called.\n-// (This is used by the socket to determine if user closed the pipe\n-// during callback.)\n-extern bool nni_pipe_closed(nni_pipe *);\n-\n // nni_pipe_rele releases the hold on the pipe placed by nni_pipe_find.\n extern void nni_pipe_rele(nni_pipe *);\n \ndiff --git a/src/core/socket.c b/src/core/socket.c\nindex f4e59af50..0fa776f13 100644\n--- a/src/core/socket.c\n+++ b/src/core/socket.c\n@@ -399,16 +399,6 @@ nni_sock_rele(nni_sock *s)\n \tnni_mtx_unlock(&sock_lk);\n }\n \n-bool\n-nni_sock_closing(nni_sock *s)\n-{\n-\tbool rv;\n-\tnni_mtx_lock(&s->s_mx);\n-\trv = s->s_closing;\n-\tnni_mtx_unlock(&s->s_mx);\n-\treturn (rv);\n-}\n-\n static void\n sock_destroy(nni_sock *s)\n {\n@@ -1382,16 +1372,36 @@ nni_dialer_timer_start(nni_dialer *d)\n \tnni_mtx_unlock(&s->s_mx);\n }\n \n+static void\n+pipe_start(nni_pipe *p)\n+{\n+\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_PRE);\n+\n+\t// As the callback above that would close the pipe runs on\n+\t// this thread, we can skip the lock.\n+\tif (p->p_closed) {\n+\t\treturn;\n+\t}\n+\n+\tif (p->p_proto_ops.pipe_start(p->p_proto_data) != 0) {\n+\t\tnni_pipe_close(p);\n+\t\treturn;\n+\t}\n+\n+\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_POST);\n+}\n+\n void\n-nni_dialer_add_pipe(nni_dialer *d, nni_pipe *p)\n+nni_dialer_add_pipe(nni_dialer *d, void *tpipe)\n {\n \tnni_sock *s = d->d_sock;\n+\tnni_pipe *p;\n \n \tnni_mtx_lock(&s->s_mx);\n \n-\tif (s->s_closed || d->d_closing) {\n+\tif (s->s_closed || d->d_closing ||\n+\t    (nni_pipe_create(&p, d->d_sock, d->d_tran, tpipe) != 0)) {\n \t\tnni_mtx_unlock(&s->s_mx);\n-\t\tnni_pipe_close(p);\n \t\treturn;\n \t}\n \n@@ -1403,7 +1413,7 @@ nni_dialer_add_pipe(nni_dialer *d, nni_pipe *p)\n \tnni_mtx_unlock(&s->s_mx);\n \n \t// Start the initial negotiation I/O...\n-\tnni_pipe_start(p);\n+\tpipe_start(p);\n }\n \n static void\n@@ -1473,14 +1483,15 @@ nni_dialer_reap(nni_dialer *d)\n }\n \n void\n-nni_listener_add_pipe(nni_listener *l, nni_pipe *p)\n+nni_listener_add_pipe(nni_listener *l, void *tpipe)\n {\n \tnni_sock *s = l->l_sock;\n+\tnni_pipe *p;\n \n \tnni_mtx_lock(&s->s_mx);\n-\tif (s->s_closed || l->l_closing) {\n+\tif (s->s_closed || l->l_closing ||\n+\t    (nni_pipe_create(&p, l->l_sock, l->l_tran, tpipe) != 0)) {\n \t\tnni_mtx_unlock(&s->s_mx);\n-\t\tnni_pipe_close(p);\n \t\treturn;\n \t}\n \tp->p_listener = l;\n@@ -1489,7 +1500,7 @@ nni_listener_add_pipe(nni_listener *l, nni_pipe *p)\n \tnni_mtx_unlock(&s->s_mx);\n \n \t// Start the initial negotiation I/O...\n-\tnni_pipe_start(p);\n+\tpipe_start(p);\n }\n \n static void\n@@ -1600,7 +1611,10 @@ nni_pipe_remove(nni_pipe *p)\n \tp->p_dialer   = NULL;\n \tif ((d != NULL) && (d->d_pipe == p)) {\n \t\td->d_pipe = NULL;\n-\t\tdialer_timer_start_locked(d); // Kick the timer to redial.\n+\t\tif (!s->s_closing) {\n+\t\t\tdialer_timer_start_locked(\n+\t\t\t    d); // Kick the timer to redial.\n+\t\t}\n \t}\n \tif (s->s_closing) {\n \t\tnni_cv_wake(&s->s_cv);\ndiff --git a/src/core/socket.h b/src/core/socket.h\nindex 4b9c46429..cebe87ca4 100644\n--- a/src/core/socket.h\n+++ b/src/core/socket.h\n@@ -62,8 +62,6 @@ extern uint32_t nni_sock_flags(nni_sock *);\n // should be executed.\n extern void nni_sock_set_pipe_cb(nni_sock *sock, int, nng_pipe_cb, void *);\n \n-extern bool nni_sock_closing(nni_sock *sock);\n-\n // nni_ctx_open is used to open/create a new context structure.\n // Contexts are not supported by most protocols, but for those that do,\n // this can offer some improvements for massive concurrency/scalability.\ndiff --git a/src/core/sockimpl.h b/src/core/sockimpl.h\nindex 569e5caed..29e83f7a0 100644\n--- a/src/core/sockimpl.h\n+++ b/src/core/sockimpl.h\n@@ -78,7 +78,6 @@ struct nni_pipe {\n \tnni_mtx            p_mtx;\n \tnni_cv             p_cv;\n \tnni_reap_item      p_reap;\n-\tnni_aio *          p_start_aio;\n };\n \n extern int  nni_sock_add_dialer(nni_sock *, nni_dialer *);\n@@ -87,14 +86,14 @@ extern void nni_sock_remove_dialer(nni_sock *, nni_dialer *);\n extern int  nni_sock_add_listener(nni_sock *, nni_listener *);\n extern void nni_sock_remove_listener(nni_sock *, nni_listener *);\n \n-extern void nni_dialer_add_pipe(nni_dialer *, nni_pipe *);\n+extern void nni_dialer_add_pipe(nni_dialer *, void *);\n extern void nni_dialer_shutdown(nni_dialer *);\n extern void nni_dialer_reap(nni_dialer *);\n extern void nni_dialer_destroy(nni_dialer *);\n extern void nni_dialer_timer_start(nni_dialer *);\n extern void nni_dialer_close_rele(nni_dialer *);\n \n-extern void nni_listener_add_pipe(nni_listener *, nni_pipe *);\n+extern void nni_listener_add_pipe(nni_listener *, void *);\n extern void nni_listener_shutdown(nni_listener *);\n extern void nni_listener_reap(nni_listener *);\n extern void nni_listener_destroy(nni_listener *);\ndiff --git a/src/core/transport.h b/src/core/transport.h\nindex 257d232d5..458bfda4d 100644\n--- a/src/core/transport.h\n+++ b/src/core/transport.h\n@@ -30,7 +30,8 @@ enum nni_ep_mode {\n #define NNI_TRANSPORT_V1 0x54520001\n #define NNI_TRANSPORT_V2 0x54520002\n #define NNI_TRANSPORT_V3 0x54520003\n-#define NNI_TRANSPORT_VERSION NNI_TRANSPORT_V3\n+#define NNI_TRANSPORT_V4 0x54520004\n+#define NNI_TRANSPORT_VERSION NNI_TRANSPORT_V4\n \n // Option handlers.\n struct nni_tran_option {\n@@ -131,19 +132,12 @@ struct nni_tran_pipe_ops {\n \t// make further calls on the same pipe.\n \tvoid (*p_fini)(void *);\n \n-\t// p_start starts the pipe running.  This gives the transport a\n-\t// chance to hook into any transport specific negotiation\n-\t// phase. The pipe will not have its p_send or p_recv calls\n-\t// started, and will not be access by the \"socket\" until the\n-\t// pipe has indicated its readiness by finishing the aio.\n-\tvoid (*p_start)(void *, nni_aio *);\n-\n \t// p_stop stops the pipe, waiting for any callbacks that are\n \t// outstanding to complete.  This is done before tearing down\n \t// resources with p_fini.\n \tvoid (*p_stop)(void *);\n \n-\t// p_aio_send queues the message for transmit.  If this fails,\n+\t// p_send queues the message for transmit.  If this fails,\n \t// then the caller may try again with the same message (or free\n \t// it).  If the call succeeds, then the transport has taken\n \t// ownership of the message, and the caller may not use it\ndiff --git a/src/platform/posix/posix_ipcconn.c b/src/platform/posix/posix_ipcconn.c\nindex 2b46fb12e..539a00ba9 100644\n--- a/src/platform/posix/posix_ipcconn.c\n+++ b/src/platform/posix/posix_ipcconn.c\n@@ -47,6 +47,10 @@ ipc_conn_dowrite(nni_ipc_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->writeq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \n@@ -129,6 +133,10 @@ ipc_conn_doread(nni_ipc_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->readq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \ndiff --git a/src/platform/posix/posix_tcpconn.c b/src/platform/posix/posix_tcpconn.c\nindex c0352c552..cf85e8e8c 100644\n--- a/src/platform/posix/posix_tcpconn.c\n+++ b/src/platform/posix/posix_tcpconn.c\n@@ -43,6 +43,10 @@ tcp_conn_dowrite(nni_tcp_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->writeq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \n@@ -125,6 +129,10 @@ tcp_conn_doread(nni_tcp_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->readq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \ndiff --git a/src/transport/ipc/ipc.c b/src/transport/ipc/ipc.c\nindex ee72d6d87..3d798d4c1 100644\n--- a/src/transport/ipc/ipc.c\n+++ b/src/transport/ipc/ipc.c\n@@ -23,14 +23,20 @@\n typedef struct ipctran_pipe     ipctran_pipe;\n typedef struct ipctran_dialer   ipctran_dialer;\n typedef struct ipctran_listener ipctran_listener;\n+typedef struct ipctran_ep       ipctran_ep;\n \n // ipc_pipe is one end of an IPC connection.\n struct ipctran_pipe {\n-\tnni_ipc_conn *conn;\n-\tuint16_t      peer;\n-\tuint16_t      proto;\n-\tsize_t        rcvmax;\n-\tnni_sockaddr  sa;\n+\tnni_ipc_conn *  conn;\n+\tuint16_t        peer;\n+\tuint16_t        proto;\n+\tsize_t          rcvmax;\n+\tnni_atomic_flag reaped;\n+\tnni_sockaddr    sa;\n+\tnni_list_node   node;\n+\tipctran_ep *    ep;\n+\tnni_reap_item   reap;\n+\tbool            closed;\n \n \tuint8_t txhead[1 + sizeof(uint64_t)];\n \tuint8_t rxhead[1 + sizeof(uint64_t)];\n@@ -41,32 +47,34 @@ struct ipctran_pipe {\n \n \tnni_list recvq;\n \tnni_list sendq;\n-\tnni_aio *user_negaio;\n+\tnni_aio *useraio;\n \tnni_aio *txaio;\n \tnni_aio *rxaio;\n-\tnni_aio *negaio;\n+\tnni_aio *negoaio;\n+\tnni_aio *connaio;\n \tnni_msg *rxmsg;\n \tnni_mtx  mtx;\n };\n \n+struct ipctran_ep {\n+\tnni_mtx       mtx;\n+\tnni_list      pipes;\n+\tbool          fini;\n+\tsize_t        rcvmax;\n+\tuint16_t      proto;\n+\tnni_cb        dtor;\n+\tnni_sockaddr  sa;\n+\tnni_reap_item reap;\n+};\n+\n struct ipctran_dialer {\n-\tnni_sockaddr    sa;\n+\tipctran_ep      ep;\n \tnni_ipc_dialer *dialer;\n-\tuint16_t        proto;\n-\tsize_t          rcvmax;\n-\tnni_aio *       aio;\n-\tnni_aio *       user_aio;\n-\tnni_mtx         mtx;\n };\n \n struct ipctran_listener {\n-\tnni_sockaddr      sa;\n+\tipctran_ep        ep;\n \tnni_ipc_listener *listener;\n-\tuint16_t          proto;\n-\tsize_t            rcvmax;\n-\tnni_aio *         aio;\n-\tnni_aio *         user_aio;\n-\tnni_mtx           mtx;\n };\n \n static void ipctran_pipe_send_start(ipctran_pipe *);\n@@ -74,8 +82,8 @@ static void ipctran_pipe_recv_start(ipctran_pipe *);\n static void ipctran_pipe_send_cb(void *);\n static void ipctran_pipe_recv_cb(void *);\n static void ipctran_pipe_nego_cb(void *);\n-static void ipctran_dialer_cb(void *);\n-static void ipctran_listener_cb(void *);\n+static void ipctran_pipe_conn_cb(void *);\n+static void ipctran_pipe_reap(ipctran_pipe *);\n \n static int\n ipctran_init(void)\n@@ -95,7 +103,8 @@ ipctran_pipe_close(void *arg)\n \n \tnni_aio_close(p->rxaio);\n \tnni_aio_close(p->txaio);\n-\tnni_aio_close(p->negaio);\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n \n \tnni_ipc_conn_close(p->conn);\n }\n@@ -105,19 +114,39 @@ ipctran_pipe_stop(void *arg)\n {\n \tipctran_pipe *p = arg;\n \n+\tnni_mtx_lock(&p->mtx);\n+\tp->closed = true;\n+\tnni_mtx_unlock(&p->mtx);\n+\n \tnni_aio_stop(p->rxaio);\n \tnni_aio_stop(p->txaio);\n-\tnni_aio_stop(p->negaio);\n+\tnni_aio_stop(p->negoaio);\n+\tnni_aio_stop(p->connaio);\n }\n \n static void\n ipctran_pipe_fini(void *arg)\n {\n \tipctran_pipe *p = arg;\n+\tipctran_ep *  ep;\n+\n+\tif (p == NULL) {\n+\t\treturn;\n+\t}\n+\tipctran_pipe_stop(p);\n+\tif ((ep = p->ep) != NULL) {\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tnni_list_remove(&ep->pipes, p);\n+\t\tif (ep->fini && nni_list_empty(&ep->pipes)) {\n+\t\t\tnni_reap(&ep->reap, ep->dtor, ep);\n+\t\t}\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t}\n \n \tnni_aio_fini(p->rxaio);\n \tnni_aio_fini(p->txaio);\n-\tnni_aio_fini(p->negaio);\n+\tnni_aio_fini(p->negoaio);\n+\tnni_aio_fini(p->connaio);\n \tif (p->conn != NULL) {\n \t\tnni_ipc_conn_fini(p->conn);\n \t}\n@@ -128,8 +157,16 @@ ipctran_pipe_fini(void *arg)\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+ipctran_pipe_reap(ipctran_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n+\t\tnni_reap(&p->reap, ipctran_pipe_fini, p);\n+\t}\n+}\n+\n static int\n-ipctran_pipe_init(ipctran_pipe **pipep, void *conn)\n+ipctran_pipe_init(ipctran_pipe **pipep, ipctran_ep *ep)\n {\n \tipctran_pipe *p;\n \tint           rv;\n@@ -138,51 +175,75 @@ ipctran_pipe_init(ipctran_pipe **pipep, void *conn)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&p->mtx);\n+\tNNI_LIST_NODE_INIT(&p->node);\n \tif (((rv = nni_aio_init(&p->txaio, ipctran_pipe_send_cb, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->rxaio, ipctran_pipe_recv_cb, p)) != 0) ||\n-\t    ((rv = nni_aio_init(&p->negaio, ipctran_pipe_nego_cb, p)) != 0)) {\n-\t\tipctran_pipe_fini(p);\n+\t    ((rv = nni_aio_init(&p->negoaio, ipctran_pipe_nego_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->connaio, ipctran_pipe_conn_cb, p)) != 0)) {\n+\t\tipctran_pipe_reap(p);\n \t\treturn (rv);\n \t}\n \tnni_aio_list_init(&p->sendq);\n \tnni_aio_list_init(&p->recvq);\n \n-\tp->conn = conn;\n-#if 0\n-\tp->proto              = ep->proto;\n-\tp->rcvmax             = ep->rcvmax;\n-\tp->sa.s_ipc.sa_family = NNG_AF_IPC;\n-\tp->sa                 = ep->sa;\n-#endif\n+\tnni_list_append(&ep->pipes, p);\n+\tp->ep     = ep;\n+\tp->proto  = ep->proto;\n+\tp->rcvmax = ep->rcvmax;\n+\tp->sa     = ep->sa;\n+\n \t*pipep = p;\n \treturn (0);\n }\n \n static void\n-ipctran_pipe_nego_cancel(nni_aio *aio, int rv)\n+ipctran_pipe_conn_cb(void *arg)\n {\n-\tipctran_pipe *p = nni_aio_get_prov_data(aio);\n+\tipctran_pipe *p   = arg;\n+\tnni_aio *     aio = p->connaio;\n+\tnni_iov       iov;\n+\tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n-\tif (p->user_negaio != aio) {\n-\t\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\tipctran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tp->user_negaio = NULL;\n-\tnni_mtx_unlock(&p->mtx);\n \n-\tnni_aio_abort(p->negaio, rv);\n-\tnni_aio_finish_error(aio, rv);\n+\tp->conn      = nni_aio_get_output(aio, 0);\n+\tp->txhead[0] = 0;\n+\tp->txhead[1] = 'S';\n+\tp->txhead[2] = 'P';\n+\tp->txhead[3] = 0;\n+\tNNI_PUT16(&p->txhead[4], p->proto);\n+\tNNI_PUT16(&p->txhead[6], 0);\n+\n+\tp->gotrxhead  = 0;\n+\tp->gottxhead  = 0;\n+\tp->wantrxhead = 8;\n+\tp->wanttxhead = 8;\n+\tiov.iov_len   = 8;\n+\tiov.iov_buf   = &p->txhead[0];\n+\tnni_aio_set_iov(p->negoaio, 1, &iov);\n+\tnni_ipc_conn_send(p->conn, p->negoaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n }\n \n static void\n ipctran_pipe_nego_cb(void *arg)\n {\n \tipctran_pipe *p   = arg;\n-\tnni_aio *     aio = p->negaio;\n+\tnni_aio *     aio = p->negoaio;\n+\tnni_aio *     uaio;\n \tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n \tif ((rv = nni_aio_result(aio)) != 0) {\n \t\tgoto done;\n \t}\n@@ -201,7 +262,7 @@ ipctran_pipe_nego_cb(void *arg)\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\t// send it down...\n \t\tnni_ipc_conn_send(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \tif (p->gotrxhead < p->wantrxhead) {\n@@ -210,7 +271,7 @@ ipctran_pipe_nego_cb(void *arg)\n \t\tiov.iov_buf = &p->rxhead[p->gotrxhead];\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_ipc_conn_recv(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \t// We have both sent and received the headers.  Lets check the\n@@ -225,11 +286,19 @@ ipctran_pipe_nego_cb(void *arg)\n \tNNI_GET16(&p->rxhead[4], p->peer);\n \n done:\n-\tif ((aio = p->user_negaio) != NULL) {\n-\t\tp->user_negaio = NULL;\n-\t\tnni_aio_finish(aio, rv, 0);\n+\n+\tif ((uaio = p->useraio) != NULL) {\n+\t\tp->useraio = NULL;\n+\t\tif (rv == 0) {\n+\t\t\tnni_aio_set_output(uaio, 0, p);\n+\t\t\tnni_aio_finish(uaio, 0, 0);\n+\t\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\t\treturn;\n+\t\t}\n+\t\tnni_aio_finish_error(uaio, rv);\n \t}\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&p->ep->mtx);\n+\tipctran_pipe_reap(p);\n }\n \n static void\n@@ -243,17 +312,20 @@ ipctran_pipe_send_cb(void *arg)\n \tnni_aio *     txaio = p->txaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->sendq);\n \n-\tif ((rv = nni_aio_result(txaio)) != 0) {\n+\trv = p->closed ? NNG_ECLOSED : nni_aio_result(txaio);\n+\n+\tif (rv != 0) {\n \t\t// Intentionally we do not queue up another transfer.\n \t\t// There's an excellent chance that the pipe is no longer\n \t\t// usable, with a partial transfer.\n \t\t// The protocol should see this error, and close the\n \t\t// pipe itself, we hope.\n-\t\tnni_aio_list_remove(aio);\n+\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, rv);\n+\t\t}\n \t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n \t\treturn;\n \t}\n \n@@ -265,6 +337,7 @@ ipctran_pipe_send_cb(void *arg)\n \t\treturn;\n \t}\n \n+\taio = nni_list_first(&p->sendq);\n \tnni_aio_list_remove(aio);\n \tipctran_pipe_send_start(p);\n \n@@ -288,7 +361,6 @@ ipctran_pipe_recv_cb(void *arg)\n \tnni_aio *     rxaio = p->rxaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->recvq);\n \n \tif ((rv = nni_aio_result(rxaio)) != 0) {\n \t\t// Error on receive.  This has to cause an error back\n@@ -296,6 +368,10 @@ ipctran_pipe_recv_cb(void *arg)\n \t\t// toss it.\n \t\tgoto recv_error;\n \t}\n+\tif (p->closed) {\n+\t\trv = NNG_ECLOSED;\n+\t\tgoto recv_error;\n+\t}\n \n \tn = nni_aio_count(rxaio);\n \tnni_aio_iov_advance(rxaio, n);\n@@ -354,6 +430,7 @@ ipctran_pipe_recv_cb(void *arg)\n \t// Otherwise we got a message read completely.  Let the user know the\n \t// good news.\n \n+\taio = nni_list_first(&p->recvq);\n \tnni_aio_list_remove(aio);\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n@@ -367,7 +444,10 @@ ipctran_pipe_recv_cb(void *arg)\n \treturn;\n \n recv_error:\n-\tnni_aio_list_remove(aio);\n+\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n+\t\tnni_aio_list_remove(aio);\n+\t\tnni_aio_finish_error(aio, rv);\n+\t}\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n \t// Intentionally, we do not queue up another receive.\n@@ -375,7 +455,6 @@ ipctran_pipe_recv_cb(void *arg)\n \tnni_mtx_unlock(&p->mtx);\n \n \tnni_msg_free(msg);\n-\tnni_aio_finish_error(aio, rv);\n }\n \n static void\n@@ -452,6 +531,11 @@ ipctran_pipe_send(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, ipctran_pipe_send_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -514,6 +598,11 @@ ipctran_pipe_recv(void *arg, nni_aio *aio)\n \t}\n \tnni_mtx_lock(&p->mtx);\n \n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, ipctran_pipe_recv_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -527,43 +616,6 @@ ipctran_pipe_recv(void *arg, nni_aio *aio)\n \tnni_mtx_unlock(&p->mtx);\n }\n \n-static void\n-ipctran_pipe_start(void *arg, nni_aio *aio)\n-{\n-\tipctran_pipe *p = arg;\n-\tnni_aio *     negaio;\n-\tnni_iov       iov;\n-\tint           rv;\n-\n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n-\t}\n-\tnni_mtx_lock(&p->mtx);\n-\tif ((rv = nni_aio_schedule(aio, ipctran_pipe_nego_cancel, p)) != 0) {\n-\t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tp->txhead[0] = 0;\n-\tp->txhead[1] = 'S';\n-\tp->txhead[2] = 'P';\n-\tp->txhead[3] = 0;\n-\tNNI_PUT16(&p->txhead[4], p->proto);\n-\tNNI_PUT16(&p->txhead[6], 0);\n-\n-\tp->user_negaio = aio;\n-\tp->gotrxhead   = 0;\n-\tp->gottxhead   = 0;\n-\tp->wantrxhead  = 8;\n-\tp->wanttxhead  = 8;\n-\tnegaio         = p->negaio;\n-\tiov.iov_len    = 8;\n-\tiov.iov_buf    = &p->txhead[0];\n-\tnni_aio_set_iov(negaio, 1, &iov);\n-\tnni_ipc_conn_send(p->conn, negaio);\n-\tnni_mtx_unlock(&p->mtx);\n-}\n-\n static uint16_t\n ipctran_pipe_peer(void *arg)\n {\n@@ -632,21 +684,42 @@ ipctran_dialer_fini(void *arg)\n {\n \tipctran_dialer *d = arg;\n \n-\tnni_aio_stop(d->aio);\n+\tnni_mtx_lock(&d->ep.mtx);\n \tif (d->dialer != NULL) {\n \t\tnni_ipc_dialer_fini(d->dialer);\n+\t\td->dialer = NULL;\n+\t}\n+\td->ep.fini = true;\n+\tif (!nni_list_empty(&d->ep.pipes)) {\n+\t\tnni_mtx_unlock(&d->ep.mtx);\n+\t\treturn;\n \t}\n-\tnni_aio_fini(d->aio);\n-\tnni_mtx_fini(&d->mtx);\n+\tnni_mtx_unlock(&d->ep.mtx);\n+\n+\tnni_mtx_fini(&d->ep.mtx);\n \tNNI_FREE_STRUCT(d);\n }\n \n+static void\n+ipctran_ep_close(void *arg)\n+{\n+\tipctran_ep *  ep = arg;\n+\tipctran_pipe *p;\n+\n+\tnni_mtx_lock(&ep->mtx);\n+\tNNI_LIST_FOREACH (&ep->pipes, p) {\n+\t\tnni_aio_close(p->negoaio);\n+\t\tnni_aio_close(p->connaio);\n+\t}\n+\tnni_mtx_unlock(&ep->mtx);\n+}\n+\n static void\n ipctran_dialer_close(void *arg)\n {\n \tipctran_dialer *d = arg;\n \n-\tnni_aio_close(d->aio);\n+\tipctran_ep_close(&d->ep);\n \tnni_ipc_dialer_close(d->dialer);\n }\n \n@@ -660,90 +733,46 @@ ipctran_dialer_init(void **dp, nni_url *url, nni_sock *sock)\n \tif ((d = NNI_ALLOC_STRUCT(d)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&d->mtx);\n+\tnni_mtx_init(&d->ep.mtx);\n+\tNNI_LIST_INIT(&d->ep.pipes, ipctran_pipe, node);\n \n-\tsz                    = sizeof(d->sa.s_ipc.sa_path);\n-\td->sa.s_ipc.sa_family = NNG_AF_IPC;\n+\tsz                       = sizeof(d->ep.sa.s_ipc.sa_path);\n+\td->ep.sa.s_ipc.sa_family = NNG_AF_IPC;\n+\td->ep.proto              = nni_sock_proto_id(sock);\n+\td->ep.dtor               = ipctran_dialer_fini;\n \n-\tif (nni_strlcpy(d->sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n+\tif (nni_strlcpy(d->ep.sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n \t\tipctran_dialer_fini(d);\n \t\treturn (NNG_EADDRINVAL);\n \t}\n \n-\tif (((rv = nni_ipc_dialer_init(&d->dialer)) != 0) ||\n-\t    ((rv = nni_aio_init(&d->aio, ipctran_dialer_cb, d)) != 0)) {\n+\tif ((rv = nni_ipc_dialer_init(&d->dialer)) != 0) {\n \t\tipctran_dialer_fini(d);\n \t\treturn (rv);\n \t}\n \n-\td->proto = nni_sock_proto_id(sock);\n-\n \t*dp = d;\n \treturn (0);\n }\n \n static void\n-ipctran_dialer_cb(void *arg)\n+ipctran_pipe_conn_cancel(nni_aio *aio, int rv)\n {\n-\tipctran_dialer *d = arg;\n-\tipctran_pipe *  p;\n-\tnni_ipc_conn *  conn;\n-\tnni_aio *       aio;\n-\tint             rv;\n-\n-\tnni_mtx_lock(&d->mtx);\n-\taio = d->user_aio;\n-\trv  = nni_aio_result(d->aio);\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(d->aio, 0);\n-\t\t\tnni_ipc_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\td->user_aio = NULL;\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n+\tipctran_pipe *p = nni_aio_get_prov_data(aio);\n \n-\td->user_aio = NULL;\n-\tconn        = nni_aio_get_output(d->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\tif ((rv = ipctran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_ipc_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif (p->useraio != aio) {\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \n-\tp->proto  = d->proto;\n-\tp->rcvmax = d->rcvmax;\n-\tp->sa     = d->sa;\n-\tnni_mtx_unlock(&d->mtx);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-ipctran_dialer_cancel(nni_aio *aio, int rv)\n-{\n-\tipctran_dialer *d = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&d->mtx);\n-\tif (d->user_aio != aio) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tnni_mtx_unlock(&d->mtx);\n+\t// Close the underlying AIOs.  This will abort the operation.\n+\t// The pipe is removed from pending list at completion callback.\n+\tp->useraio = NULL;\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n \n-\tnni_aio_abort(d->aio, rv);\n \tnni_aio_finish_error(aio, rv);\n }\n \n@@ -751,47 +780,48 @@ static void\n ipctran_dialer_connect(void *arg, nni_aio *aio)\n {\n \tipctran_dialer *d = arg;\n+\tipctran_pipe *  p = NULL;\n \tint             rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&d->mtx);\n-\tNNI_ASSERT(d->user_aio == NULL);\n \n-\tif ((rv = nni_aio_schedule(aio, ipctran_dialer_cancel, d)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n+\tnni_mtx_lock(&d->ep.mtx);\n+\tif (((rv = ipctran_pipe_init(&p, &d->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, ipctran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&d->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\tipctran_pipe_reap(p);\n \t\treturn;\n \t}\n-\td->user_aio = aio;\n+\tp->useraio = aio;\n \n-\tnni_ipc_dialer_dial(d->dialer, &d->sa, d->aio);\n-\tnni_mtx_unlock(&d->mtx);\n+\tnni_ipc_dialer_dial(d->dialer, &p->sa, p->connaio);\n+\tnni_mtx_unlock(&d->ep.mtx);\n }\n \n static int\n-ipctran_dialer_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n+ipctran_ep_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\tipctran_dialer *d = arg;\n-\tint             rv;\n-\tnni_mtx_lock(&d->mtx);\n-\trv = nni_copyout_size(d->rcvmax, v, szp, t);\n-\tnni_mtx_unlock(&d->mtx);\n+\tipctran_ep *ep = arg;\n+\tint         rv;\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_size(ep->rcvmax, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n \treturn (rv);\n }\n \n static int\n-ipctran_dialer_set_recvmaxsz(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n+ipctran_ep_set_recvmaxsz(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\tipctran_dialer *d = arg;\n-\tsize_t          val;\n-\tint             rv;\n+\tipctran_ep *ep = arg;\n+\tsize_t      val;\n+\tint         rv;\n \tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->rcvmax = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->rcvmax = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n@@ -801,12 +831,19 @@ ipctran_listener_fini(void *arg)\n {\n \tipctran_listener *l = arg;\n \n-\tnni_aio_stop(l->aio);\n+\tnni_mtx_lock(&l->ep.mtx);\n \tif (l->listener != NULL) {\n \t\tnni_ipc_listener_fini(l->listener);\n+\t\tl->listener = NULL;\n+\t}\n+\tl->ep.fini = true;\n+\tif (!nni_list_empty(&l->ep.pipes)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n+\t\treturn;\n \t}\n-\tnni_aio_fini(l->aio);\n-\tnni_mtx_fini(&l->mtx);\n+\tnni_mtx_unlock(&l->ep.mtx);\n+\n+\tnni_mtx_fini(&l->ep.mtx);\n \tNNI_FREE_STRUCT(l);\n }\n \n@@ -820,24 +857,24 @@ ipctran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \tif ((l = NNI_ALLOC_STRUCT(l)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&l->mtx);\n+\tnni_mtx_init(&l->ep.mtx);\n+\tNNI_LIST_INIT(&l->ep.pipes, ipctran_pipe, node);\n \n-\tsz                    = sizeof(l->sa.s_ipc.sa_path);\n-\tl->sa.s_ipc.sa_family = NNG_AF_IPC;\n+\tsz                       = sizeof(l->ep.sa.s_ipc.sa_path);\n+\tl->ep.sa.s_ipc.sa_family = NNG_AF_IPC;\n+\tl->ep.proto              = nni_sock_proto_id(sock);\n+\tl->ep.dtor               = ipctran_listener_fini;\n \n-\tif (nni_strlcpy(l->sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n+\tif (nni_strlcpy(l->ep.sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n \t\tipctran_listener_fini(l);\n \t\treturn (NNG_EADDRINVAL);\n \t}\n \n-\tif (((rv = nni_ipc_listener_init(&l->listener)) != 0) ||\n-\t    ((rv = nni_aio_init(&l->aio, ipctran_listener_cb, l)) != 0)) {\n+\tif ((rv = nni_ipc_listener_init(&l->listener)) != 0) {\n \t\tipctran_listener_fini(l);\n \t\treturn (rv);\n \t}\n \n-\tl->proto = nni_sock_proto_id(sock);\n-\n \t*lp = l;\n \treturn (0);\n }\n@@ -847,7 +884,7 @@ ipctran_listener_close(void *arg)\n {\n \tipctran_listener *l = arg;\n \n-\tnni_aio_close(l->aio);\n+\tipctran_ep_close(&l->ep);\n \tnni_ipc_listener_close(l->listener);\n }\n \n@@ -857,128 +894,35 @@ ipctran_listener_bind(void *arg)\n \tipctran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_ipc_listener_listen(l->listener, &l->sa);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\trv = nni_ipc_listener_listen(l->listener, &l->ep.sa);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \treturn (rv);\n }\n \n-static void\n-ipctran_listener_cb(void *arg)\n-{\n-\tipctran_listener *l = arg;\n-\tnni_aio *         aio;\n-\tint               rv;\n-\tipctran_pipe *    p = NULL;\n-\tnni_ipc_conn *    conn;\n-\n-\tnni_mtx_lock(&l->mtx);\n-\trv          = nni_aio_result(l->aio);\n-\taio         = l->user_aio;\n-\tl->user_aio = NULL;\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(l->aio, 0);\n-\t\t\tnni_ipc_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tconn = nni_aio_get_output(l->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\n-\t// Attempt to allocate the parent pipe.  If this fails we'll\n-\t// drop the connection (ENOMEM probably).\n-\tif ((rv = ipctran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_ipc_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tp->proto  = l->proto;\n-\tp->rcvmax = l->rcvmax;\n-\tp->sa     = l->sa;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-ipctran_listener_cancel(nni_aio *aio, int rv)\n-{\n-\tipctran_listener *l = nni_aio_get_prov_data(aio);\n-\n-\tNNI_ASSERT(rv != 0);\n-\tnni_mtx_lock(&l->mtx);\n-\tif (l->user_aio != aio) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\treturn;\n-\t}\n-\tl->user_aio = NULL;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\tnni_aio_abort(l->aio, rv);\n-\tnni_aio_finish_error(aio, rv);\n-}\n-\n static void\n ipctran_listener_accept(void *arg, nni_aio *aio)\n {\n \tipctran_listener *l = arg;\n+\tipctran_pipe *    p;\n \tint               rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&l->mtx);\n-\tNNI_ASSERT(l->user_aio == NULL);\n \n-\tif ((rv = nni_aio_schedule(aio, ipctran_listener_cancel, l)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\tif (((rv = ipctran_pipe_init(&p, &l->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, ipctran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\tipctran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tl->user_aio = aio;\n-\n-\tnni_ipc_listener_accept(l->listener, l->aio);\n-\tnni_mtx_unlock(&l->mtx);\n-}\n-\n-static int\n-ipctran_listener_set_recvmaxsz(\n-    void *arg, const void *data, size_t sz, nni_opt_type t)\n-{\n-\tipctran_listener *l = arg;\n-\tsize_t            val;\n-\tint               rv;\n-\n-\tif ((rv = nni_copyin_size(&val, data, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->rcvmax = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n+\tp->useraio = aio;\n \n-static int\n-ipctran_listener_get_recvmaxsz(\n-    void *arg, void *data, size_t *szp, nni_opt_type t)\n-{\n-\tipctran_listener *l = arg;\n-\tint               rv;\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_size(l->rcvmax, data, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n+\tnni_ipc_listener_accept(l->listener, p->connaio);\n+\tnni_mtx_unlock(&l->ep.mtx);\n }\n \n static int\n@@ -987,9 +931,9 @@ ipctran_listener_get_locaddr(void *arg, void *buf, size_t *szp, nni_opt_type t)\n \tipctran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_sockaddr(&l->sa, buf, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\trv = nni_copyout_sockaddr(&l->ep.sa, buf, szp, t);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \treturn (rv);\n }\n \n@@ -1010,9 +954,9 @@ ipctran_listener_set_perms(\n \t// Probably we could further limit this -- most systems don't have\n \t// meaningful chmod beyond the lower 9 bits.\n \tif ((rv = nni_copyin_int(&val, data, sz, 0, 0x7FFFFFFF, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n+\t\tnni_mtx_lock(&l->ep.mtx);\n \t\trv = nni_ipc_listener_set_permissions(l->listener, val);\n-\t\tnni_mtx_unlock(&l->mtx);\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t}\n \treturn (rv);\n }\n@@ -1032,10 +976,10 @@ ipctran_listener_set_sec_desc(\n \tint               rv;\n \n \tif ((rv = nni_copyin_ptr(&ptr, data, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n+\t\tnni_mtx_lock(&l->ep.mtx);\n \t\trv =\n \t\t    nni_ipc_listener_set_security_descriptor(l->listener, ptr);\n-\t\tnni_mtx_unlock(&l->mtx);\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t}\n \treturn (rv);\n }\n@@ -1085,7 +1029,6 @@ static nni_tran_option ipctran_pipe_options[] = {\n \n static nni_tran_pipe_ops ipctran_pipe_ops = {\n \t.p_fini    = ipctran_pipe_fini,\n-\t.p_start   = ipctran_pipe_start,\n \t.p_stop    = ipctran_pipe_stop,\n \t.p_send    = ipctran_pipe_send,\n \t.p_recv    = ipctran_pipe_recv,\n@@ -1098,8 +1041,8 @@ static nni_tran_option ipctran_dialer_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = ipctran_dialer_get_recvmaxsz,\n-\t    .o_set  = ipctran_dialer_set_recvmaxsz,\n+\t    .o_get  = ipctran_ep_get_recvmaxsz,\n+\t    .o_set  = ipctran_ep_set_recvmaxsz,\n \t    .o_chk  = ipctran_check_recvmaxsz,\n \t},\n \t// terminate list\n@@ -1112,8 +1055,8 @@ static nni_tran_option ipctran_listener_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = ipctran_listener_get_recvmaxsz,\n-\t    .o_set  = ipctran_listener_set_recvmaxsz,\n+\t    .o_get  = ipctran_ep_get_recvmaxsz,\n+\t    .o_set  = ipctran_ep_set_recvmaxsz,\n \t    .o_chk  = ipctran_check_recvmaxsz,\n \t},\n \t{\ndiff --git a/src/transport/tcp/tcp.c b/src/transport/tcp/tcp.c\nindex 0d47529e6..6cf699721 100644\n--- a/src/transport/tcp/tcp.c\n+++ b/src/transport/tcp/tcp.c\n@@ -20,19 +20,26 @@\n typedef struct tcptran_pipe     tcptran_pipe;\n typedef struct tcptran_dialer   tcptran_dialer;\n typedef struct tcptran_listener tcptran_listener;\n+typedef struct tcptran_ep       tcptran_ep;\n \n // tcp_pipe is one end of a TCP connection.\n struct tcptran_pipe {\n-\tnni_tcp_conn *conn;\n-\tuint16_t      peer;\n-\tuint16_t      proto;\n-\tsize_t        rcvmax;\n-\tbool          nodelay;\n-\tbool          keepalive;\n+\tnni_tcp_conn *  conn;\n+\tuint16_t        peer;\n+\tuint16_t        proto;\n+\tsize_t          rcvmax;\n+\tnni_sockaddr    sa;\n+\tbool            nodelay;\n+\tbool            keepalive;\n+\tbool            closed;\n+\tnni_atomic_flag reaped;\n+\tnni_list_node   node;\n+\tnni_reap_item   reap;\n+\ttcptran_ep *    ep;\n \n \tnni_list recvq;\n \tnni_list sendq;\n-\tnni_aio *user_negaio;\n+\tnni_aio *useraio;\n \n \tuint8_t  txlen[sizeof(uint64_t)];\n \tuint8_t  rxlen[sizeof(uint64_t)];\n@@ -42,47 +49,48 @@ struct tcptran_pipe {\n \tsize_t   wantrxhead;\n \tnni_aio *txaio;\n \tnni_aio *rxaio;\n-\tnni_aio *negaio;\n+\tnni_aio *negoaio;\n+\tnni_aio *connaio;\n+\tnni_aio *rslvaio;\n \tnni_msg *rxmsg;\n \tnni_mtx  mtx;\n };\n \n+struct tcptran_ep {\n+\tnni_mtx       mtx;\n+\tnni_list      pipes;\n+\tnni_url *     url;\n+\tsize_t        rcvmax;\n+\tbool          nodelay;\n+\tbool          keepalive;\n+\tbool          fini;\n+\tuint16_t      proto;\n+\tnni_cb        dtor;\n+\tnni_reap_item reap;\n+};\n+\n struct tcptran_dialer {\n+\ttcptran_ep      ep;\n \tnni_tcp_dialer *dialer;\n-\tuint16_t        proto;\n-\tuint16_t        af;\n-\tsize_t          rcvmax;\n-\tbool            nodelay;\n-\tbool            keepalive;\n-\tbool            resolving;\n \tnng_sockaddr    sa;\n-\tnni_aio *       aio;\n-\tnni_aio *       user_aio;\n-\tnni_url *       url;\n-\tnni_mtx         mtx;\n+\tuint16_t        af;\n };\n \n struct tcptran_listener {\n+\ttcptran_ep        ep;\n \tnni_tcp_listener *listener;\n-\tuint16_t          proto;\n-\tsize_t            rcvmax;\n-\tbool              nodelay;\n-\tbool              keepalive;\n-\tnni_aio *         aio;\n-\tnni_aio *         user_aio;\n-\tnni_url *         url;\n \tnng_sockaddr      sa;\n \tnng_sockaddr      bsa; // bound addr\n-\tnni_mtx           mtx;\n };\n \n static void tcptran_pipe_send_start(tcptran_pipe *);\n static void tcptran_pipe_recv_start(tcptran_pipe *);\n static void tcptran_pipe_send_cb(void *);\n static void tcptran_pipe_recv_cb(void *);\n+static void tcptran_pipe_rslv_cb(void *);\n static void tcptran_pipe_nego_cb(void *);\n-static void tcptran_dialer_cb(void *arg);\n-static void tcptran_listener_cb(void *arg);\n+static void tcptran_pipe_conn_cb(void *);\n+static void tcptran_pipe_reap(tcptran_pipe *);\n \n static int\n tcptran_init(void)\n@@ -100,9 +108,15 @@ tcptran_pipe_close(void *arg)\n {\n \ttcptran_pipe *p = arg;\n \n+\tnni_mtx_lock(&p->mtx);\n+\tp->closed = true;\n+\tnni_mtx_unlock(&p->mtx);\n+\n \tnni_aio_close(p->rxaio);\n \tnni_aio_close(p->txaio);\n-\tnni_aio_close(p->negaio);\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n \n \tnni_tcp_conn_close(p->conn);\n }\n@@ -114,17 +128,34 @@ tcptran_pipe_stop(void *arg)\n \n \tnni_aio_stop(p->rxaio);\n \tnni_aio_stop(p->txaio);\n-\tnni_aio_stop(p->negaio);\n+\tnni_aio_stop(p->negoaio);\n+\tnni_aio_stop(p->connaio);\n+\tnni_aio_stop(p->rslvaio);\n }\n \n static void\n tcptran_pipe_fini(void *arg)\n {\n \ttcptran_pipe *p = arg;\n+\ttcptran_ep *  ep;\n \n+\tif (p == NULL) {\n+\t\treturn;\n+\t}\n+\ttcptran_pipe_stop(p);\n+\tif ((ep = p->ep) != NULL) {\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tnni_list_remove(&ep->pipes, p);\n+\t\tif (ep->fini && nni_list_empty(&ep->pipes)) {\n+\t\t\tnni_reap(&ep->reap, ep->dtor, ep);\n+\t\t}\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t}\n \tnni_aio_fini(p->rxaio);\n \tnni_aio_fini(p->txaio);\n-\tnni_aio_fini(p->negaio);\n+\tnni_aio_fini(p->negoaio);\n+\tnni_aio_fini(p->connaio);\n+\tnni_aio_fini(p->rslvaio);\n \tif (p->conn != NULL) {\n \t\tnni_tcp_conn_fini(p->conn);\n \t}\n@@ -133,8 +164,16 @@ tcptran_pipe_fini(void *arg)\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+tcptran_pipe_reap(tcptran_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n+\t\tnni_reap(&p->reap, tcptran_pipe_fini, p);\n+\t}\n+}\n+\n static int\n-tcptran_pipe_init(tcptran_pipe **pipep, void *conn)\n+tcptran_pipe_init(tcptran_pipe **pipep, tcptran_ep *ep)\n {\n \ttcptran_pipe *p;\n \tint           rv;\n@@ -143,45 +182,108 @@ tcptran_pipe_init(tcptran_pipe **pipep, void *conn)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&p->mtx);\n+\tNNI_LIST_NODE_INIT(&p->node);\n+\tnni_aio_list_init(&p->recvq);\n+\tnni_aio_list_init(&p->sendq);\n+\tnni_atomic_flag_reset(&p->reaped);\n+\n \tif (((rv = nni_aio_init(&p->txaio, tcptran_pipe_send_cb, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->rxaio, tcptran_pipe_recv_cb, p)) != 0) ||\n-\t    ((rv = nni_aio_init(&p->negaio, tcptran_pipe_nego_cb, p)) != 0)) {\n-\t\ttcptran_pipe_fini(p);\n+\t    ((rv = nni_aio_init(&p->rslvaio, tcptran_pipe_rslv_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->connaio, tcptran_pipe_conn_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->negoaio, tcptran_pipe_nego_cb, p)) != 0)) {\n+\t\ttcptran_pipe_reap(p);\n \t\treturn (rv);\n \t}\n-\tnni_aio_list_init(&p->recvq);\n-\tnni_aio_list_init(&p->sendq);\n+\tnni_list_append(&ep->pipes, p);\n+\tp->ep        = ep;\n+\tp->proto     = ep->proto;\n+\tp->rcvmax    = ep->rcvmax;\n+\tp->keepalive = ep->keepalive;\n+\tp->nodelay   = ep->nodelay;\n \n-\tp->conn = conn;\n-\t*pipep  = p;\n+\t*pipep = p;\n \treturn (0);\n }\n \n static void\n-tcptran_pipe_nego_cancel(nni_aio *aio, int rv)\n+tcptran_pipe_rslv_cb(void *arg)\n {\n-\ttcptran_pipe *p = nni_aio_get_prov_data(aio);\n+\ttcptran_pipe *  p = arg;\n+\ttcptran_dialer *d;\n+\tnni_aio *       aio = p->rslvaio;\n+\tint             rv;\n \n-\tnni_mtx_lock(&p->mtx);\n-\tif (p->user_negaio != aio) {\n-\t\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttcptran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tp->user_negaio = NULL;\n-\tnni_mtx_unlock(&p->mtx);\n+\td = (void *) p->ep;\n+\tif (d->dialer != NULL) {\n+\t\tnni_tcp_dialer_dial(d->dialer, &p->sa, p->connaio);\n+\t}\n+\tnni_mtx_unlock(&p->ep->mtx);\n+}\n \n-\tnni_aio_abort(p->negaio, rv);\n-\tnni_aio_finish_error(aio, rv);\n+static void\n+tcptran_pipe_conn_cb(void *arg)\n+{\n+\ttcptran_pipe *p   = arg;\n+\tnni_aio *     aio = p->connaio;\n+\tnni_iov       iov;\n+\tint           rv;\n+\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttcptran_pipe_reap(p);\n+\t\treturn;\n+\t}\n+\n+\tp->conn = nni_aio_get_output(aio, 0);\n+\n+\t(void) nni_tcp_conn_set_nodelay(p->conn, p->nodelay);\n+\t(void) nni_tcp_conn_set_keepalive(p->conn, p->keepalive);\n+\n+\tp->txlen[0] = 0;\n+\tp->txlen[1] = 'S';\n+\tp->txlen[2] = 'P';\n+\tp->txlen[3] = 0;\n+\tNNI_PUT16(&p->txlen[4], p->proto);\n+\tNNI_PUT16(&p->txlen[6], 0);\n+\n+\tp->gotrxhead  = 0;\n+\tp->gottxhead  = 0;\n+\tp->wantrxhead = 8;\n+\tp->wanttxhead = 8;\n+\tiov.iov_len   = 8;\n+\tiov.iov_buf   = &p->txlen[0];\n+\tnni_aio_set_iov(p->negoaio, 1, &iov);\n+\tnni_tcp_conn_send(p->conn, p->negoaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n }\n \n static void\n tcptran_pipe_nego_cb(void *arg)\n {\n \ttcptran_pipe *p   = arg;\n-\tnni_aio *     aio = p->negaio;\n+\tnni_aio *     aio = p->negoaio;\n+\tnni_aio *     uaio;\n \tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n \tif ((rv = nni_aio_result(aio)) != 0) {\n \t\tgoto done;\n \t}\n@@ -200,7 +302,7 @@ tcptran_pipe_nego_cb(void *arg)\n \t\t// send it down...\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_tcp_conn_send(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \tif (p->gotrxhead < p->wantrxhead) {\n@@ -209,7 +311,7 @@ tcptran_pipe_nego_cb(void *arg)\n \t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_tcp_conn_recv(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \t// We have both sent and received the headers.  Lets check the\n@@ -224,11 +326,18 @@ tcptran_pipe_nego_cb(void *arg)\n \tNNI_GET16(&p->rxlen[4], p->peer);\n \n done:\n-\tif ((aio = p->user_negaio) != NULL) {\n-\t\tp->user_negaio = NULL;\n-\t\tnni_aio_finish(aio, rv, 0);\n+\tif ((uaio = p->useraio) != NULL) {\n+\t\tp->useraio = NULL;\n+\t\tif (rv == 0) {\n+\t\t\tnni_aio_set_output(uaio, 0, p);\n+\t\t\tnni_aio_finish(uaio, 0, 0);\n+\t\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\t\treturn;\n+\t\t}\n+\t\tnni_aio_finish_error(uaio, rv);\n \t}\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&p->ep->mtx);\n+\ttcptran_pipe_reap(p);\n }\n \n static void\n@@ -242,17 +351,19 @@ tcptran_pipe_send_cb(void *arg)\n \tnni_aio *     txaio = p->txaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->sendq);\n+\trv = p->closed ? NNG_ECLOSED : nni_aio_result(txaio);\n \n-\tif ((rv = nni_aio_result(txaio)) != 0) {\n+\tif (rv != 0) {\n \t\t// Intentionally we do not queue up another transfer.\n \t\t// There's an excellent chance that the pipe is no longer\n \t\t// usable, with a partial transfer.\n \t\t// The protocol should see this error, and close the\n \t\t// pipe itself, we hope.\n-\t\tnni_aio_list_remove(aio);\n+\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, rv);\n+\t\t}\n \t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n \t\treturn;\n \t}\n \n@@ -264,6 +375,7 @@ tcptran_pipe_send_cb(void *arg)\n \t\treturn;\n \t}\n \n+\taio = nni_list_first(&p->sendq);\n \tnni_aio_list_remove(aio);\n \ttcptran_pipe_send_start(p);\n \n@@ -287,11 +399,14 @@ tcptran_pipe_recv_cb(void *arg)\n \tnni_aio *     rxaio = p->rxaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->recvq);\n \n \tif ((rv = nni_aio_result(rxaio)) != 0) {\n \t\tgoto recv_error;\n \t}\n+\tif (p->closed) {\n+\t\trv = NNG_ECLOSED;\n+\t\tgoto recv_error;\n+\t}\n \n \tn = nni_aio_count(rxaio);\n \tnni_aio_iov_advance(rxaio, n);\n@@ -335,6 +450,7 @@ tcptran_pipe_recv_cb(void *arg)\n \t}\n \n \t// We read a message completely.  Let the user know the good news.\n+\taio = nni_list_first(&p->recvq);\n \tnni_aio_list_remove(aio);\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n@@ -348,7 +464,10 @@ tcptran_pipe_recv_cb(void *arg)\n \treturn;\n \n recv_error:\n-\tnni_aio_list_remove(aio);\n+\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n+\t\tnni_aio_list_remove(aio);\n+\t\tnni_aio_finish_error(aio, rv);\n+\t}\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n \t// Intentionally, we do not queue up another receive.\n@@ -356,7 +475,6 @@ tcptran_pipe_recv_cb(void *arg)\n \tnni_mtx_unlock(&p->mtx);\n \n \tnni_msg_free(msg);\n-\tnni_aio_finish_error(aio, rv);\n }\n \n static void\n@@ -432,6 +550,11 @@ tcptran_pipe_send(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tcptran_pipe_send_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -474,7 +597,7 @@ tcptran_pipe_recv_start(tcptran_pipe *p)\n \tnni_iov  iov;\n \tNNI_ASSERT(p->rxmsg == NULL);\n \n-\t// Schedule a read of the IPC header.\n+\t// Schedule a read of the header.\n \trxaio       = p->rxaio;\n \tiov.iov_buf = p->rxlen;\n \tiov.iov_len = sizeof(p->rxlen);\n@@ -493,6 +616,11 @@ tcptran_pipe_recv(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tcptran_pipe_recv_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -557,54 +685,36 @@ tcptran_pipe_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n }\n \n static void\n-tcptran_pipe_start(void *arg, nni_aio *aio)\n+tcptran_dialer_fini(void *arg)\n {\n-\ttcptran_pipe *p = arg;\n-\tnni_aio *     negaio;\n-\tnni_iov       iov;\n-\tint           rv;\n+\ttcptran_dialer *d = arg;\n \n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n+\tnni_mtx_lock(&d->ep.mtx);\n+\tif (d->dialer != NULL) {\n+\t\tnni_tcp_dialer_fini(d->dialer);\n+\t\td->dialer = NULL;\n \t}\n-\tnni_mtx_lock(&p->mtx);\n-\tif ((rv = nni_aio_schedule(aio, tcptran_pipe_nego_cancel, p)) != 0) {\n-\t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n+\td->ep.fini = true;\n+\tif (!nni_list_empty(&d->ep.pipes)) {\n+\t\tnni_mtx_unlock(&d->ep.mtx);\n \t\treturn;\n \t}\n-\tp->txlen[0] = 0;\n-\tp->txlen[1] = 'S';\n-\tp->txlen[2] = 'P';\n-\tp->txlen[3] = 0;\n-\tNNI_PUT16(&p->txlen[4], p->proto);\n-\tNNI_PUT16(&p->txlen[6], 0);\n-\n-\tp->user_negaio = aio;\n-\tp->gotrxhead   = 0;\n-\tp->gottxhead   = 0;\n-\tp->wantrxhead  = 8;\n-\tp->wanttxhead  = 8;\n-\tnegaio         = p->negaio;\n-\tiov.iov_len    = 8;\n-\tiov.iov_buf    = &p->txlen[0];\n-\tnni_aio_set_iov(negaio, 1, &iov);\n-\tnni_tcp_conn_send(p->conn, negaio);\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&d->ep.mtx);\n+\tnni_mtx_fini(&d->ep.mtx);\n+\tNNI_FREE_STRUCT(d);\n }\n \n static void\n-tcptran_dialer_fini(void *arg)\n+tcptran_ep_close(tcptran_ep *ep)\n {\n-\ttcptran_dialer *d = arg;\n-\n-\tnni_aio_stop(d->aio);\n-\tif (d->dialer != NULL) {\n-\t\tnni_tcp_dialer_fini(d->dialer);\n+\ttcptran_pipe *p;\n+\tnni_mtx_lock(&ep->mtx);\n+\tNNI_LIST_FOREACH (&ep->pipes, p) {\n+\t\tnni_aio_close(p->negoaio);\n+\t\tnni_aio_close(p->connaio);\n+\t\tnni_aio_close(p->rslvaio);\n \t}\n-\tnni_aio_fini(d->aio);\n-\tnni_mtx_fini(&d->mtx);\n-\tNNI_FREE_STRUCT(d);\n+\tnni_mtx_unlock(&ep->mtx);\n }\n \n static void\n@@ -612,7 +722,7 @@ tcptran_dialer_close(void *arg)\n {\n \ttcptran_dialer *d = arg;\n \n-\tnni_aio_close(d->aio);\n+\ttcptran_ep_close(&d->ep);\n \tnni_tcp_dialer_close(d->dialer);\n }\n \n@@ -646,127 +756,72 @@ tcptran_dialer_init(void **dp, nni_url *url, nni_sock *sock)\n \tif ((d = NNI_ALLOC_STRUCT(d)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&d->mtx);\n+\tnni_mtx_init(&d->ep.mtx);\n+\tNNI_LIST_INIT(&d->ep.pipes, tcptran_pipe, node);\n+\td->ep.dtor      = tcptran_dialer_fini;\n+\td->ep.nodelay   = true;\n+\td->ep.keepalive = false;\n+\td->ep.proto     = nni_sock_proto_id(sock);\n+\td->ep.url       = url;\n+\td->af           = af;\n \n-\tif (((rv = nni_tcp_dialer_init(&d->dialer)) != 0) ||\n-\t    ((rv = nni_aio_init(&d->aio, tcptran_dialer_cb, d)) != 0)) {\n+\tif ((rv = nni_tcp_dialer_init(&d->dialer)) != 0) {\n \t\ttcptran_dialer_fini(d);\n \t\treturn (rv);\n \t}\n \n-\td->url       = url;\n-\td->proto     = nni_sock_proto_id(sock);\n-\td->nodelay   = true;\n-\td->keepalive = false;\n-\td->af        = af;\n-\n \t*dp = d;\n \treturn (0);\n }\n \n static void\n-tcptran_dialer_cb(void *arg)\n+tcptran_pipe_conn_cancel(nni_aio *aio, int rv)\n {\n-\ttcptran_dialer *d = arg;\n-\ttcptran_pipe *  p;\n-\tnni_tcp_conn *  conn;\n-\tnni_aio *       aio;\n-\tint             rv;\n-\n-\tnni_mtx_lock(&d->mtx);\n-\taio = d->user_aio;\n-\trv  = nni_aio_result(d->aio);\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tif ((rv == 0) && !d->resolving) {\n-\t\t\tconn = nni_aio_get_output(d->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\td->user_aio = NULL;\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tif (d->resolving) {\n-\t\t// Name resolution complete.  Now go to next step.\n-\t\td->resolving = false;\n-\t\tnni_tcp_dialer_dial(d->dialer, &d->sa, d->aio);\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\treturn;\n-\t}\n+\ttcptran_pipe *p = nni_aio_get_prov_data(aio);\n \n-\td->user_aio = NULL;\n-\tconn        = nni_aio_get_output(d->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\tif ((rv = tcptran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif (p->useraio != aio) {\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \n-\tp->proto     = d->proto;\n-\tp->rcvmax    = d->rcvmax;\n-\tp->nodelay   = d->nodelay;\n-\tp->keepalive = d->keepalive;\n-\tnni_mtx_unlock(&d->mtx);\n+\t// Close the underlying AIOs.  This will abort the operation.\n+\t// The pipe is removed from pending list at completion callback.\n+\tp->useraio = NULL;\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n \n-\t(void) nni_tcp_conn_set_nodelay(conn, p->nodelay);\n-\t(void) nni_tcp_conn_set_keepalive(conn, p->keepalive);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-tcptran_dialer_cancel(nni_aio *aio, int rv)\n-{\n-\ttcptran_dialer *d = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&d->mtx);\n-\tif (d->user_aio != aio) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tnni_mtx_unlock(&d->mtx);\n-\n-\tnni_aio_abort(d->aio, rv);\n \tnni_aio_finish_error(aio, rv);\n }\n \n static void\n tcptran_dialer_connect(void *arg, nni_aio *aio)\n {\n-\ttcptran_dialer *d = arg;\n+\ttcptran_dialer *d  = arg;\n+\ttcptran_ep *    ep = &d->ep;\n+\ttcptran_pipe *  p  = NULL;\n \tint             rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&d->mtx);\n-\tNNI_ASSERT(d->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tcptran_dialer_cancel, d)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n+\tnni_mtx_lock(&ep->mtx);\n+\tif (((rv = tcptran_pipe_init(&p, ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tcptran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttcptran_pipe_reap(p);\n \t\treturn;\n \t}\n-\td->user_aio = aio;\n-\n-\td->resolving = true;\n+\tp->useraio = aio;\n \n-\t// Start the name resolution.  Callback will see resolving, and then\n-\t// switch to doing actual connect.\n-\tnni_aio_set_input(d->aio, 0, &d->sa);\n-\tnni_tcp_resolv(d->url->u_hostname, d->url->u_port, d->af, 0, d->aio);\n-\tnni_mtx_unlock(&d->mtx);\n+\t// Start the name resolution as first step.\n+\tnni_aio_set_input(p->rslvaio, 0, &p->sa);\n+\tnni_tcp_resolv(\n+\t    ep->url->u_hostname, ep->url->u_port, d->af, 0, p->rslvaio);\n+\tnni_mtx_unlock(&ep->mtx);\n }\n \n static int\n@@ -774,79 +829,81 @@ tcptran_dialer_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n \ttcptran_dialer *d = arg;\n \n-\treturn (nni_copyout_str(d->url->u_rawurl, v, szp, t));\n+\treturn (nni_copyout_str(d->ep.url->u_rawurl, v, szp, t));\n }\n \n static int\n-tcptran_dialer_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n+tcptran_ep_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tint         rv;\n \n-\tnni_mtx_lock(&d->mtx);\n-\trv = nni_copyout_size(d->rcvmax, v, szp, t);\n-\tnni_mtx_unlock(&d->mtx);\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_size(ep->rcvmax, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_set_recvmaxsz(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n+tcptran_ep_set_recvmaxsz(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tsize_t          val;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tsize_t      val;\n+\tint         rv;\n \tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->rcvmax = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->rcvmax = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n+tcptran_ep_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tint             rv;\n-\tnni_mtx_lock(&d->mtx);\n-\trv = nni_copyout_bool(d->nodelay, v, szp, t);\n-\tnni_mtx_unlock(&d->mtx);\n+\ttcptran_ep *ep = arg;\n+\tint         rv;\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_bool(ep->nodelay, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_set_nodelay(void *arg, const void *v, size_t sz, nni_opt_type t)\n+tcptran_ep_set_nodelay(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tbool            val;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tbool        val;\n+\tint         rv;\n \tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->nodelay = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->nodelay = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_get_keepalive(void *arg, void *v, size_t *szp, nni_opt_type t)\n+tcptran_ep_get_keepalive(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\treturn (nni_copyout_bool(d->keepalive, v, szp, t));\n+\ttcptran_ep *ep = arg;\n+\tint         rv;\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_bool(ep->keepalive, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n+\treturn (rv);\n }\n \n static int\n-tcptran_dialer_set_keepalive(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n+tcptran_ep_set_keepalive(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tbool            val;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tbool        val;\n+\tint         rv;\n \tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->keepalive = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->keepalive = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n@@ -856,12 +913,18 @@ tcptran_listener_fini(void *arg)\n {\n \ttcptran_listener *l = arg;\n \n-\tnni_aio_stop(l->aio);\n+\tnni_mtx_lock(&l->ep.mtx);\n \tif (l->listener != NULL) {\n \t\tnni_tcp_listener_fini(l->listener);\n+\t\tl->listener = NULL;\n \t}\n-\tnni_aio_fini(l->aio);\n-\tnni_mtx_fini(&l->mtx);\n+\tl->ep.fini = true;\n+\tif (!nni_list_empty(&l->ep.pipes)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n+\t\treturn;\n+\t}\n+\tnni_mtx_unlock(&l->ep.mtx);\n+\tnni_mtx_fini(&l->ep.mtx);\n \tNNI_FREE_STRUCT(l);\n }\n \n@@ -896,8 +959,13 @@ tcptran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \tif ((l = NNI_ALLOC_STRUCT(l)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&l->mtx);\n-\tl->url = url;\n+\tnni_mtx_init(&l->ep.mtx);\n+\tNNI_LIST_INIT(&l->ep.pipes, tcptran_pipe, node);\n+\tl->ep.dtor      = tcptran_listener_fini;\n+\tl->ep.url       = url;\n+\tl->ep.proto     = nni_sock_proto_id(sock);\n+\tl->ep.nodelay   = true;\n+\tl->ep.keepalive = false;\n \n \tif (strlen(url->u_hostname) == 0) {\n \t\thost = NULL;\n@@ -923,21 +991,12 @@ tcptran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \trv = nni_aio_result(aio);\n \tnni_aio_fini(aio);\n \n-\tif (rv != 0) {\n+\tif ((rv != 0) || ((rv = nni_tcp_listener_init(&l->listener)) != 0)) {\n \t\ttcptran_listener_fini(l);\n \t\treturn (rv);\n \t}\n \n-\tif (((rv = nni_tcp_listener_init(&l->listener)) != 0) ||\n-\t    ((rv = nni_aio_init(&l->aio, tcptran_listener_cb, l)) != 0)) {\n-\t\ttcptran_listener_fini(l);\n-\t\treturn (rv);\n-\t}\n-\n-\tl->proto     = nni_sock_proto_id(sock);\n-\tl->nodelay   = true;\n-\tl->keepalive = false;\n-\tl->bsa       = l->sa;\n+\tl->bsa = l->sa;\n \n \t*lp = l;\n \treturn (0);\n@@ -948,7 +1007,7 @@ tcptran_listener_close(void *arg)\n {\n \ttcptran_listener *l = arg;\n \n-\tnni_aio_close(l->aio);\n+\ttcptran_ep_close(&l->ep);\n \tnni_tcp_listener_close(l->listener);\n }\n \n@@ -958,171 +1017,36 @@ tcptran_listener_bind(void *arg)\n \ttcptran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n \tl->bsa = l->sa;\n \trv     = nni_tcp_listener_listen(l->listener, &l->bsa);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \n \treturn (rv);\n }\n \n-static void\n-tcptran_listener_cb(void *arg)\n-{\n-\ttcptran_listener *l = arg;\n-\tnni_aio *         aio;\n-\tint               rv;\n-\ttcptran_pipe *    p = NULL;\n-\tnni_tcp_conn *    conn;\n-\n-\tnni_mtx_lock(&l->mtx);\n-\trv          = nni_aio_result(l->aio);\n-\taio         = l->user_aio;\n-\tl->user_aio = NULL;\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(l->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tconn = nni_aio_get_output(l->aio, 0);\n-\n-\tNNI_ASSERT(conn != NULL);\n-\tif ((rv = tcptran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tp->proto     = l->proto;\n-\tp->rcvmax    = l->rcvmax;\n-\tp->nodelay   = l->nodelay;\n-\tp->keepalive = l->keepalive;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\t(void) nni_tcp_conn_set_nodelay(conn, p->nodelay);\n-\t(void) nni_tcp_conn_set_keepalive(conn, p->keepalive);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-tcptran_listener_cancel(nni_aio *aio, int rv)\n-{\n-\ttcptran_listener *l = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&l->mtx);\n-\tif (l->user_aio != aio) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\treturn;\n-\t}\n-\tl->user_aio = NULL;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\tnni_aio_abort(l->aio, rv);\n-\tnni_aio_finish_error(aio, rv);\n-}\n-\n static void\n tcptran_listener_accept(void *arg, nni_aio *aio)\n {\n \ttcptran_listener *l = arg;\n+\ttcptran_pipe *    p = NULL;\n \tint               rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&l->mtx);\n-\tNNI_ASSERT(l->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tcptran_listener_cancel, l)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\tif (((rv = tcptran_pipe_init(&p, &l->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tcptran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttcptran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tl->user_aio = aio;\n-\n-\tnni_tcp_listener_accept(l->listener, l->aio);\n-\tnni_mtx_unlock(&l->mtx);\n-}\n-\n-static int\n-tcptran_listener_set_nodelay(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tbool              val;\n-\tint               rv;\n-\tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->nodelay = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n-\n-static int\n-tcptran_listener_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tint               rv;\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_bool(l->nodelay, v, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n-}\n-\n-static int\n-tcptran_listener_set_recvmaxsz(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tsize_t            val;\n-\tint               rv;\n-\tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->rcvmax = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n+\tp->useraio = aio;\n \n-static int\n-tcptran_listener_set_keepalive(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tbool              val;\n-\tint               rv;\n-\tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->keepalive = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n-\n-static int\n-tcptran_listener_get_keepalive(void *arg, void *v, size_t *szp, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tint               rv;\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_bool(l->keepalive, v, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n+\tnni_tcp_listener_accept(l->listener, p->connaio);\n+\tnni_mtx_unlock(&l->ep.mtx);\n }\n \n static int\n@@ -1138,27 +1062,15 @@ tcptran_listener_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n \treturn (nni_copyout_str(ustr, v, szp, t));\n }\n \n-static int\n-tcptran_listener_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tint               rv;\n-\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_size(l->rcvmax, v, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n-}\n-\n static int\n tcptran_listener_get_locaddr(void *arg, void *buf, size_t *szp, nni_opt_type t)\n {\n \ttcptran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n \trv = nni_copyout_sockaddr(&l->bsa, buf, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \treturn (rv);\n }\n \n@@ -1203,7 +1115,6 @@ static nni_tran_option tcptran_pipe_options[] = {\n \n static nni_tran_pipe_ops tcptran_pipe_ops = {\n \t.p_fini    = tcptran_pipe_fini,\n-\t.p_start   = tcptran_pipe_start,\n \t.p_stop    = tcptran_pipe_stop,\n \t.p_send    = tcptran_pipe_send,\n \t.p_recv    = tcptran_pipe_recv,\n@@ -1216,8 +1127,8 @@ static nni_tran_option tcptran_dialer_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = tcptran_dialer_get_recvmaxsz,\n-\t    .o_set  = tcptran_dialer_set_recvmaxsz,\n+\t    .o_get  = tcptran_ep_get_recvmaxsz,\n+\t    .o_set  = tcptran_ep_set_recvmaxsz,\n \t    .o_chk  = tcptran_check_recvmaxsz,\n \t},\n \t{\n@@ -1228,15 +1139,15 @@ static nni_tran_option tcptran_dialer_options[] = {\n \t{\n \t    .o_name = NNG_OPT_TCP_NODELAY,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_dialer_get_nodelay,\n-\t    .o_set  = tcptran_dialer_set_nodelay,\n+\t    .o_get  = tcptran_ep_get_nodelay,\n+\t    .o_set  = tcptran_ep_set_nodelay,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t{\n \t    .o_name = NNG_OPT_TCP_KEEPALIVE,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_dialer_get_keepalive,\n-\t    .o_set  = tcptran_dialer_set_keepalive,\n+\t    .o_get  = tcptran_ep_get_keepalive,\n+\t    .o_set  = tcptran_ep_set_keepalive,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t// terminate list\n@@ -1249,8 +1160,8 @@ static nni_tran_option tcptran_listener_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = tcptran_listener_get_recvmaxsz,\n-\t    .o_set  = tcptran_listener_set_recvmaxsz,\n+\t    .o_get  = tcptran_ep_get_recvmaxsz,\n+\t    .o_set  = tcptran_ep_set_recvmaxsz,\n \t    .o_chk  = tcptran_check_recvmaxsz,\n \t},\n \t{\n@@ -1266,15 +1177,15 @@ static nni_tran_option tcptran_listener_options[] = {\n \t{\n \t    .o_name = NNG_OPT_TCP_NODELAY,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_listener_get_nodelay,\n-\t    .o_set  = tcptran_listener_set_nodelay,\n+\t    .o_get  = tcptran_ep_get_nodelay,\n+\t    .o_set  = tcptran_ep_set_nodelay,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t{\n \t    .o_name = NNG_OPT_TCP_KEEPALIVE,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_listener_get_keepalive,\n-\t    .o_set  = tcptran_listener_set_keepalive,\n+\t    .o_get  = tcptran_ep_get_keepalive,\n+\t    .o_set  = tcptran_ep_set_keepalive,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t// terminate list\ndiff --git a/src/transport/tls/tls.c b/src/transport/tls/tls.c\nindex e6701f5f5..88e201b9f 100644\n--- a/src/transport/tls/tls.c\n+++ b/src/transport/tls/tls.c\n@@ -29,16 +29,23 @@ typedef struct tlstran_pipe     tlstran_pipe;\n \n // tlstran_pipe is one end of a TLS connection.\n struct tlstran_pipe {\n-\tnni_tls *tls;\n-\tuint16_t peer;\n-\tuint16_t proto;\n-\tsize_t   rcvmax;\n-\tbool     nodelay;\n-\tbool     keepalive;\n+\tnni_tls *       tls;\n+\tuint16_t        peer;\n+\tuint16_t        proto;\n+\tsize_t          rcvmax;\n+\tbool            nodelay;\n+\tbool            keepalive;\n+\tnni_atomic_flag reaped;\n+\tnni_list_node   node; // When pending, we are on ep list.\n+\ttlstran_ep *    ep;\n+\tnni_tcp_dialer *dialer; // Client side.\n+\tnni_sockaddr    sa;\n+\tnni_reap_item   reap;\n+\tbool            closed;\n \n \tnni_list sendq;\n \tnni_list recvq;\n-\tnni_aio *user_negaio;\n+\tnni_aio *useraio;\n \n \tuint8_t  txlen[sizeof(uint64_t)];\n \tuint8_t  rxlen[sizeof(uint64_t)];\n@@ -48,7 +55,9 @@ struct tlstran_pipe {\n \tsize_t   wantrxhead;\n \tnni_aio *txaio;\n \tnni_aio *rxaio;\n-\tnni_aio *negaio;\n+\tnni_aio *negoaio;\n+\tnni_aio *connaio;\n+\tnni_aio *rslvaio;\n \tnni_msg *rxmsg;\n \tnni_mtx  mtx;\n };\n@@ -59,27 +68,25 @@ struct tlstran_ep {\n \tsize_t          rcvmax;\n \tbool            nodelay;\n \tbool            keepalive;\n+\tbool            fini;\n+\tnni_reap_item   reap;\n+\tnni_cb          dtor;\n \tint             authmode;\n \tnng_tls_config *cfg;\n \tnni_url *       url;\n \tnni_mtx         mtx;\n+\tnni_list        pipes;\n };\n \n struct tlstran_dialer {\n \ttlstran_ep      ep; // must be first\n \tnni_tcp_dialer *dialer;\n \tuint16_t        af;\n-\tnni_aio *       aio;\n-\tnni_aio *       user_aio;\n-\tbool            resolving;\n-\tnng_sockaddr    sa;\n };\n \n struct tlstran_listener {\n \ttlstran_ep        ep; // must be first\n \tnni_tcp_listener *listener;\n-\tnni_aio *         aio;\n-\tnni_aio *         user_aio;\n \tnng_sockaddr      sa;\n \tnng_sockaddr      bsa; // bound addr\n };\n@@ -88,9 +95,10 @@ static void tlstran_pipe_send_start(tlstran_pipe *);\n static void tlstran_pipe_recv_start(tlstran_pipe *);\n static void tlstran_pipe_send_cb(void *);\n static void tlstran_pipe_recv_cb(void *);\n+static void tlstran_pipe_rslv_cb(void *);\n+static void tlstran_pipe_conn_cb(void *);\n static void tlstran_pipe_nego_cb(void *);\n-static void tlstran_dialer_cb(void *);\n-static void tlstran_listener_cb(void *);\n+static void tlstran_pipe_reap(tlstran_pipe *);\n \n static int\n tlstran_init(void)\n@@ -108,9 +116,15 @@ tlstran_pipe_close(void *arg)\n {\n \ttlstran_pipe *p = arg;\n \n+\tnni_mtx_lock(&p->mtx);\n+\tp->closed = true;\n+\tnni_mtx_unlock(&p->mtx);\n+\n \tnni_aio_close(p->rxaio);\n \tnni_aio_close(p->txaio);\n-\tnni_aio_close(p->negaio);\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n \n \tnni_tls_close(p->tls);\n }\n@@ -122,26 +136,53 @@ tlstran_pipe_stop(void *arg)\n \n \tnni_aio_stop(p->rxaio);\n \tnni_aio_stop(p->txaio);\n-\tnni_aio_stop(p->negaio);\n+\tnni_aio_stop(p->negoaio);\n+\tnni_aio_stop(p->connaio);\n+\tnni_aio_stop(p->rslvaio);\n }\n \n static void\n tlstran_pipe_fini(void *arg)\n {\n \ttlstran_pipe *p = arg;\n+\ttlstran_ep *  ep;\n+\n+\tif (p == NULL) {\n+\t\treturn;\n+\t}\n+\ttlstran_pipe_stop(p);\n+\tif ((ep = p->ep) != NULL) {\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tnni_list_remove(&ep->pipes, p);\n+\t\tif (ep->fini && nni_list_empty(&ep->pipes)) {\n+\t\t\tnni_reap(&ep->reap, ep->dtor, ep);\n+\t\t}\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t}\n \n \tnni_aio_fini(p->rxaio);\n \tnni_aio_fini(p->txaio);\n-\tnni_aio_fini(p->negaio);\n+\tnni_aio_fini(p->negoaio);\n+\tnni_aio_fini(p->connaio);\n+\tnni_aio_fini(p->rslvaio);\n \tif (p->tls != NULL) {\n \t\tnni_tls_fini(p->tls);\n \t}\n \tnni_msg_free(p->rxmsg);\n+\tnni_mtx_fini(&p->mtx);\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+tlstran_pipe_reap(tlstran_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n+\t\tnni_reap(&p->reap, tlstran_pipe_fini, p);\n+\t}\n+}\n+\n static int\n-tlstran_pipe_init(tlstran_pipe **pipep, nni_tls *tls)\n+tlstran_pipe_init(tlstran_pipe **pipep, tlstran_ep *ep)\n {\n \ttlstran_pipe *p;\n \tint           rv;\n@@ -150,46 +191,110 @@ tlstran_pipe_init(tlstran_pipe **pipep, nni_tls *tls)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&p->mtx);\n+\tnni_aio_list_init(&p->recvq);\n+\tnni_aio_list_init(&p->sendq);\n+\tnni_atomic_flag_reset(&p->reaped);\n+\tnni_list_append(&ep->pipes, p);\n+\n+\tp->proto     = ep->proto;\n+\tp->rcvmax    = ep->rcvmax;\n+\tp->nodelay   = ep->nodelay;\n+\tp->keepalive = ep->keepalive;\n+\tp->ep        = ep;\n \n \tif (((rv = nni_aio_init(&p->txaio, tlstran_pipe_send_cb, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->rxaio, tlstran_pipe_recv_cb, p)) != 0) ||\n-\t    ((rv = nni_aio_init(&p->negaio, tlstran_pipe_nego_cb, p)) != 0)) {\n-\t\ttlstran_pipe_fini(p);\n+\t    ((rv = nni_aio_init(&p->rslvaio, tlstran_pipe_rslv_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->connaio, tlstran_pipe_conn_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->negoaio, tlstran_pipe_nego_cb, p)) != 0)) {\n+\t\ttlstran_pipe_reap(p);\n \t\treturn (rv);\n \t}\n-\tnni_aio_list_init(&p->recvq);\n-\tnni_aio_list_init(&p->sendq);\n \n-\tp->tls = tls;\n \t*pipep = p;\n \treturn (0);\n }\n \n static void\n-tlstran_pipe_cancel_nego(nni_aio *aio, int rv)\n+tlstran_pipe_rslv_cb(void *arg)\n {\n-\ttlstran_pipe *p = nni_aio_get_prov_data(aio);\n+\ttlstran_pipe *  p   = arg;\n+\ttlstran_dialer *d   = (void *) p->ep;\n+\tnni_aio *       aio = p->rslvaio;\n+\tint             rv;\n \n-\tnni_mtx_lock(&p->mtx);\n-\tif (p->user_negaio != aio) {\n-\t\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttlstran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tp->user_negaio = NULL;\n-\tnni_mtx_unlock(&p->mtx);\n+\tif (d->dialer != NULL) {\n+\t\tnni_tcp_dialer_dial(d->dialer, &p->sa, p->connaio);\n+\t}\n+\tnni_mtx_unlock(&p->ep->mtx);\n+}\n \n-\tnni_aio_abort(p->negaio, rv);\n-\tnni_aio_finish_error(aio, rv);\n+static void\n+tlstran_pipe_conn_cb(void *arg)\n+{\n+\ttlstran_pipe *p   = arg;\n+\tnni_aio *     aio = p->connaio;\n+\tnni_iov       iov;\n+\tint           rv;\n+\n+\tnni_mtx_lock(&p->ep->mtx);\n+\n+\tif ((rv = nni_aio_result(aio)) == 0) {\n+\t\tnni_tcp_conn *tcp = nni_aio_get_output(aio, 0);\n+\t\tif ((rv = nni_tls_init(&p->tls, p->ep->cfg, tcp)) != 0) {\n+\t\t\tnni_tcp_conn_fini(tcp);\n+\t\t}\n+\t}\n+\n+\tif (rv != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttlstran_pipe_reap(p);\n+\t\treturn;\n+\t}\n+\n+\tp->txlen[0] = 0;\n+\tp->txlen[1] = 'S';\n+\tp->txlen[2] = 'P';\n+\tp->txlen[3] = 0;\n+\tNNI_PUT16(&p->txlen[4], p->proto);\n+\tNNI_PUT16(&p->txlen[6], 0);\n+\n+\tp->gotrxhead  = 0;\n+\tp->gottxhead  = 0;\n+\tp->wantrxhead = 8;\n+\tp->wanttxhead = 8;\n+\tiov.iov_len   = 8;\n+\tiov.iov_buf   = &p->txlen[0];\n+\tnni_aio_set_iov(p->negoaio, 1, &iov);\n+\tnni_tls_send(p->tls, p->negoaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n }\n \n static void\n tlstran_pipe_nego_cb(void *arg)\n {\n \ttlstran_pipe *p   = arg;\n-\tnni_aio *     aio = p->negaio;\n+\tnni_aio *     aio = p->negoaio;\n+\tnni_aio *     uaio;\n \tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n \tif ((rv = nni_aio_result(aio)) != 0) {\n \t\tgoto done;\n \t}\n@@ -208,7 +313,7 @@ tlstran_pipe_nego_cb(void *arg)\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\t// send it down...\n \t\tnni_tls_send(p->tls, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \tif (p->gotrxhead < p->wantrxhead) {\n@@ -217,7 +322,7 @@ tlstran_pipe_nego_cb(void *arg)\n \t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_tls_recv(p->tls, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \t// We have both sent and received the headers.  Lets check the\n@@ -232,17 +337,23 @@ tlstran_pipe_nego_cb(void *arg)\n \tNNI_GET16(&p->rxlen[4], p->peer);\n \n done:\n-\tif (rv == 0) {\n-\t\t// These can fail. Note that the TLS stack automatically\n-\t\t// starts out in NODELAY to make the handshake performant.\n-\t\t(void) nni_tls_set_nodelay(p->tls, p->nodelay);\n-\t\t(void) nni_tls_set_keepalive(p->tls, p->keepalive);\n-\t}\n-\tif ((aio = p->user_negaio) != NULL) {\n-\t\tp->user_negaio = NULL;\n-\t\tnni_aio_finish(aio, rv, 0);\n+\tif ((uaio = p->useraio) != NULL) {\n+\t\tp->useraio = NULL;\n+\t\tif (rv == 0) {\n+\t\t\t// These can fail. Note that the TLS stack\n+\t\t\t// automatically starts out in NODELAY to make the\n+\t\t\t// handshake performant.\n+\t\t\t(void) nni_tls_set_nodelay(p->tls, p->nodelay);\n+\t\t\t(void) nni_tls_set_keepalive(p->tls, p->keepalive);\n+\t\t\tnni_aio_set_output(uaio, 0, p);\n+\t\t\tnni_aio_finish(uaio, 0, 0);\n+\t\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\t\treturn;\n+\t\t}\n+\t\tnni_aio_finish_error(aio, rv);\n \t}\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&p->ep->mtx);\n+\ttlstran_pipe_reap(p);\n }\n \n static void\n@@ -256,17 +367,18 @@ tlstran_pipe_send_cb(void *arg)\n \tnni_aio *     txaio = p->txaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->sendq);\n-\n-\tif ((rv = nni_aio_result(txaio)) != 0) {\n+\trv = p->closed ? NNG_ECLOSED : nni_aio_result(txaio);\n+\tif (rv != 0) {\n \t\t// Intentionally we do not queue up another transfer.\n \t\t// There's an excellent chance that the pipe is no longer\n \t\t// usable, with a partial transfer.\n \t\t// The protocol should see this error, and close the\n \t\t// pipe itself, we hope.\n-\t\tnni_aio_list_remove(aio);\n+\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, rv);\n+\t\t}\n \t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n \t\treturn;\n \t}\n \n@@ -277,6 +389,7 @@ tlstran_pipe_send_cb(void *arg)\n \t\tnni_mtx_unlock(&p->mtx);\n \t\treturn;\n \t}\n+\taio = nni_list_first(&p->sendq);\n \tnni_aio_list_remove(aio);\n \ttlstran_pipe_send_start(p);\n \tnni_mtx_unlock(&p->mtx);\n@@ -299,11 +412,14 @@ tlstran_pipe_recv_cb(void *arg)\n \tnni_aio *     rxaio = p->rxaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->recvq);\n \n \tif ((rv = nni_aio_result(p->rxaio)) != 0) {\n \t\tgoto recv_error;\n \t}\n+\tif (p->closed) {\n+\t\trv = NNG_ECLOSED;\n+\t\tgoto recv_error;\n+\t}\n \n \tn = nni_aio_count(rxaio);\n \tnni_aio_iov_advance(rxaio, n);\n@@ -348,6 +464,7 @@ tlstran_pipe_recv_cb(void *arg)\n \t}\n \n \t// We read a message completely.  Let the user know the good news.\n+\taio = nni_list_first(&p->recvq);\n \tnni_aio_list_remove(aio);\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n@@ -361,14 +478,16 @@ tlstran_pipe_recv_cb(void *arg)\n \treturn;\n \n recv_error:\n-\tnni_aio_list_remove(aio);\n+\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n+\t\tnni_aio_list_remove(aio);\n+\t\tnni_aio_finish_error(aio, rv);\n+\t}\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n \t// Intentionally, we do not queue up another receive.\n \t// The protocol should notice this error and close the pipe.\n \tnni_mtx_unlock(&p->mtx);\n \tnni_msg_free(msg);\n-\tnni_aio_finish_error(aio, rv);\n }\n \n static void\n@@ -444,6 +563,11 @@ tlstran_pipe_send(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tlstran_pipe_send_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -486,7 +610,7 @@ tlstran_pipe_recv_start(tlstran_pipe *p)\n \tnni_iov  iov;\n \tNNI_ASSERT(p->rxmsg == NULL);\n \n-\t// Schedule a read of the IPC header.\n+\t// Schedule a read of the header.\n \trxaio       = p->rxaio;\n \tiov.iov_buf = p->rxlen;\n \tiov.iov_len = sizeof(p->rxlen);\n@@ -505,6 +629,11 @@ tlstran_pipe_recv(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tlstran_pipe_recv_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -569,56 +698,40 @@ tlstran_pipe_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n }\n \n static void\n-tlstran_pipe_start(void *arg, nni_aio *aio)\n+tlstran_ep_close(tlstran_ep *ep)\n {\n-\ttlstran_pipe *p = arg;\n-\tnni_aio *     negaio;\n-\tnni_iov       iov;\n-\tint           rv;\n-\n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n-\t}\n-\tnni_mtx_lock(&p->mtx);\n-\tif ((rv = nni_aio_schedule(aio, tlstran_pipe_cancel_nego, p)) != 0) {\n-\t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n+\ttlstran_pipe *p;\n+\tnni_mtx_lock(&ep->mtx);\n+\tNNI_LIST_FOREACH (&ep->pipes, p) {\n+\t\tnni_aio_close(p->negoaio);\n+\t\tnni_aio_close(p->connaio);\n+\t\tnni_aio_close(p->rslvaio);\n \t}\n-\tp->txlen[0] = 0;\n-\tp->txlen[1] = 'S';\n-\tp->txlen[2] = 'P';\n-\tp->txlen[3] = 0;\n-\tNNI_PUT16(&p->txlen[4], p->proto);\n-\tNNI_PUT16(&p->txlen[6], 0);\n-\n-\tp->user_negaio = aio;\n-\tp->gotrxhead   = 0;\n-\tp->gottxhead   = 0;\n-\tp->wantrxhead  = 8;\n-\tp->wanttxhead  = 8;\n-\tnegaio         = p->negaio;\n-\tiov.iov_len    = 8;\n-\tiov.iov_buf    = &p->txlen[0];\n-\tnni_aio_set_iov(negaio, 1, &iov);\n-\tnni_tls_send(p->tls, negaio);\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&ep->mtx);\n }\n \n static void\n tlstran_dialer_fini(void *arg)\n {\n-\ttlstran_dialer *d = arg;\n+\ttlstran_dialer *d  = arg;\n+\ttlstran_ep *    ep = &d->ep;\n \n-\tnni_aio_stop(d->aio);\n+\tnni_mtx_lock(&ep->mtx);\n+\td->ep.fini = true;\n \tif (d->dialer != NULL) {\n \t\tnni_tcp_dialer_fini(d->dialer);\n+\t\td->dialer = NULL;\n+\t}\n+\tif (!nni_list_empty(&ep->pipes)) {\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t\treturn;\n \t}\n-\tnni_aio_fini(d->aio);\n-\tif (d->ep.cfg != NULL) {\n-\t\tnni_tls_config_fini(d->ep.cfg);\n+\tnni_mtx_unlock(&ep->mtx);\n+\tif (ep->cfg != NULL) {\n+\t\tnni_tls_config_fini(ep->cfg);\n \t}\n-\tnni_mtx_fini(&d->ep.mtx);\n+\tnni_mtx_fini(&ep->mtx);\n+\n \tNNI_FREE_STRUCT(d);\n }\n \n@@ -627,8 +740,8 @@ tlstran_dialer_close(void *arg)\n {\n \ttlstran_dialer *d = arg;\n \n-\tnni_aio_close(d->aio);\n \tnni_tcp_dialer_close(d->dialer);\n+\ttlstran_ep_close(&d->ep);\n }\n \n static int\n@@ -664,110 +777,48 @@ tlstran_dialer_init(void **dp, nni_url *url, nni_sock *sock)\n \t}\n \n \tnni_mtx_init(&d->ep.mtx);\n+\tNNI_LIST_INIT(&d->ep.pipes, tlstran_pipe, node);\n \td->ep.authmode  = NNG_TLS_AUTH_MODE_REQUIRED;\n \td->ep.url       = url;\n \td->ep.proto     = nni_sock_proto_id(sock);\n \td->ep.nodelay   = true;\n \td->ep.keepalive = false;\n+\td->ep.dtor      = tlstran_dialer_fini;\n+\td->af           = af;\n \n \tif (((rv = nni_tcp_dialer_init(&d->dialer)) != 0) ||\n \t    ((rv = nni_tls_config_init(&d->ep.cfg, NNG_TLS_MODE_CLIENT)) !=\n \t        0) ||\n \t    ((rv = nng_tls_config_auth_mode(d->ep.cfg, d->ep.authmode)) !=\n \t        0) ||\n-\t    ((rv = nng_tls_config_server_name(d->ep.cfg, host)) != 0) ||\n-\t    ((rv = nni_aio_init(&d->aio, tlstran_dialer_cb, d)) != 0)) {\n+\t    ((rv = nng_tls_config_server_name(d->ep.cfg, host)) != 0)) {\n \t\ttlstran_dialer_fini(d);\n \t\treturn (rv);\n \t}\n-\td->af = af;\n \n \t*dp = d;\n \treturn (0);\n }\n \n static void\n-tlstran_dialer_cb(void *arg)\n+tlstran_pipe_conn_cancel(nni_aio *aio, int rv)\n {\n-\ttlstran_dialer *d = arg;\n-\ttlstran_pipe *  p;\n-\tnni_tcp_conn *  conn;\n-\tnni_tls *       tls;\n-\tnni_aio *       aio;\n-\tint             rv;\n-\n-\tnni_mtx_lock(&d->ep.mtx);\n-\taio = d->user_aio;\n-\trv  = nni_aio_result(d->aio);\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tif ((rv == 0) && !d->resolving) {\n-\t\t\tconn = nni_aio_get_output(d->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\td->user_aio = NULL;\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tif (d->resolving) {\n-\t\t// Name resolution complete.  Now go to next step.\n-\t\td->resolving = false;\n-\t\tnni_tcp_dialer_dial(d->dialer, &d->sa, d->aio);\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tconn        = nni_aio_get_output(d->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\n-\tif ((rv = nni_tls_init(&tls, d->ep.cfg, conn)) != 0) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n+\ttlstran_pipe *p = nni_aio_get_prov_data(aio);\n \n-\tif ((rv = tlstran_pipe_init(&p, tls)) != 0) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tnni_tls_fini(tls);\n-\t\tnni_aio_finish_error(aio, rv);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif (p->useraio != aio) {\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \n-\tp->proto     = d->ep.proto;\n-\tp->rcvmax    = d->ep.rcvmax;\n-\tp->nodelay   = d->ep.nodelay;\n-\tp->keepalive = d->ep.keepalive;\n-\tnni_mtx_unlock(&d->ep.mtx);\n-\n-\t(void) nni_tls_set_nodelay(tls, p->nodelay);\n-\t(void) nni_tls_set_keepalive(tls, p->keepalive);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n+\t// Close the underlying AIOs.  This will abort the operation.\n+\t// The pipe is removed from pending list at completion callback.\n+\tp->useraio = NULL;\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n \n-static void\n-tlstran_dialer_cancel(nni_aio *aio, int rv)\n-{\n-\ttlstran_dialer *d = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&d->ep.mtx);\n-\tif (d->user_aio != aio) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tnni_mtx_unlock(&d->ep.mtx);\n-\n-\tnni_aio_abort(d->aio, rv);\n \tnni_aio_finish_error(aio, rv);\n }\n \n@@ -775,45 +826,52 @@ static void\n tlstran_dialer_connect(void *arg, nni_aio *aio)\n {\n \ttlstran_dialer *d = arg;\n+\ttlstran_pipe *  p = NULL;\n \tint             rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n \tnni_mtx_lock(&d->ep.mtx);\n-\tNNI_ASSERT(d->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tlstran_dialer_cancel, d)) != 0) {\n+\tif (((rv = tlstran_pipe_init(&p, &d->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tlstran_pipe_conn_cancel, p)) != 0)) {\n \t\tnni_mtx_unlock(&d->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttlstran_pipe_reap(p);\n \t\treturn;\n \t}\n-\td->user_aio = aio;\n+\tp->useraio = aio;\n+\tp->dialer  = d->dialer;\n \n-\td->resolving = true;\n-\n-\t// Start the name resolution.  Callback will see resolving, and then\n-\t// switch to doing actual connect.\n-\tnni_aio_set_input(d->aio, 0, &d->sa);\n+\t// Start the name resolution.\n+\tnni_aio_set_input(p->rslvaio, 0, &p->sa);\n \tnni_tcp_resolv(\n-\t    d->ep.url->u_hostname, d->ep.url->u_port, d->af, 0, d->aio);\n+\t    d->ep.url->u_hostname, d->ep.url->u_port, d->af, 0, p->rslvaio);\n \tnni_mtx_unlock(&d->ep.mtx);\n }\n \n static void\n tlstran_listener_fini(void *arg)\n {\n-\ttlstran_listener *l = arg;\n+\ttlstran_listener *l  = arg;\n+\ttlstran_ep *      ep = &l->ep;\n \n-\tnni_aio_stop(l->aio);\n+\tnni_mtx_lock(&ep->mtx);\n+\tl->ep.fini = true;\n \tif (l->listener != NULL) {\n \t\tnni_tcp_listener_fini(l->listener);\n+\t\tl->listener = NULL;\n \t}\n-\tnni_aio_fini(l->aio);\n-\tif (l->ep.cfg != NULL) {\n-\t\tnni_tls_config_fini(l->ep.cfg);\n+\tif (!nni_list_empty(&ep->pipes)) {\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t\treturn;\n+\t}\n+\tnni_mtx_unlock(&ep->mtx);\n+\tif (ep->cfg != NULL) {\n+\t\tnni_tls_config_fini(ep->cfg);\n \t}\n-\tnni_mtx_fini(&l->ep.mtx);\n+\tnni_mtx_fini(&ep->mtx);\n+\n \tNNI_FREE_STRUCT(l);\n }\n \n@@ -822,7 +880,7 @@ tlstran_listener_close(void *arg)\n {\n \ttlstran_listener *l = arg;\n \n-\tnni_aio_close(l->aio);\n+\ttlstran_ep_close(&l->ep);\n \tnni_tcp_listener_close(l->listener);\n }\n \n@@ -859,11 +917,13 @@ tlstran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&l->ep.mtx);\n+\tNNI_LIST_INIT(&l->ep.pipes, tlstran_pipe, node);\n \tl->ep.url       = url;\n \tl->ep.authmode  = NNG_TLS_AUTH_MODE_NONE;\n \tl->ep.keepalive = false;\n \tl->ep.nodelay   = true;\n \tl->ep.proto     = nni_sock_proto_id(sock);\n+\tl->ep.dtor      = tlstran_listener_fini;\n \n \tif (strlen(host) == 0) {\n \t\thost = NULL;\n@@ -896,8 +956,7 @@ tlstran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \t    ((rv = nni_tls_config_init(&l->ep.cfg, NNG_TLS_MODE_SERVER)) !=\n \t        0) ||\n \t    ((rv = nng_tls_config_auth_mode(l->ep.cfg, l->ep.authmode)) !=\n-\t        0) ||\n-\t    ((rv = nni_aio_init(&l->aio, tlstran_listener_cb, l)) != 0)) {\n+\t        0)) {\n \t\ttlstran_listener_fini(l);\n \t\treturn (rv);\n \t}\n@@ -921,99 +980,27 @@ tlstran_listener_bind(void *arg)\n \treturn (rv);\n }\n \n-static void\n-tlstran_listener_cb(void *arg)\n-{\n-\ttlstran_listener *l = arg;\n-\tnni_aio *         aio;\n-\tint               rv;\n-\ttlstran_pipe *    p = NULL;\n-\tnni_tcp_conn *    conn;\n-\tnni_tls *         tls;\n-\n-\tnni_mtx_lock(&l->ep.mtx);\n-\trv          = nni_aio_result(l->aio);\n-\taio         = l->user_aio;\n-\tl->user_aio = NULL;\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(l->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\tif (rv != 0) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tconn = nni_aio_get_output(l->aio, 0);\n-\tif ((rv = nni_tls_init(&tls, l->ep.cfg, conn)) != 0) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tif ((rv = tlstran_pipe_init(&p, tls)) != 0) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tnni_tls_fini(tls);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tp->proto     = l->ep.proto;\n-\tp->rcvmax    = l->ep.rcvmax;\n-\tp->nodelay   = l->ep.nodelay;\n-\tp->keepalive = l->ep.keepalive;\n-\n-\t(void) nni_tls_set_nodelay(tls, p->nodelay);\n-\t(void) nni_tls_set_keepalive(tls, p->keepalive);\n-\n-\tnni_mtx_unlock(&l->ep.mtx);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-tlstran_listener_cancel(nni_aio *aio, int rv)\n-{\n-\ttlstran_listener *l = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&l->ep.mtx);\n-\tif (l->user_aio != aio) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\treturn;\n-\t}\n-\tl->user_aio = NULL;\n-\tnni_mtx_unlock(&l->ep.mtx);\n-\n-\tnni_aio_abort(l->aio, rv);\n-\tnni_aio_finish_error(aio, rv);\n-}\n-\n static void\n tlstran_listener_accept(void *arg, nni_aio *aio)\n {\n \ttlstran_listener *l = arg;\n+\ttlstran_pipe *    p = NULL;\n \tint               rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n \tnni_mtx_lock(&l->ep.mtx);\n-\tNNI_ASSERT(l->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tlstran_listener_cancel, l)) != 0) {\n+\tif (((rv = tlstran_pipe_init(&p, &l->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tlstran_pipe_conn_cancel, p)) != 0)) {\n \t\tnni_mtx_unlock(&l->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttlstran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tl->user_aio = aio;\n+\tp->useraio = aio;\n \n-\tnni_tcp_listener_accept(l->listener, l->aio);\n+\tnni_tcp_listener_accept(l->listener, p->connaio);\n \tnni_mtx_unlock(&l->ep.mtx);\n }\n \n@@ -1306,7 +1293,6 @@ static nni_tran_option tlstran_pipe_options[] = {\n \n static nni_tran_pipe_ops tlstran_pipe_ops = {\n \t.p_fini    = tlstran_pipe_fini,\n-\t.p_start   = tlstran_pipe_start,\n \t.p_stop    = tlstran_pipe_stop,\n \t.p_send    = tlstran_pipe_send,\n \t.p_recv    = tlstran_pipe_recv,\ndiff --git a/src/transport/zerotier/zerotier.c b/src/transport/zerotier/zerotier.c\nindex a2163e3f6..d10729315 100644\n--- a/src/transport/zerotier/zerotier.c\n+++ b/src/transport/zerotier/zerotier.c\n@@ -183,27 +183,28 @@ struct zt_fraglist {\n };\n \n struct zt_pipe {\n-\tnni_list_node zp_link;\n-\tconst char *  zp_addr;\n-\tzt_node *     zp_ztn;\n-\tuint64_t      zp_nwid;\n-\tuint64_t      zp_laddr;\n-\tuint64_t      zp_raddr;\n-\tuint16_t      zp_peer;\n-\tuint16_t      zp_proto;\n-\tuint16_t      zp_next_msgid;\n-\tsize_t        zp_rcvmax;\n-\tsize_t        zp_mtu;\n-\tint           zp_closed;\n-\tnni_aio *     zp_user_rxaio;\n-\tnni_time      zp_last_recv;\n-\tzt_fraglist   zp_recvq[zt_recvq];\n-\tint           zp_ping_try;\n-\tint           zp_ping_tries;\n-\tint           zp_ping_active;\n-\tnni_duration  zp_ping_time;\n-\tnni_aio *     zp_ping_aio;\n-\tuint8_t *     zp_send_buf;\n+\tnni_list_node   zp_link;\n+\tconst char *    zp_addr;\n+\tzt_node *       zp_ztn;\n+\tuint64_t        zp_nwid;\n+\tuint64_t        zp_laddr;\n+\tuint64_t        zp_raddr;\n+\tuint16_t        zp_peer;\n+\tuint16_t        zp_proto;\n+\tuint16_t        zp_next_msgid;\n+\tsize_t          zp_rcvmax;\n+\tsize_t          zp_mtu;\n+\tnni_aio *       zp_user_rxaio;\n+\tnni_time        zp_last_recv;\n+\tzt_fraglist     zp_recvq[zt_recvq];\n+\tint             zp_ping_try;\n+\tint             zp_ping_tries;\n+\tbool            zp_closed;\n+\tnni_duration    zp_ping_time;\n+\tnni_aio *       zp_ping_aio;\n+\tuint8_t *       zp_send_buf;\n+\tnni_atomic_flag zp_reaped;\n+\tnni_reap_item   zp_reap;\n };\n \n typedef struct zt_creq zt_creq;\n@@ -280,6 +281,7 @@ static void zt_fraglist_free(zt_fraglist *);\n static void zt_virtual_recv(ZT_Node *, void *, void *, uint64_t, void **,\n     uint64_t, uint64_t, unsigned int, unsigned int, const void *,\n     unsigned int);\n+static void zt_pipe_start_ping(zt_pipe *);\n \n static int64_t\n zt_now(void)\n@@ -805,10 +807,8 @@ zt_pipe_close_err(zt_pipe *p, int err, uint8_t code, const char *msg)\n \t\tp->zp_user_rxaio = NULL;\n \t\tnni_aio_finish_error(aio, err);\n \t}\n-\tif ((aio = p->zp_ping_aio) != NULL) {\n-\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n-\t}\n-\tp->zp_closed = 1;\n+\tnni_aio_close(p->zp_ping_aio);\n+\tp->zp_closed = true;\n \tif (msg != NULL) {\n \t\tzt_pipe_send_err(p, code, msg);\n \t}\n@@ -974,7 +974,7 @@ zt_pipe_recv_disc_req(zt_pipe *p, const uint8_t *data, size_t len)\n \t// Don't bother to check the length, going to disconnect anyway.\n \tif ((aio = p->zp_user_rxaio) != NULL) {\n \t\tp->zp_user_rxaio = NULL;\n-\t\tp->zp_closed     = 1;\n+\t\tp->zp_closed     = true;\n \t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n \t}\n }\n@@ -990,7 +990,7 @@ zt_pipe_recv_error(zt_pipe *p, const uint8_t *data, size_t len)\n \t// the day, the details are just not that interesting.\n \tif ((aio = p->zp_user_rxaio) != NULL) {\n \t\tp->zp_user_rxaio = NULL;\n-\t\tp->zp_closed     = 1;\n+\t\tp->zp_closed     = true;\n \t\tnni_aio_finish_error(aio, NNG_ETRANERR);\n \t}\n }\n@@ -1627,7 +1627,8 @@ zt_pipe_close(void *arg)\n \tnni_aio *aio;\n \n \tnni_mtx_lock(&zt_lk);\n-\tp->zp_closed = 1;\n+\tp->zp_closed = true;\n+\tnni_aio_close(p->zp_ping_aio);\n \tif ((aio = p->zp_user_rxaio) != NULL) {\n \t\tp->zp_user_rxaio = NULL;\n \t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n@@ -1659,6 +1660,14 @@ zt_pipe_fini(void *arg)\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+zt_pipe_reap(zt_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->zp_reaped)) {\n+\t\tnni_reap(&p->zp_reap, zt_pipe_fini, p);\n+\t}\n+}\n+\n static int\n zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n {\n@@ -1687,6 +1696,7 @@ zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n \tp->zp_ping_time  = ep->ze_ping_time;\n \tp->zp_next_msgid = (uint16_t) nni_random();\n \tp->zp_ping_try   = 0;\n+\tnni_atomic_flag_reset(&p->zp_reaped);\n \n \tif (ep->ze_mode == NNI_EP_MODE_DIAL) {\n \t\trv = nni_idhash_insert(ztn->zn_lpipes, laddr, p);\n@@ -1696,7 +1706,8 @@ zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n \tif ((rv != 0) ||\n \t    ((rv = nni_idhash_insert(ztn->zn_peers, p->zp_raddr, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->zp_ping_aio, zt_pipe_ping_cb, p)) != 0)) {\n-\t\tzt_pipe_fini(p);\n+\t\tzt_pipe_reap(p);\n+\t\treturn (rv);\n \t}\n \n \t// The largest fragment we can accept on this pipe. The MTU is\n@@ -1717,7 +1728,7 @@ zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n \t\tfl->fl_missingsz = (maxfrags + 7) / 8;\n \t\tfl->fl_missing   = nni_alloc(fl->fl_missingsz);\n \t\tif (fl->fl_missing == NULL) {\n-\t\t\tzt_pipe_fini(p);\n+\t\t\tzt_pipe_reap(p);\n \t\t\treturn (NNG_ENOMEM);\n \t\t}\n \t}\n@@ -2015,97 +2026,51 @@ zt_pipe_get_node(void *arg, void *buf, size_t *szp, nni_opt_type t)\n \treturn (nni_copyout_u64(p->zp_laddr >> 24, buf, szp, t));\n }\n \n-static void\n-zt_pipe_cancel_ping(nni_aio *aio, int rv)\n-{\n-\tzt_pipe *p = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&zt_lk);\n-\tif (p->zp_ping_active) {\n-\t\tp->zp_ping_active = 0;\n-\t\tnni_aio_finish_error(aio, rv);\n-\t}\n-\tnni_mtx_unlock(&zt_lk);\n-}\n-\n static void\n zt_pipe_ping_cb(void *arg)\n {\n \tzt_pipe *p   = arg;\n \tnni_aio *aio = p->zp_ping_aio;\n+\tint      rv;\n \n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\t// We were canceled.  That means we're done.\n+\t\treturn;\n+\t}\n \tnni_mtx_lock(&zt_lk);\n-\n-\tp->zp_ping_active = 0;\n \tif (p->zp_closed || aio == NULL || (p->zp_ping_tries == 0) ||\n \t    (p->zp_ping_time == NNG_DURATION_INFINITE) ||\n \t    (p->zp_ping_time == NNG_DURATION_ZERO)) {\n \t\tnni_mtx_unlock(&zt_lk);\n \t\treturn;\n \t}\n-\tif (nni_aio_result(aio) != NNG_ETIMEDOUT) {\n-\t\tnni_mtx_unlock(&zt_lk);\n-\t\treturn;\n-\t}\n-\tif (p->zp_ping_try < p->zp_ping_tries) {\n-\t\tnni_time now = nni_clock();\n-\t\tnni_aio_set_timeout(aio, p->zp_ping_time);\n-\t\t// We want pings.  We only send one if needed, but we\n-\t\t// use the the timer to wake us up even if we aren't\n-\t\t// going to send a ping.  (We don't increment the try count\n-\t\t// unless we actually do send one though.)\n-\t\tif (nni_aio_begin(aio) == 0) {\n-\t\t\tint rv;\n-\t\t\trv = nni_aio_schedule(aio, zt_pipe_cancel_ping, p);\n-\t\t\tif (rv != 0) {\n-\t\t\t\tnni_mtx_unlock(&zt_lk);\n-\t\t\t\tnni_aio_finish_error(aio, rv);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tp->zp_ping_active = 1;\n-\t\t\tif (now > (p->zp_last_recv + p->zp_ping_time)) {\n-\t\t\t\tp->zp_ping_try++;\n-\t\t\t\tzt_pipe_send_ping(p);\n-\t\t\t}\n-\t\t}\n-\t} else {\n+\tif (p->zp_ping_try >= p->zp_ping_tries) {\n \t\t// Ping count exceeded; the other side is AFK.\n \t\t// Close the pipe, but no need to send a reason to the peer.\n \t\tzt_pipe_close_err(p, NNG_ECLOSED, 0, NULL);\n+\t\tnni_mtx_unlock(&zt_lk);\n+\t\treturn;\n+\t}\n+\n+\tif (nni_clock() > (p->zp_last_recv + p->zp_ping_time)) {\n+\t\tp->zp_ping_try++;\n+\t\tzt_pipe_send_ping(p);\n \t}\n+\n+\tnni_sleep_aio(p->zp_ping_time, aio); // Schedule a recheck.\n \tnni_mtx_unlock(&zt_lk);\n }\n \n static void\n-zt_pipe_start(void *arg, nni_aio *aio)\n+zt_pipe_start_ping(zt_pipe *p)\n {\n-\tzt_pipe *p = arg;\n-\n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n-\t}\n-\tnni_mtx_lock(&zt_lk);\n-\tp->zp_ping_active = 0;\n \t// send a gratuitous ping, and start the ping interval timer.\n \tif ((p->zp_ping_tries > 0) && (p->zp_ping_time != NNG_DURATION_ZERO) &&\n-\t    (p->zp_ping_time != NNG_DURATION_INFINITE) &&\n-\t    (p->zp_ping_aio != NULL)) {\n+\t    (p->zp_ping_time != NNG_DURATION_INFINITE)) {\n \t\tp->zp_ping_try = 0;\n-\t\tnni_aio_set_timeout(aio, p->zp_ping_time);\n-\t\tif (nni_aio_begin(p->zp_ping_aio) == 0) {\n-\t\t\tint rv;\n-\t\t\trv = nni_aio_schedule(\n-\t\t\t    p->zp_ping_aio, zt_pipe_cancel_ping, p);\n-\t\t\tif (rv != 0) {\n-\t\t\t\tnni_aio_finish_error(p->zp_ping_aio, rv);\n-\t\t\t} else {\n-\t\t\t\tp->zp_ping_active = 1;\n-\t\t\t\tzt_pipe_send_ping(p);\n-\t\t\t}\n-\t\t}\n+\t\tzt_pipe_send_ping(p);\n+\t\tnni_sleep_aio(p->zp_ping_time, p->zp_ping_aio);\n \t}\n-\tnni_aio_finish(aio, 0, 0);\n-\tnni_mtx_unlock(&zt_lk);\n }\n \n static void\n@@ -2425,6 +2390,7 @@ zt_ep_doaccept(zt_ep *ep)\n \t\t}\n \t\tp->zp_peer = creq.cr_proto;\n \t\tzt_pipe_send_conn_ack(p);\n+\t\tzt_pipe_start_ping(p);\n \t\tnni_aio_set_output(aio, 0, p);\n \t\tnni_aio_finish(aio, 0, 0);\n \t}\n@@ -2484,6 +2450,7 @@ zt_ep_conn_req_cb(void *arg)\n \t\t// Already canceled, or already handled?\n \t\tif ((uaio = nni_list_first(&ep->ze_aios)) != NULL) {\n \t\t\tnni_aio_list_remove(uaio);\n+\t\t\tzt_pipe_start_ping(p);\n \t\t\tnni_aio_set_output(uaio, 0, p);\n \t\t\tnni_aio_finish(uaio, 0, 0);\n \t\t} else {\n@@ -2991,7 +2958,6 @@ static nni_tran_option zt_pipe_options[] = {\n \n static nni_tran_pipe_ops zt_pipe_ops = {\n \t.p_fini    = zt_pipe_fini,\n-\t.p_start   = zt_pipe_start,\n \t.p_send    = zt_pipe_send,\n \t.p_recv    = zt_pipe_recv,\n \t.p_close   = zt_pipe_close,\n", "test_patch": "diff --git a/tests/tls.c b/tests/tls.c\nindex 1f1f244c6..01e49aa74 100644\n--- a/tests/tls.c\n+++ b/tests/tls.c\n@@ -265,7 +265,6 @@ init_listener_tls_file(nng_listener l)\n }\n \n TestMain(\"TLS Transport\", {\n-\n \tstatic trantest tt;\n \n \ttt.dialer_init   = init_dialer_tls;\n@@ -291,28 +290,39 @@ TestMain(\"TLS Transport\", {\n \t});\n \n \tConvey(\"We can bind to wild card\", {\n-\t\tnng_socket s1;\n-\t\tnng_socket s2;\n-\t\tchar       addr[NNG_MAXADDRLEN];\n+\t\tnng_socket   s1;\n+\t\tnng_socket   s2;\n+\t\tchar         addr[NNG_MAXADDRLEN];\n+\t\tnng_listener l;\n+\t\tnng_dialer   d;\n \n \t\tSo(nng_tls_register() == 0);\n+\n \t\tSo(nng_pair_open(&s1) == 0);\n \t\tSo(nng_pair_open(&s2) == 0);\n+\n \t\tReset({\n \t\t\tnng_close(s2);\n \t\t\tnng_close(s1);\n \t\t});\n \t\ttrantest_next_address(addr, \"tls+tcp://*:%u\");\n-\t\tSo(nng_listen(s1, addr, NULL, 0) == 0);\n-\t\t// reset port back one\n+\t\tSo(nng_listener_create(&l, s1, addr) == 0);\n+\t\tSo(init_listener_tls(l) == 0);\n \t\ttrantest_prev_address(addr, \"tls+tcp://127.0.0.1:%u\");\n-\t\tSo(nng_dial(s2, addr, NULL, 0) == 0);\n+\t\tSo(nng_dialer_create(&d, s2, addr) == 0);\n+\t\tSo(init_dialer_tls(d) == 0);\n+\t\tSo(nng_dialer_setopt_int(\n+\t\t       d, NNG_OPT_TLS_AUTH_MODE, NNG_TLS_AUTH_MODE_NONE) == 0);\n+\n+\t\tSo(nng_listener_start(l, 0) == 0);\n+\t\tSo(nng_dialer_start(d, 0) == 0);\n \t});\n \n \tConvey(\"We can bind to port zero\", {\n \t\tnng_socket   s1;\n \t\tnng_socket   s2;\n \t\tnng_listener l;\n+\t\tnng_dialer   d;\n \t\tchar *       addr;\n \t\tsize_t       sz;\n \n@@ -323,10 +333,16 @@ TestMain(\"TLS Transport\", {\n \t\t\tnng_close(s2);\n \t\t\tnng_close(s1);\n \t\t});\n-\t\tSo(nng_listen(s1, \"tls+tcp://127.0.0.1:0\", &l, 0) == 0);\n+\t\tSo(nng_listener_create(&l, s1, \"tls+tcp://127.0.0.1:0\") == 0);\n+\t\tSo(init_listener_tls(l) == 0);\n+\t\tSo(nng_listener_start(l, 0) == 0);\n \t\tsz = NNG_MAXADDRLEN;\n \t\tSo(nng_listener_getopt_string(l, NNG_OPT_URL, &addr) == 0);\n-\t\tSo(nng_dial(s2, addr, NULL, 0) == 0);\n+\t\tSo(nng_dialer_create(&d, s2, addr) == 0);\n+\t\tSo(init_dialer_tls(d) == 0);\n+\t\tSo(nng_dialer_setopt_int(\n+\t\t       d, NNG_OPT_TLS_AUTH_MODE, NNG_TLS_AUTH_MODE_NONE) == 0);\n+\t\tSo(nng_dialer_start(d, 0) == 0);\n \t\tnng_strfree(addr);\n \t});\n \n@@ -572,5 +588,4 @@ TestMain(\"TLS Transport\", {\n \t\tSo(nng_dialer_getopt_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);\n \t\tSo(v == true);\n \t});\n-\n })\n", "problem_statement": "Race condition closing between header & body\nFor some protocols (TCP, IPC, and TLS stream transports), if the pipe is closed, we\r\ncan wind up closing the pipe, but rescheduling a transfer of data which won't fail\r\nas the underlying aio is closed.\r\n\r\nFor this to occur, the close has to occur between receiving the message header\r\nand the message body.\r\n\n", "hints_text": "", "created_at": "2018-08-01T01:50:11Z"}

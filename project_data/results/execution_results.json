[
  {
    "instance_id": "redis__hiredis-1215",
    "success": true,
    "attempts": 1,
    "final_patch_file": "D:\\上课资料\\科研课堂\\WeCode\\CFix\\project_data\\results\\redis__hiredis-1215_final_patch.diff",
    "trajectory_file": "D:\\上课资料\\科研课堂\\WeCode\\CFix\\project_data\\trajs\\redis__hiredis-1215_trajectory.json",
    "log_directory": "D:\\上课资料\\科研课堂\\WeCode\\CFix\\project_data\\logs\\redis__hiredis-1215_20250606_141156",
    "test_logs": "=== METHOD: HEREDOC ===\n=== AI PATCH PREVIEW ===\ndiff --git a/net.c b/net.c\nindex ec96412..114f597 100644\n--- a/net.c\n+++ b/net.c\n@@ -172,6 +172,11 @@ int redisKeepAlive(redisContext *c, int interval) {\n     int val = 1;\n     redisFD fd = c->fd;\n \n+    if (c->connection_type == REDIS_CONN_UNIX) {\n+        __redisSetError(c,REDIS_ERR_OTHER,\"Keepalive not supported for unix socket\");\n\n\n=== TEST EXECUTION ===\npatching file net.c\nHunk #1 succeeded at 173 (offset 1 line).\ncc -std=c99 -c -O3 -fPIC   -Wall -Wextra -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -Werror -g -ggdb  -pedantic net.c\ncc  -shared -Wl,-soname,libhiredis.so.1.2.1-dev -o libhiredis.so alloc.o net.o hiredis.o sds.o async.o read.o sockcompat.o \nar rcs libhiredis.a alloc.o net.o hiredis.o sds.o async.o read.o sockcompat.o\ncc -o hiredis-test -O3 -fPIC   -Wall -Wextra -Wstrict-prototypes -Wwrite-strings -Wno-missing-field-initializers -Werror -g -ggdb  -pedantic -I. test.o libhiredis.a  \n./hiredis-test\n#01 redisContext uses injected allocators: \u001b[0;32mPASSED\u001b[0;0m\n#02 redisReader uses injected allocators: \u001b[0;32mPASSED\u001b[0;0m\n#03 hiredis calloc wrapper protects against overflow: \u001b[0;32mPASSED\u001b[0;0m\n#04 Format command without interpolation: \u001b[0;32mPASSED\u001b[0;0m\n#05 Format command with %s string interpolation: \u001b[0;32mPASSED\u001b[0;0m\n#06 Format command with %s and an empty string: \u001b[0;32mPASSED\u001b[0;0m\n#07 Format command with an empty string in between proper interpolations: \u001b[0;32mPASSED\u001b[0;0m\n#08 Format command with %b string interpolation: \u001b[0;32mPASSED\u001b[0;0m\n#09 Format command with %b and an empty string: \u001b[0;32mPASSED\u001b[0;0m\n#10 Format command with literal %: \u001b[0;32mPASSED\u001b[0;0m\n#11 Format command with printf-delegation (int): \u001b[0;32mPASSED\u001b[0;0m\n#12 Format command with printf-delegation (char): \u001b[0;32mPASSED\u001b[0;0m\n#13 Format command with printf-delegation (short): \u001b[0;32mPASSED\u001b[0;0m\n#14 Format command with printf-delegation (long): \u001b[0;32mPASSED\u001b[0;0m\n#15 Format command with printf-delegation (long long): \u001b[0;32mPASSED\u001b[0;0m\n#16 Format command with printf-delegation (unsigned int): \u001b[0;32mPASSED\u001b[0;0m\n#17 Format command with printf-delegation (unsigned char): \u001b[0;32mPASSED\u001b[0;0m\n#18 Format command with printf-delegation (unsigned short): \u001b[0;32mPASSED\u001b[0;0m\n#19 Format command with printf-delegation (unsigned long): \u001b[0;32mPASSED\u001b[0;0m\n#20 Format command with printf-delegation (unsigned long long): \u001b[0;32mPASSED\u001b[0;0m\n#21 Format command with printf-delegation (float): \u001b[0;32mPASSED\u001b[0;0m\n#22 Format command with printf-delegation (double): \u001b[0;32mPASSED\u001b[0;0m\n#23 Format command with unhandled printf format (specifier 'p' not supported): \u001b[0;32mPASSED\u001b[0;0m\n#24 Format command with invalid printf format (specifier missing): \u001b[0;32mPASSED\u001b[0;0m\n#25 Format command by passing argc/argv without lengths: \u001b[0;32mPASSED\u001b[0;0m\n#26 Format command by passing argc/argv with lengths: \u001b[0;32mPASSED\u001b[0;0m\n#27 Format command into sds by passing argc/argv without lengths: \u001b[0;32mPASSED\u001b[0;0m\n#28 Format command into sds by passing argc/argv with lengths: \u001b[0;32mPASSED\u001b[0;0m\n#29 Error handling in reply parser: \u001b[0;32mPASSED\u001b[0;0m\n#30 Memory cleanup in reply parser: \u001b[0;32mPASSED\u001b[0;0m\n#31 Can handle arbitrarily nested multi-bulks: \u001b[0;32mPASSED\u001b[0;0m\n#32 Can parse arbitrarily nested multi-bulks correctly: \u001b[0;32mPASSED\u001b[0;0m\n#33 Correctly parses LLONG_MAX: \u001b[0;32mPASSED\u001b[0;0m\n#34 Set error when > LLONG_MAX: \u001b[0;32mPASSED\u001b[0;0m\n#35 Correctly parses LLONG_MIN: \u001b[0;32mPASSED\u001b[0;0m\n#36 Set error when < LLONG_MIN: \u001b[0;32mPASSED\u001b[0;0m\n#37 Set error when array < -1: \u001b[0;32mPASSED\u001b[0;0m\n#38 Set error when bulk < -1: \u001b[0;32mPASSED\u001b[0;0m\n#39 Can configure maximum multi-bulk elements: \u001b[0;32mPASSED\u001b[0;0m\n#40 Multi-bulk never overflows regardless of maxelements: \u001b[0;32mPASSED\u001b[0;0m\n#41 Works with NULL functions for reply: \u001b[0;32mPASSED\u001b[0;0m\n#42 Works when a single newline (\\r\\n) covers two calls to feed: \u001b[0;32mPASSED\u001b[0;0m\n#43 Don't reset state after protocol error: \u001b[0;32mPASSED\u001b[0;0m\n#44 Don't reset state after protocol error(not segfault): \u001b[0;32mPASSED\u001b[0;0m\n#45 Don't do empty allocation for empty multi bulk: \u001b[0;32mPASSED\u001b[0;0m\n#46 Can parse RESP3 verbatim strings: \u001b[0;32mPASSED\u001b[0;0m\n#47 Can parse RESP3 push messages: \u001b[0;32mPASSED\u001b[0;0m\n#48 Can parse RESP3 doubles: \u001b[0;32mPASSED\u001b[0;0m\n#49 Set error on invalid RESP3 double: \u001b[0;32mPASSED\u001b[0;0m\n#50 Correctly parses RESP3 double INFINITY: \u001b[0;32mPASSED\u001b[0;0m\n#51 Correctly parses RESP3 double NaN: \u001b[0;32mPASSED\u001b[0;0m\n#52 Correctly parses RESP3 double -Nan: \u001b[0;32mPASSED\u001b[0;0m\n#53 Can parse RESP3 nil: \u001b[0;32mPASSED\u001b[0;0m\n#54 Set error on invalid RESP3 nil: \u001b[0;32mPASSED\u001b[0;0m\n#55 Can parse RESP3 bool (true): \u001b[0;32mPASSED\u001b[0;0m\n#56 Can parse RESP3 bool (false): \u001b[0;32mPASSED\u001b[0;0m\n#57 Set error on invalid RESP3 bool: \u001b[0;32mPASSED\u001b[0;0m\n#58 Can parse RESP3 map: \u001b[0;32mPASSED\u001b[0;0m\n#59 Can parse RESP3 set: \u001b[0;32mPASSED\u001b[0;0m\n#60 Can parse RESP3 bignum: \u001b[0;32mPASSED\u001b[0;0m\n#61 Can parse RESP3 doubles in an array: \u001b[0;32mPASSED\u001b[0;0m\n#62 Returns error when host cannot be resolved: \u001b[0;32mPASSED\u001b[0;0m\n#63 Returns error when the port is not open: \u001b[0;32mPASSED\u001b[0;0m\n#64 We don't clobber connection exception with setsockopt error: \u001b[0;32mPASSED\u001b[0;0m\n#65 Returns error when the unix_sock socket path doesn't accept connections: \u001b[0;32mPASSED\u001b[0;0m\n#66 Don't fail when redisFree is passed a NULL value: \u001b[0;32mPASSED\u001b[0;0m\n#67 Don't fail when freeReplyObject is passed a NULL value: \u001b[0;32mPASSED\u001b[0;0m\n\nTesting against TCP connection (172.17.0.2:6379):\n#68 Is able to deliver commands: \u001b[0;32mPASSED\u001b[0;0m\n#69 Is a able to send commands verbatim: \u001b[0;32mPASSED\u001b[0;0m\n#70 %s String interpolation works: \u001b[0;32mPASSED\u001b[0;0m\n#71 %b String interpolation works: \u001b[0;32mPASSED\u001b[0;0m\n#72 Binary reply length is correct: \u001b[0;32mPASSED\u001b[0;0m\n#73 Can parse nil replies: \u001b[0;32mPASSED\u001b[0;0m\n#74 Can parse integer replies: \u001b[0;32mPASSED\u001b[0;0m\n#75 Can parse multi bulk replies: \u001b[0;32mPASSED\u001b[0;0m\n#76 Can handle nested multi bulk replies: \u001b[0;32mPASSED\u001b[0;0m\n#77 Send command by passing argc/argv: \u001b[0;32mPASSED\u001b[0;0m\n#78 Can pass NULL to redisGetReply: \u001b[0;32mPASSED\u001b[0;0m\n#79 RESP3 PUSH messages are handled out of band by default: \u001b[0;32mPASSED\u001b[0;0m\n#80 We can set a custom RESP3 PUSH handler: \u001b[0;32mPASSED\u001b[0;0m\n#81 We properly handle a NIL invalidation payload: \u001b[0;32mPASSED\u001b[0;0m\n#82 With no handler, PUSH replies come in-band: \u001b[0;32mPASSED\u001b[0;0m\n#83 With no PUSH handler, no replies are lost: \u001b[0;32mPASSED\u001b[0;0m\n#84 We set a default RESP3 handler for redisContext: \u001b[0;32mPASSED\u001b[0;0m\n#85 We don't set a default RESP3 push handler for redisAsyncContext: \u001b[0;32mPASSED\u001b[0;0m\n#86 Our REDIS_OPT_NO_PUSH_AUTOFREE flag works: \u001b[0;32mPASSED\u001b[0;0m\n#87 We can use redisOptions to set a custom PUSH handler for redisContext: \u001b[0;32mPASSED\u001b[0;0m\n#88 We can use redisOptions to set a custom PUSH handler for redisAsyncContext: \u001b[0;32mPASSED\u001b[0;0m\n#89 We can use redisOptions to set privdata: \u001b[0;32mPASSED\u001b[0;0m\n#90 Our privdata destructor fires when we free the context: \u001b[0;32mPASSED\u001b[0;0m\n#91 Successfully completes a command when the timeout is not exceeded: \u001b[0;32mPASSED\u001b[0;0m\n#92 Does not return a reply when the command times out: \u001b[0;32mPASSED\u001b[0;0m\n#93 Reconnect properly reconnects after a timeout: \u001b[0;32mPASSED\u001b[0;0m\n#94 Reconnect properly uses owned parameters: \u001b[0;32mPASSED\u001b[0;0m\n#95 Returns I/O error when the connection is lost: \u001b[0;32mPASSED\u001b[0;0m\n#96 Returns I/O error on socket timeout: \u001b[0;32mPASSED\u001b[0;0m\n#97 Set error when an invalid timeout usec value is used during connect: \u001b[0;32mPASSED\u001b[0;0m\n#98 Set error when an invalid timeout sec value is used during connect: \u001b[0;32mPASSED\u001b[0;0m\n#99 Append format command: \u001b[0;32mPASSED\u001b[0;0m\n#100 We can enable TCP_KEEPALIVE: \u001b[0;32mPASSED\u001b[0;0m\n#101 We can set TCP_USER_TIMEOUT: \u001b[0;32mPASSED\u001b[0;0m\n#102 Throughput:\n\t(1000x PING: 0.035s)\n\t(1000x LRANGE with 500 elements: 0.087s)\n\t(1000x INCRBY: 0.064s)\n\t(10000x PING (pipelined): 0.005s)\n\t(10000x LRANGE with 500 elements (pipelined): 0.504s)\n\t(10000x INCRBY (pipelined): 0.022s)\n\nTesting against Unix socket connection (/tmp/redis.sock): \n#103 Is able to deliver commands: \u001b[0;32mPASSED\u001b[0;0m\n#104 Is a able to send commands verbatim: \u001b[0;32mPASSED\u001b[0;0m\n#105 %s String interpolation works: \u001b[0;32mPASSED\u001b[0;0m\n#106 %b String interpolation works: \u001b[0;32mPASSED\u001b[0;0m\n#107 Binary reply length is correct: \u001b[0;32mPASSED\u001b[0;0m\n#108 Can parse nil replies: \u001b[0;32mPASSED\u001b[0;0m\n#109 Can parse integer replies: \u001b[0;32mPASSED\u001b[0;0m\n#110 Can parse multi bulk replies: \u001b[0;32mPASSED\u001b[0;0m\n#111 Can handle nested multi bulk replies: \u001b[0;32mPASSED\u001b[0;0m\n#112 Send command by passing argc/argv: \u001b[0;32mPASSED\u001b[0;0m\n#113 Can pass NULL to redisGetReply: \u001b[0;32mPASSED\u001b[0;0m\n#114 RESP3 PUSH messages are handled out of band by default: \u001b[0;32mPASSED\u001b[0;0m\n#115 We can set a custom RESP3 PUSH handler: \u001b[0;32mPASSED\u001b[0;0m\n#116 We properly handle a NIL invalidation payload: \u001b[0;32mPASSED\u001b[0;0m\n#117 With no handler, PUSH replies come in-band: \u001b[0;32mPASSED\u001b[0;0m\n#118 With no PUSH handler, no replies are lost: \u001b[0;32mPASSED\u001b[0;0m\n#119 We set a default RESP3 handler for redisContext: \u001b[0;32mPASSED\u001b[0;0m\n#120 We don't set a default RESP3 push handler for redisAsyncContext: \u001b[0;32mPASSED\u001b[0;0m\n#121 Our REDIS_OPT_NO_PUSH_AUTOFREE flag works: \u001b[0;32mPASSED\u001b[0;0m\n#122 We can use redisOptions to set a custom PUSH handler for redisContext: \u001b[0;32mPASSED\u001b[0;0m\n#123 We can use redisOptions to set a custom PUSH handler for redisAsyncContext: \u001b[0;32mPASSED\u001b[0;0m\n#124 We can use redisOptions to set privdata: \u001b[0;32mPASSED\u001b[0;0m\n#125 Our privdata destructor fires when we free the context: \u001b[0;32mPASSED\u001b[0;0m\n#126 Successfully completes a command when the timeout is not exceeded: \u001b[0;32mPASSED\u001b[0;0m\n#127 Does not return a reply when the command times out: \u001b[0;32mPASSED\u001b[0;0m\n#128 Reconnect properly reconnects after a timeout: \u001b[0;32mPASSED\u001b[0;0m\n#129 Reconnect properly uses owned parameters: \u001b[0;32mPASSED\u001b[0;0m\n#130 Returns I/O error when the connection is lost: \u001b[0;32mPASSED\u001b[0;0m\n#131 Returns I/O error on socket timeout: \u001b[0;32mPASSED\u001b[0;0m\n#132 Set error when an invalid timeout usec value is used during connect: \u001b[0;32mPASSED\u001b[0;0m\n#133 Set error when an invalid timeout sec value is used during connect: \u001b[0;32mPASSED\u001b[0;0m\n#134 Throughput:\n\t(1000x PING: 0.029s)\n\t(1000x LRANGE with 500 elements: 0.078s)\n\t(1000x INCRBY: 0.027s)\n\t(10000x PING (pipelined): 0.003s)\n\t(10000x LRANGE with 500 elements (pipelined): 0.501s)\n\t(10000x INCRBY (pipelined): 0.025s)\n\nTesting asynchronous API using polling_adapter TCP (172.17.0.2:6379):\n#135 Async connect: \u001b[0;32mPASSED\u001b[0;0m\n#136 Async free after connect: \u001b[0;32mPASSED\u001b[0;0m\n#137 Async connect timeout: \u001b[0;32mPASSED\u001b[0;0m\n#138 Async PING/PONG: \u001b[0;32mPASSED\u001b[0;0m\n#139 Async PING/PONG after connect timeout: \u001b[0;32mPASSED\u001b[0;0m\n#140 Disconnect from onConnected callback (Issue #931): \u001b[0;32mPASSED\u001b[0;0m\n#141 Ping/Pong from onConnected callback (Issue #931): \u001b[0;32mPASSED\u001b[0;0m\n\nTesting asynchronous API using polling_adapter UNIX (/tmp/redis.sock):\n#142 Async connect: \u001b[0;32mPASSED\u001b[0;0m\n#143 Async free after connect: \u001b[0;32mPASSED\u001b[0;0m\n#144 Async PING/PONG: \u001b[0;32mPASSED\u001b[0;0m\n#145 Disconnect from onConnected callback (Issue #931): \u001b[0;32mPASSED\u001b[0;0m\n#146 Ping/Pong from onConnected callback (Issue #931): \u001b[0;32mPASSED\u001b[0;0m\n\nTesting against inherited fd (/tmp/redis.sock): \nConnecting to inherited fd 3\n#147 Is able to deliver commands: \u001b[0;32mPASSED\u001b[0;0m\n#148 Is a able to send commands verbatim: \u001b[0;32mPASSED\u001b[0;0m\n#149 %s String interpolation works: \u001b[0;32mPASSED\u001b[0;0m\n#150 %b String interpolation works: \u001b[0;32mPASSED\u001b[0;0m\n#151 Binary reply length is correct: \u001b[0;32mPASSED\u001b[0;0m\n#152 Can parse nil replies: \u001b[0;32mPASSED\u001b[0;0m\n#153 Can parse integer replies: \u001b[0;32mPASSED\u001b[0;0m\n#154 Can parse multi bulk replies: \u001b[0;32mPASSED\u001b[0;0m\n#155 Can handle nested multi bulk replies: \u001b[0;32mPASSED\u001b[0;0m\n#156 Send command by passing argc/argv: \u001b[0;32mPASSED\u001b[0;0m\n#157 Can pass NULL to redisGetReply: \u001b[0;32mPASSED\u001b[0;0m\n#158 RESP3 PUSH messages are handled out of band by default: \u001b[0;32mPASSED\u001b[0;0m\n#159 We can set a custom RESP3 PUSH handler: \u001b[0;32mPASSED\u001b[0;0m\n#160 We properly handle a NIL invalidation payload: \u001b[0;32mPASSED\u001b[0;0m\n#161 With no handler, PUSH replies come in-band: \u001b[0;32mPASSED\u001b[0;0m\n#162 With no PUSH handler, no replies are lost: \u001b[0;32mPASSED\u001b[0;0m\n#163 We set a default RESP3 handler for redisContext: \u001b[0;32mPASSED\u001b[0;0m\n#164 We don't set a default RESP3 push handler for redisAsyncContext: \u001b[0;32mPASSED\u001b[0;0m\n#165 Our REDIS_OPT_NO_PUSH_AUTOFREE flag works: \u001b[0;32mPASSED\u001b[0;0m\n#166 We can use redisOptions to set a custom PUSH handler for redisContext: \u001b[0;32mPASSED\u001b[0;0m\n#167 We can use redisOptions to set a custom PUSH handler for redisAsyncContext: \u001b[0;32mPASSED\u001b[0;0m\n#168 We can use redisOptions to set privdata: \u001b[0;32mPASSED\u001b[0;0m\n#169 Our privdata destructor fires when we free the context: \u001b[0;32mPASSED\u001b[0;0m\nALL TESTS PASSED (0 skipped)\n"
  }
]
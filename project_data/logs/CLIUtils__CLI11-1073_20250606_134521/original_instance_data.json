{
  "repo": "CLIUtils/CLI11",
  "pull_number": 1073,
  "instance_id": "CLIUtils__CLI11-1073",
  "issue_numbers": [
    "1022"
  ],
  "base_commit": "79b14300197b10a5f7bb7c9ebeac1f956ab41f98",
  "patch": "diff --git a/.github/actions/quick_cmake/action.yml b/.github/actions/quick_cmake/action.yml\nindex d2b3825fe..9889e24dd 100644\n--- a/.github/actions/quick_cmake/action.yml\n+++ b/.github/actions/quick_cmake/action.yml\n@@ -13,7 +13,7 @@ runs:\n   using: composite\n   steps:\n     - name: CMake ${{ inputs.cmake-version }}\n-      uses: jwlawson/actions-setup-cmake@v1.14\n+      uses: jwlawson/actions-setup-cmake@v2.0.2\n       with:\n         cmake-version: \"${{ inputs.cmake-version }}\"\n     - run: |\ndiff --git a/README.md b/README.md\nindex 4a84885f9..c3ae26fb6 100644\n--- a/README.md\n+++ b/README.md\n@@ -905,10 +905,15 @@ option_groups. These are:\n   options are specified in the `add_option` calls or the ability to process\n   options in the form of `-s --long --file=file_name.ext`.\n - `.fallthrough()`: Allow extra unmatched options and positionals to \"fall\n-  through\" and be matched on a parent option. Subcommands always are allowed to\n-  \"fall through\" as in they will first attempt to match on the current\n+  through\" and be matched on a parent option. Subcommands by default are allowed\n+  to \"fall through\" as in they will first attempt to match on the current\n   subcommand and if they fail will progressively check parents for matching\n-  subcommands.\n+  subcommands. This can be disabled through `subcommand_fallthrough(false)` ðŸš§.\n+- `.subcommand_fallthrough()`: ðŸš§ Allow subcommands to \"fall through\" and be\n+  matched on a parent option. Disabling this prevents additional subcommands at\n+  the same level from being matched. It can be useful in certain circumstances\n+  where there might be ambiguity between subcommands and positionals. The\n+  default is true.\n - `.configurable()`: Allow the subcommand to be triggered from a configuration\n   file. By default subcommand options in a configuration file do not trigger a\n   subcommand but will just update default values.\ndiff --git a/book/chapters/subcommands.md b/book/chapters/subcommands.md\nindex 7a0c41c7e..0f621b867 100644\n--- a/book/chapters/subcommands.md\n+++ b/book/chapters/subcommands.md\n@@ -132,7 +132,21 @@ gitbook:code $ ./my_program my_model_1 --model_flag --shared_flag\n ```\n \n Here, `--shared_flag` was set on the main app, and on the command line it \"falls\n-through\" `my_model_1` to match on the main app.\n+through\" `my_model_1` to match on the main app. This is set through\n+`->fallthrough()` on a subcommand.\n+\n+#### Subcommand fallthrough\n+\n+Subcommand fallthrough allows additional subcommands to be triggered after the\n+first subcommand. By default subcommand fallthrough is enabled, but it can be\n+turned off through `->subcommand_fallthrough(false)` on a subcommand. This will\n+prevent additional subcommands at the same inheritance level from triggering,\n+the strings would then be treated as positional values. As a technical note if\n+fallthrough is enabled but subcommand fallthrough disabled (this is not the\n+default in both cases), then subcommands on grandparents can still be triggered\n+from the grandchild subcommand, unless subcommand fallthrough is also disabled\n+on the parent. This is an unusual circumstance but may arise in some very\n+particular situations.\n \n ### Prefix command\n \ndiff --git a/include/CLI/App.hpp b/include/CLI/App.hpp\nindex f98463f97..dd8b37227 100644\n--- a/include/CLI/App.hpp\n+++ b/include/CLI/App.hpp\n@@ -224,9 +224,13 @@ class App {\n     /// If true, the program should ignore underscores INHERITABLE\n     bool ignore_underscore_{false};\n \n-    /// Allow subcommand fallthrough, so that parent commands can collect commands after subcommand.  INHERITABLE\n+    /// Allow options or other arguments to fallthrough, so that parent commands can collect options after subcommand.\n+    /// INHERITABLE\n     bool fallthrough_{false};\n \n+    /// Allow subcommands to fallthrough, so that parent commands can trigger other subcommands after subcommand.\n+    bool subcommand_fallthrough_{true};\n+\n     /// Allow '/' for options for Windows like options. Defaults to true on Windows, false otherwise. INHERITABLE\n     bool allow_windows_style_options_{\n #ifdef _WIN32\n@@ -828,13 +832,19 @@ class App {\n         return this;\n     }\n \n-    /// Stop subcommand fallthrough, so that parent commands cannot collect commands after subcommand.\n+    /// Set fallthrough, set to true so that options will fallthrough to parent if not recognized in a subcommand\n     /// Default from parent, usually set on parent.\n     App *fallthrough(bool value = true) {\n         fallthrough_ = value;\n         return this;\n     }\n \n+    /// Set subcommand fallthrough, set to true so that subcommands on parents are recognized\n+    App *subcommand_fallthrough(bool value = true) {\n+        subcommand_fallthrough_ = value;\n+        return this;\n+    }\n+\n     /// Check to see if this subcommand was parsed, true only if received on command line.\n     /// This allows the subcommand to be directly checked.\n     explicit operator bool() const { return parsed_ > 0; }\n@@ -1084,6 +1094,9 @@ class App {\n     /// Check the status of fallthrough\n     CLI11_NODISCARD bool get_fallthrough() const { return fallthrough_; }\n \n+    /// Check the status of subcommand fallthrough\n+    CLI11_NODISCARD bool get_subcommand_fallthrough() const { return subcommand_fallthrough_; }\n+\n     /// Check the status of the allow windows style options\n     CLI11_NODISCARD bool get_allow_windows_style_options() const { return allow_windows_style_options_; }\n \ndiff --git a/include/CLI/impl/App_inl.hpp b/include/CLI/impl/App_inl.hpp\nindex b66bab7c9..f4325dce3 100644\n--- a/include/CLI/impl/App_inl.hpp\n+++ b/include/CLI/impl/App_inl.hpp\n@@ -1038,7 +1038,8 @@ CLI11_INLINE void App::run_callback(bool final_mode, bool suppress_final_callbac\n \n CLI11_NODISCARD CLI11_INLINE bool App::_valid_subcommand(const std::string &current, bool ignore_used) const {\n     // Don't match if max has been reached - but still check parents\n-    if(require_subcommand_max_ != 0 && parsed_subcommands_.size() >= require_subcommand_max_) {\n+    if(require_subcommand_max_ != 0 && parsed_subcommands_.size() >= require_subcommand_max_ &&\n+       subcommand_fallthrough_) {\n         return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);\n     }\n     auto *com = _find_subcommand(current, true, ignore_used);\n@@ -1046,7 +1047,10 @@ CLI11_NODISCARD CLI11_INLINE bool App::_valid_subcommand(const std::string &curr\n         return true;\n     }\n     // Check parent if exists, else return false\n-    return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);\n+    if(subcommand_fallthrough_) {\n+        return parent_ != nullptr && parent_->_valid_subcommand(current, ignore_used);\n+    }\n+    return false;\n }\n \n CLI11_NODISCARD CLI11_INLINE detail::Classifier App::_recognize(const std::string &current,\n@@ -1743,9 +1747,9 @@ CLI11_INLINE bool App::_parse_positional(std::vector<std::string> &args, bool ha\n         }\n     }\n     // let the parent deal with it if possible\n-    if(parent_ != nullptr && fallthrough_)\n+    if(parent_ != nullptr && fallthrough_) {\n         return _get_fallthrough_parent()->_parse_positional(args, static_cast<bool>(parse_complete_callback_));\n-\n+    }\n     /// Try to find a local subcommand that is repeated\n     auto *com = _find_subcommand(args.back(), true, false);\n     if(com != nullptr && (require_subcommand_max_ == 0 || require_subcommand_max_ > parsed_subcommands_.size())) {\n@@ -1756,15 +1760,16 @@ CLI11_INLINE bool App::_parse_positional(std::vector<std::string> &args, bool ha\n         com->_parse(args);\n         return true;\n     }\n-    /// now try one last gasp at subcommands that have been executed before, go to root app and try to find a\n-    /// subcommand in a broader way, if one exists let the parent deal with it\n-    auto *parent_app = (parent_ != nullptr) ? _get_fallthrough_parent() : this;\n-    com = parent_app->_find_subcommand(args.back(), true, false);\n-    if(com != nullptr && (com->parent_->require_subcommand_max_ == 0 ||\n-                          com->parent_->require_subcommand_max_ > com->parent_->parsed_subcommands_.size())) {\n-        return false;\n+    if(subcommand_fallthrough_) {\n+        /// now try one last gasp at subcommands that have been executed before, go to root app and try to find a\n+        /// subcommand in a broader way, if one exists let the parent deal with it\n+        auto *parent_app = (parent_ != nullptr) ? _get_fallthrough_parent() : this;\n+        com = parent_app->_find_subcommand(args.back(), true, false);\n+        if(com != nullptr && (com->parent_->require_subcommand_max_ == 0 ||\n+                              com->parent_->require_subcommand_max_ > com->parent_->parsed_subcommands_.size())) {\n+            return false;\n+        }\n     }\n-\n     if(positionals_at_end_) {\n         throw CLI::ExtrasError(name_, args);\n     }\n",
  "test_patch": "diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml\nindex 86e61e734..98b963557 100644\n--- a/.github/workflows/tests.yml\n+++ b/.github/workflows/tests.yml\n@@ -292,10 +292,10 @@ jobs:\n           cmake-version: \"3.13\"\n         if: success() || failure()\n \n-      - name: Check CMake 3.14\n+      - name: Check CMake 3.14.7\n         uses: ./.github/actions/quick_cmake\n         with:\n-          cmake-version: \"3.14\"\n+          cmake-version: \"3.14.7\"\n           args: -DCLI11_SANITIZERS=ON -DCLI11_BUILD_EXAMPLES_JSON=ON\n         if: success() || failure()\n \n@@ -387,6 +387,6 @@ jobs:\n       - name: Check CMake 3.28 (full)\n         uses: ./.github/actions/quick_cmake\n         with:\n-          cmake-version: \"3.28\"\n+          cmake-version: \"3.28.X\"\n           args: -DCLI11_SANITIZERS=ON -DCLI11_BUILD_EXAMPLES_JSON=ON\n         if: success() || failure()\ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\nindex 6724fca04..53404bc3a 100644\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -4,7 +4,7 @@ if(CLI11_SANITIZERS AND ${CMAKE_VERSION} VERSION_GREATER \"3.13.0\")\n     sanitizers\n     GIT_REPOSITORY https://github.com/arsenm/sanitizers-cmake.git\n     GIT_SHALLOW 1\n-    GIT_TAG 3f0542e)\n+    GIT_TAG 0573e2e)\n \n   FetchContent_GetProperties(sanitizers)\n \ndiff --git a/tests/SubcommandTest.cpp b/tests/SubcommandTest.cpp\nindex b7a8bb97c..dc98a7742 100644\n--- a/tests/SubcommandTest.cpp\n+++ b/tests/SubcommandTest.cpp\n@@ -719,12 +719,25 @@ TEST_CASE_METHOD(TApp, \"Required1SubCom\", \"[subcom]\") {\n     CHECK_THROWS_AS(run(), CLI::RequiredError);\n \n     args = {\"sub1\"};\n-    run();\n+    CHECK_NOTHROW(run());\n \n     args = {\"sub1\", \"sub2\"};\n     CHECK_THROWS_AS(run(), CLI::ExtrasError);\n }\n \n+TEST_CASE_METHOD(TApp, \"subcomNoSubComfallthrough\", \"[subcom]\") {\n+    auto *sub1 = app.add_subcommand(\"sub1\");\n+    std::vector<std::string> pos;\n+    sub1->add_option(\"args\", pos);\n+    app.add_subcommand(\"sub2\");\n+    app.add_subcommand(\"sub3\");\n+    sub1->subcommand_fallthrough(false);\n+    CHECK_FALSE(sub1->get_subcommand_fallthrough());\n+    args = {\"sub1\", \"sub2\", \"sub3\"};\n+    run();\n+    CHECK(pos.size() == 2);\n+}\n+\n TEST_CASE_METHOD(TApp, \"BadSubcommandSearch\", \"[subcom]\") {\n \n     auto *one = app.add_subcommand(\"one\");\n",
  "problem_statement": "Positional is treated as a sub-command\nCLI11: Version 2.4.1\r\n\r\nI have this setup:\r\n\r\n```c++\r\nint main() {\r\n    CLI::App cli{};\r\n    cli.set_help_flag();\r\n    cli.add_subcommand(\"foo\", \"Does foo\")->parse_complete_callback([&](){std::cout << \"=== Foo doing foo\" << std::endl;});\r\n    cli.add_subcommand(\"bar\", \"Does bar\")->parse_complete_callback([&](){std::cout << \"=== Bar doing bar\" << std::endl;});\r\n    auto *help_cmd = cli.add_subcommand(\"help\", \"Does help\");\r\n    std::string help_for_command;\r\n    auto *help_opt = help_cmd->add_option(\"command\", help_for_command, \"Command to print help for\")->expected(0, 1);\r\n    help_cmd->parse_complete_callback([&]() {\r\n            if (*help_opt) {\r\n                std::cout << \"Print help for \" << help_for_command << std::endl;\r\n            } else {\r\n                CLI::Formatter fmt{};\r\n                std::cout << fmt.make_help(&cli, \"\", CLI::AppFormatMode::Normal) << std::endl;\r\n            }\r\n    });\r\n\r\n    std::cout << \"=> \" << std::flush;\r\n    for (std::string line; std::getline(std::cin, line);) {\r\n        try {\r\n            cli.parse(line);\r\n        } catch (const CLI::ParseError &e) {\r\n            std::cout << e.what() << std::endl;\r\n            std::cout << cli.help();\r\n        }\r\n        std::cout << \"=> \" << std::flush;\r\n    }\r\n}\r\n```\r\n\r\nGiven the above setup, here are some behaviors that I expect:\r\n```\r\nScenario 1\r\nWhen help is called without arguments\r\nThen the help string of all commands is printed\r\n\r\nScenario 2\r\nWhen help is called with one argument\r\nAnd   the argument is a registered (sub)command\r\nThen the help string of this command is printed\r\n\r\nScenario 3\r\nWhen help is called with one argument\r\nAnd   the argument is not a registered (sub)command\r\nThen the help string of all commands is printed\r\n```\r\n\r\nHowever, I get the below output for each scenario:\r\n\r\nScenario 1 ðŸŸ¢ \r\n```shell\r\n=>help\r\n help\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\n=>\r\n```\r\n\r\nScenario 2 ðŸ”´ \r\nNot only the positional is not recognised, it is executed as a sucommand.\r\n```shell\r\n=>help foo\r\n help foo\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\n=== Foo doing foo\r\n=>\r\n```\r\n\r\n```shell\r\n=>help help\r\n help help\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\n=>\r\n```\r\n\r\nScenario 3 ðŸ”´ \r\n```shell\r\n=>help other\r\n help other\r\nUsage: [SUBCOMMAND]\r\n\r\nSubcommands:\r\n  foo                         Does foo\r\n  bar                         Does bar\r\n  help                        Does help\r\n\r\nThe following argument was not expected: other\r\nDoes help\r\nUsage: help [command]\r\n\r\nPositionals:\r\n  command TEXT                Command to print help for\r\n```\r\n\r\n\r\nI've tried using `fallthrough(false)` for `help` command, but with no luck.\r\nHow could I implement my use case?\n",
  "hints_text": "I think what you want here is to use `prefix_command()` on the help subcommand.  That will force everything that comes after it to be a positional argument.  \r\n\r\nOtherwise subcommands would take precedence over positionals \nThanks for your timely response.\r\n\r\nI've tried it as such, but it didn't help:\r\n\r\n```c++\r\nint main() {\r\n    CLI::App cli{};\r\n    cli.set_help_flag();\r\n    cli.add_subcommand(\"foo\", \"Does foo\")->parse_complete_callback([&](){std::cout << \"=== Foo doing foo\" << std::endl;});\r\n    cli.add_subcommand(\"bar\", \"Does bar\")->parse_complete_callback([&](){std::cout << \"=== Bar doing bar\" << std::endl;});\r\n    auto *help_cmd = cli.add_subcommand(\"help\", \"Does help\");\r\n    std::string help_for_command;\r\n    auto *help_opt = help_cmd->add_option(\"command\", help_for_command, \"Command to print help for\")->expected(0, 1);\r\n    help_cmd\r\n        ->prefix_command()\r\n        ->parse_complete_callback([&]() {\r\n            if (*help_opt) {\r\n                std::cout << \"Print help for \" << help_for_command << std::endl;\r\n            } else {\r\n                CLI::Formatter fmt{};\r\n                std::cout << fmt.make_help(&cli, \"\", CLI::AppFormatMode::Normal) << std::endl;\r\n            }\r\n    });\r\n    ...\r\n}\r\n```\r\n\r\nIs there anything that I'm missing on the above snippet?\nI played with it a bit.   There does seem to be a gap in configuration capability for this scenario.\r\nI believe this code does what you want\r\n```C++\r\nint main() {\r\n    CLI::App cli{};\r\n    cli.set_help_flag();\r\n    cli.add_subcommand(\"foo\", \"Does foo\")->parse_complete_callback([&](){std::cout << \"=== Foo doing foo\" << std::endl;});\r\n    cli.add_subcommand(\"bar\", \"Does bar\")->parse_complete_callback([&](){std::cout << \"=== Bar doing bar\" << std::endl;});\r\n    auto *help_cmd = cli.add_subcommand(\"help\", \"Does help\");\r\n    std::string help_for_command;\r\n    auto *help_opt = help_cmd->add_option(\"command\", help_for_command, \"Command to print help for\");\r\n    help_cmd\r\n        ->preparse_callback([&](size_t values){help_opt->required(values>0);})\r\n        ->parse_complete_callback([&]() {\r\n        if (*help_opt) {\r\n            std::cout << \"Print help for \" << help_for_command << std::endl;\r\n        } else {\r\n            CLI::Formatter fmt{};\r\n            std::cout << fmt.make_help(&cli, \"\", CLI::AppFormatMode::Normal) << std::endl;\r\n        }\r\n            });\r\n    std::cout << \"=> \" << std::flush;\r\n    for (std::string line; std::getline(std::cin, line);) {\r\n        try {\r\n            cli.parse(line);\r\n        } catch (const CLI::ParseError &e) {\r\n            std::cout << e.what() << std::endl;\r\n            std::cout << cli.help();\r\n        }\r\n        std::cout << \"=> \" << std::flush;\r\n    }\r\n    return 0;\r\n}\r\n```\r\nbut it isn't obvious, so there might be a missing option on subcommands that needs to get added for situations like this.  The use for prefix_command is slightly different, so doesn't work in this case.  What the above code does is take advantage of the preparse callback and the fact that required positionals take precedence over subcommands.  \nThank you very much. That seemed to do the trick.\r\n\r\nAn option that does this exact thing would be quite handy.",
  "created_at": "2024-10-07T16:06:38Z"
}
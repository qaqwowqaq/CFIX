{
  "repo": "redis/hiredis",
  "pull_number": 1215,
  "instance_id": "redis__hiredis-1215",
  "issue_numbers": [
    "1185"
  ],
  "base_commit": "e07ae7d3b6248be8be842eca3e1e97595a17aa1a",
  "patch": "diff --git a/.gitignore b/.gitignore\nindex 056959ffe..c223f299a 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -7,3 +7,4 @@\n /*.pc\n *.dSYM\n tags\n+compile_commands.json\ndiff --git a/net.c b/net.c\nindex c7d827139..8b7831e35 100644\n--- a/net.c\n+++ b/net.c\n@@ -173,6 +173,10 @@ int redisKeepAlive(redisContext *c, int interval) {\n     int val = 1;\n     redisFD fd = c->fd;\n \n+    /* TCP_KEEPALIVE makes no sense with AF_UNIX connections */\n+    if (c->connection_type == REDIS_CONN_UNIX)\n+        return REDIS_ERR;\n+\n #ifndef _WIN32\n     if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1){\n         __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));\n",
  "test_patch": "diff --git a/test.c b/test.c\nindex 45914af42..897daf8fe 100644\n--- a/test.c\n+++ b/test.c\n@@ -431,6 +431,24 @@ static void test_tcp_options(struct config cfg) {\n     redisFree(c);\n }\n \n+static void test_unix_keepalive(struct config cfg) {\n+    redisContext *c;\n+    redisReply *r;\n+\n+    c = do_connect(cfg);\n+\n+    test(\"Setting TCP_KEEPALIVE on a unix socket returns an error: \");\n+    test_cond(redisEnableKeepAlive(c) == REDIS_ERR && c->err == 0);\n+\n+    test(\"Setting TCP_KEEPALIVE on a unix socket doesn't break the connection: \");\n+    r = redisCommand(c, \"PING\");\n+    test_cond(r != NULL && r->type == REDIS_REPLY_STATUS && r->len == 4 &&\n+              !memcmp(r->str, \"PONG\", 4));\n+    freeReplyObject(r);\n+\n+    redisFree(c);\n+}\n+\n static void test_reply_reader(void) {\n     redisReader *reader;\n     void *reply, *root;\n@@ -2363,6 +2381,7 @@ int main(int argc, char **argv) {\n         test_blocking_connection_timeouts(cfg);\n         test_blocking_io_errors(cfg);\n         test_invalid_timeout_errors(cfg);\n+        test_unix_keepalive(cfg);\n         if (throughput) test_throughput(cfg);\n     } else {\n         test_skipped();\n",
  "problem_statement": "Improvement: More specific error message when calling redisEnableKeepAlive() with unix socket\nUnix sockets don't support setsockopt `TCP_KEEPALIVE` and currently the error message is set to `strerror(errno)`: \"Operation not supported\". While this is totally valid I suggest to explicitly catch this case and return a more specific error message. E.g.:\r\n\r\n```\r\ndiff --git a/net.c b/net.c\r\nindex ec96412..114f597 100644\r\n--- a/net.c\r\n+++ b/net.c\r\n@@ -172,6 +172,11 @@ int redisKeepAlive(redisContext *c, int interval) {\r\n     int val = 1;\r\n     redisFD fd = c->fd;\r\n \r\n+    if (c->connection_type == REDIS_CONN_UNIX) {\r\n+        __redisSetError(c,REDIS_ERR_OTHER,\"Keepalive not supported for unix socket\");\r\n+        return REDIS_ERR;\r\n+    }\r\n+\r\n #ifndef _WIN32\r\n     if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1){\r\n         __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));\r\n```\r\n\r\nOr maybe it would also be an option to only print a warning in this case. What do you think?\n",
  "hints_text": "It's actually a good question.\r\n\r\nTypically I handle this in the application logic, but I don't see any harm in providing a more helpful error message.  I don't think we really have the option to print an error though.  We'd need to stay consistent and set the error in the context like you're suggesting.\r\n\r\nEdit:  An alternative approach would be to treat the operation as a no-op if it's an `AF_UNIX` connection.",
  "created_at": "2023-07-31T22:54:21Z"
}
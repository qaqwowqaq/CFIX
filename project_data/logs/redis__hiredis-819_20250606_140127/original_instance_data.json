{
  "repo": "redis/hiredis",
  "pull_number": 819,
  "instance_id": "redis__hiredis-819",
  "issue_numbers": [
    "815"
  ],
  "base_commit": "c8999c66024b0de347adecb774d14963c08a66db",
  "patch": "diff --git a/async.c b/async.c\nindex 6990e86cb..68a656ffd 100644\n--- a/async.c\n+++ b/async.c\n@@ -374,7 +374,7 @@ static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply,\n \n     /* Custom reply functions are not supported for pub/sub. This will fail\n      * very hard when they are used... */\n-    if (reply->type == REDIS_REPLY_ARRAY) {\n+    if (reply->type == REDIS_REPLY_ARRAY || reply->type == REDIS_REPLY_PUSH) {\n         assert(reply->elements >= 2);\n         assert(reply->element[0]->type == REDIS_REPLY_STRING);\n         stype = reply->element[0]->str;\ndiff --git a/hiredis.c b/hiredis.c\nindex deb65a929..1c9e8ae5a 100644\n--- a/hiredis.c\n+++ b/hiredis.c\n@@ -97,6 +97,7 @@ void freeReplyObject(void *reply) {\n     case REDIS_REPLY_ARRAY:\n     case REDIS_REPLY_MAP:\n     case REDIS_REPLY_SET:\n+    case REDIS_REPLY_PUSH:\n         if (r->element != NULL) {\n             for (j = 0; j < r->elements; j++)\n                 freeReplyObject(r->element[j]);\n@@ -155,7 +156,8 @@ static void *createStringObject(const redisReadTask *task, char *str, size_t len\n         parent = task->parent->obj;\n         assert(parent->type == REDIS_REPLY_ARRAY ||\n                parent->type == REDIS_REPLY_MAP ||\n-               parent->type == REDIS_REPLY_SET);\n+               parent->type == REDIS_REPLY_SET ||\n+               parent->type == REDIS_REPLY_PUSH);\n         parent->element[task->idx] = r;\n     }\n     return r;\n@@ -201,7 +203,8 @@ static void *createIntegerObject(const redisReadTask *task, long long value) {\n         parent = task->parent->obj;\n         assert(parent->type == REDIS_REPLY_ARRAY ||\n                parent->type == REDIS_REPLY_MAP ||\n-               parent->type == REDIS_REPLY_SET);\n+               parent->type == REDIS_REPLY_SET ||\n+               parent->type == REDIS_REPLY_PUSH);\n         parent->element[task->idx] = r;\n     }\n     return r;\ndiff --git a/read.c b/read.c\nindex 835eb65fb..4924014d7 100644\n--- a/read.c\n+++ b/read.c\n@@ -250,7 +250,8 @@ static void moveToNextTask(redisReader *r) {\n         prv = r->task[r->ridx-1];\n         assert(prv->type == REDIS_REPLY_ARRAY ||\n                prv->type == REDIS_REPLY_MAP ||\n-               prv->type == REDIS_REPLY_SET);\n+               prv->type == REDIS_REPLY_SET ||\n+               prv->type == REDIS_REPLY_PUSH);\n         if (cur->idx == prv->elements-1) {\n             r->ridx--;\n         } else {\n@@ -562,6 +563,9 @@ static int processItem(redisReader *r) {\n             case '=':\n                 cur->type = REDIS_REPLY_VERB;\n                 break;\n+            case '>':\n+                cur->type = REDIS_REPLY_PUSH;\n+                break;\n             default:\n                 __redisReaderSetErrorProtocolByte(r,*p);\n                 return REDIS_ERR;\n@@ -587,6 +591,7 @@ static int processItem(redisReader *r) {\n     case REDIS_REPLY_ARRAY:\n     case REDIS_REPLY_MAP:\n     case REDIS_REPLY_SET:\n+    case REDIS_REPLY_PUSH:\n         return processAggregateItem(r);\n     default:\n         assert(NULL);\n",
  "test_patch": "diff --git a/test.c b/test.c\nindex 8e45e78d8..1d38caa6f 100644\n--- a/test.c\n+++ b/test.c\n@@ -488,6 +488,21 @@ static void test_reply_reader(void) {\n          !memcmp(((redisReply*)reply)->str,\"LOLWUT\", 6));\n     freeReplyObject(reply);\n     redisReaderFree(reader);\n+\n+    /* RESP3 push messages (Github issue #815) */\n+    test(\"Can parse RESP3 push messages: \");\n+    reader = redisReaderCreate();\n+    redisReaderFeed(reader,(char*)\">2\\r\\n$6\\r\\nLOLWUT\\r\\n:42\\r\\n\",21);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret == REDIS_OK &&\n+        ((redisReply*)reply)->type == REDIS_REPLY_PUSH &&\n+        ((redisReply*)reply)->elements == 2 &&\n+        ((redisReply*)reply)->element[0]->type == REDIS_REPLY_STRING &&\n+        !memcmp(((redisReply*)reply)->element[0]->str,\"LOLWUT\",6) &&\n+        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&\n+        ((redisReply*)reply)->element[1]->integer == 42);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n }\n \n static void test_free_null(void) {\n",
  "problem_statement": "Asynchronous PSUBSCRIBE command fails when using RESP3\nThe following toy implementation shows how execution of asynchronous `PSUBSCRIBE` command using current `RESP3` support in master (i.e. https://github.com/redis/hiredis/pull/805 already merged) fails with error `Protocol error, got \">\" as reply type byte`. This has been tested using Redis Server 6.0.3. Same logic using RESP2 works as expected.\r\n\r\n```\r\n// gcc test.c -o test -Wall -lhiredis -lev\r\n// redis-server --port 6400\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <assert.h>\r\n#include <hiredis/hiredis.h>\r\n#include <hiredis/async.h>\r\n#include <hiredis/adapters/libev.h>\r\n\r\n#define HOST \"127.0.0.1\"\r\n#define PORT 6400\r\n#define PROTOCOL 3\r\n\r\nstatic void\r\nconnectCallback(const redisAsyncContext *ctx, int status)\r\n{\r\n    if (status != REDIS_OK) {\r\n        printf(\"CONNECT CB: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        exit(1);\r\n    }\r\n}\r\n\r\nstatic void\r\ndisconnectCallback(const redisAsyncContext *ctx, int status)\r\n{\r\n    if (status != REDIS_OK) {\r\n        printf(\"DISCONNECT CB: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        exit(1);\r\n    }\r\n}\r\n\r\nstatic void\r\nhelloCallback(redisAsyncContext *context, void *r, void *s)\r\n{\r\n    redisReply *reply = r;\r\n    assert(\r\n        reply != NULL &&\r\n        (reply->type == REDIS_REPLY_ARRAY ||\r\n         reply->type == REDIS_REPLY_MAP));\r\n    printf(\"HELLO CB: %d\\n\", reply->type);\r\n}\r\n\r\nstatic void\r\npsubscribeCallback(redisAsyncContext *context, void *r, void *s)\r\n{\r\n    redisReply *reply = r;\r\n    if (reply != NULL) {\r\n        printf(\"PSUBSCRIBE CB: %d\\n\", reply->type);\r\n    }\r\n}\r\n\r\nstatic redisAsyncContext *\r\nconnect(unsigned version, struct ev_loop *loop)\r\n{\r\n    redisAsyncContext *ctx = redisAsyncConnect(HOST, PORT);\r\n    assert(ctx != NULL);\r\n    if (ctx->err) {\r\n        printf(\"CONNECT: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        exit(1);\r\n    }\r\n\r\n    redisLibevAttach(loop, ctx);\r\n    redisAsyncSetConnectCallback(ctx, connectCallback);\r\n    redisAsyncSetDisconnectCallback(ctx, disconnectCallback);\r\n\r\n    if (redisAsyncCommand(ctx, helloCallback, NULL, \"HELLO %d\", version) != REDIS_OK) {\r\n        if (ctx->err) {\r\n            printf(\"HELLO: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        }\r\n        exit(1);\r\n    }\r\n\r\n    if (redisAsyncCommand(ctx, psubscribeCallback, NULL, \"PSUBSCRIBE foo bar\") != REDIS_OK) {\r\n        if (ctx->err) {\r\n            printf(\"PSUBSCRIBE: %s\\n\", ctx->err ? ctx->errstr : \"-\");\r\n        }\r\n        exit(1);\r\n    }\r\n\r\n    return ctx;\r\n}\r\n\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\n    struct ev_loop *loop = ev_loop_new(EVFLAG_AUTO);\r\n    assert(loop != NULL);\r\n    assert(connect(PROTOCOL, loop) != NULL);\r\n    while (1) {\r\n        ev_loop(loop, EVRUN_NOWAIT);\r\n        usleep(500000);\r\n    }\r\n}\r\n```\n",
  "hints_text": "Thanks, I'll take a look.\r\n\r\nActually I think `>` is RESP3 for out-of-band \"push\" notifications.  This might be a non-trivial change.\r\n\r\nWe should probably do it but it will warrant discussion around whether it's out of scope for a \"minimalist\" Redis library.\r\n\r\nEdit:  The bug also exists in `redis-cli` on current unstable:\r\n\r\n```bash\r\n$ redis-cli \r\n127.0.0.1:6379> hello 3\r\n1# \"server\" => \"redis\"\r\n2# \"version\" => \"999.999.999\"\r\n3# \"proto\" => (integer) 3\r\n4# \"id\" => (integer) 5\r\n5# \"mode\" => \"standalone\"\r\n6# \"role\" => \"master\"\r\n7# \"modules\" => (empty array)\r\n127.0.0.1:6379> subscribe foo\r\nReading messages... (press Ctrl-C to quit)\r\nError: Protocol error, got \">\" as reply type byte\r\n```",
  "created_at": "2020-05-21T16:17:44Z"
}
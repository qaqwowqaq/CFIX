{
  "repo": "nanomsg/nng",
  "pull_number": 613,
  "instance_id": "nanomsg__nng-613",
  "issue_numbers": [
    "616"
  ],
  "base_commit": "ccc24a8e508131a2226474642a038baaa2cbcc8c",
  "patch": "diff --git a/src/core/aio.c b/src/core/aio.c\nindex 40638bced..294a0b923 100644\n--- a/src/core/aio.c\n+++ b/src/core/aio.c\n@@ -217,11 +217,17 @@ void\n nni_aio_stop(nni_aio *aio)\n {\n \tif (aio != NULL) {\n+\t\tnni_aio_cancelfn cancelfn;\n+\n \t\tnni_mtx_lock(&nni_aio_lk);\n-\t\taio->a_stop = true;\n+\t\tcancelfn           = aio->a_prov_cancel;\n+\t\taio->a_prov_cancel = NULL;\n+\t\taio->a_stop        = true;\n \t\tnni_mtx_unlock(&nni_aio_lk);\n \n-\t\tnni_aio_abort(aio, NNG_ECANCELED);\n+\t\tif (cancelfn != NULL) {\n+\t\t\tcancelfn(aio, NNG_ECANCELED);\n+\t\t}\n \n \t\tnni_aio_wait(aio);\n \t}\ndiff --git a/src/core/dialer.c b/src/core/dialer.c\nindex 34e908917..4b2f105db 100644\n--- a/src/core/dialer.c\n+++ b/src/core/dialer.c\n@@ -232,24 +232,18 @@ dialer_timer_cb(void *arg)\n static void\n dialer_connect_cb(void *arg)\n {\n-\tnni_dialer *d = arg;\n-\tnni_pipe *  p;\n+\tnni_dialer *d   = arg;\n \tnni_aio *   aio = d->d_con_aio;\n \tint         rv;\n \tbool        synch;\n \n-\tif ((rv = nni_aio_result(aio)) == 0) {\n-\t\tvoid *data = nni_aio_get_output(aio, 0);\n-\t\tNNI_ASSERT(data != NULL);\n-\t\trv = nni_pipe_create(&p, d->d_sock, d->d_tran, data);\n-\t}\n \tnni_mtx_lock(&d->d_mtx);\n \tsynch = d->d_synch;\n \tnni_mtx_unlock(&d->d_mtx);\n \n-\tswitch (rv) {\n+\tswitch ((rv = nni_aio_result(aio))) {\n \tcase 0:\n-\t\tnni_dialer_add_pipe(d, p);\n+\t\tnni_dialer_add_pipe(d, nni_aio_get_output(aio, 0));\n \t\tbreak;\n \tcase NNG_ECLOSED:   // No further action.\n \tcase NNG_ECANCELED: // No further action.\ndiff --git a/src/core/listener.c b/src/core/listener.c\nindex debfa5f1c..17062d6eb 100644\n--- a/src/core/listener.c\n+++ b/src/core/listener.c\n@@ -181,6 +181,8 @@ nni_listener_close(nni_listener *l)\n \t}\n \tl->l_closed = true;\n \tnni_mtx_unlock(&listeners_lk);\n+\tnni_aio_close(l->l_acc_aio);\n+\tnni_aio_close(l->l_tmo_aio);\n \n \t// Remove us from the table so we cannot be found.\n \t// This is done fairly early in the teardown process.\n@@ -228,28 +230,25 @@ listener_timer_cb(void *arg)\n static void\n listener_accept_cb(void *arg)\n {\n-\tnni_listener *l = arg;\n-\tnni_pipe *    p;\n+\tnni_listener *l   = arg;\n \tnni_aio *     aio = l->l_acc_aio;\n-\tint           rv;\n \n-\tif ((rv = nni_aio_result(aio)) == 0) {\n-\t\tvoid *data = nni_aio_get_output(aio, 0);\n-\t\tNNI_ASSERT(data != NULL);\n-\t\trv = nni_pipe_create(&p, l->l_sock, l->l_tran, data);\n-\t}\n-\tswitch (rv) {\n+\tswitch (nni_aio_result(aio)) {\n \tcase 0:\n-\t\tnni_listener_add_pipe(l, p);\n+\t\tnni_listener_add_pipe(l, nni_aio_get_output(aio, 0));\n \t\tlistener_accept_start(l);\n \t\tbreak;\n \tcase NNG_ECONNABORTED: // remote condition, no cooldown\n \tcase NNG_ECONNRESET:   // remote condition, no cooldown\n+\tcase NNG_EPEERAUTH:    // peer validation failure\n \t\tlistener_accept_start(l);\n \t\tbreak;\n \tcase NNG_ECLOSED:   // no further action\n \tcase NNG_ECANCELED: // no further action\n \t\tbreak;\n+\tcase NNG_ENOMEM:\n+\tcase NNG_ENOFILES:\n+\tcase NNG_ENOSPC:\n \tdefault:\n \t\t// We don't really know why we failed, but we backoff\n \t\t// here. This is because errors here are probably due\ndiff --git a/src/core/pipe.c b/src/core/pipe.c\nindex 4f50ac7c4..374c45c84 100644\n--- a/src/core/pipe.c\n+++ b/src/core/pipe.c\n@@ -75,9 +75,6 @@ pipe_destroy(nni_pipe *p)\n \t}\n \tnni_mtx_unlock(&nni_pipe_lk);\n \n-\t// Wait for neg callbacks to finish. (Already closed).\n-\tnni_aio_stop(p->p_start_aio);\n-\n \tif (p->p_proto_data != NULL) {\n \t\tp->p_proto_ops.pipe_stop(p->p_proto_data);\n \t}\n@@ -93,7 +90,6 @@ pipe_destroy(nni_pipe *p)\n \tif (p->p_tran_data != NULL) {\n \t\tp->p_tran_ops.p_fini(p->p_tran_data);\n \t}\n-\tnni_aio_fini(p->p_start_aio);\n \tnni_cv_fini(&p->p_cv);\n \tnni_mtx_fini(&p->p_mtx);\n \tNNI_FREE_STRUCT(p);\n@@ -154,9 +150,6 @@ nni_pipe_send(nni_pipe *p, nni_aio *aio)\n void\n nni_pipe_close(nni_pipe *p)\n {\n-\t// abort any pending negotiation/start process.\n-\tnni_aio_close(p->p_start_aio);\n-\n \tnni_mtx_lock(&p->p_mtx);\n \tif (p->p_closed) {\n \t\t// We already did a close.\n@@ -178,49 +171,12 @@ nni_pipe_close(nni_pipe *p)\n \tnni_reap(&p->p_reap, (nni_cb) pipe_destroy, p);\n }\n \n-bool\n-nni_pipe_closed(nni_pipe *p)\n-{\n-\tbool rv;\n-\tnni_mtx_lock(&p->p_mtx);\n-\trv = p->p_closed;\n-\tnni_mtx_unlock(&p->p_mtx);\n-\treturn (rv);\n-}\n-\n uint16_t\n nni_pipe_peer(nni_pipe *p)\n {\n \treturn (p->p_tran_ops.p_peer(p->p_tran_data));\n }\n \n-static void\n-nni_pipe_start_cb(void *arg)\n-{\n-\tnni_pipe *p   = arg;\n-\tnni_sock *s   = p->p_sock;\n-\tnni_aio * aio = p->p_start_aio;\n-\n-\tif (nni_aio_result(aio) != 0) {\n-\t\tnni_pipe_close(p);\n-\t\treturn;\n-\t}\n-\n-\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_PRE);\n-\tif (nni_pipe_closed(p)) {\n-\t\tnni_pipe_close(p);\n-\t\treturn;\n-\t}\n-\n-\tif ((p->p_proto_ops.pipe_start(p->p_proto_data) != 0) ||\n-\t    nni_sock_closing(s)) {\n-\t\tnni_pipe_close(p);\n-\t\treturn;\n-\t}\n-\n-\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_POST);\n-}\n-\n int\n nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n {\n@@ -228,6 +184,7 @@ nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n \tint                 rv;\n \tvoid *              sdata = nni_sock_proto_data(sock);\n \tnni_proto_pipe_ops *pops  = nni_sock_proto_pipe_ops(sock);\n+\tuint64_t            id;\n \n \tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n \t\t// In this case we just toss the pipe...\n@@ -236,7 +193,6 @@ nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n \t}\n \n \t// Make a private copy of the transport ops.\n-\tp->p_start_aio  = NULL;\n \tp->p_tran_ops   = *tran->tran_pipe;\n \tp->p_tran_data  = tdata;\n \tp->p_proto_ops  = *pops;\n@@ -253,14 +209,11 @@ nni_pipe_create(nni_pipe **pp, nni_sock *sock, nni_tran *tran, void *tdata)\n \tnni_mtx_init(&p->p_mtx);\n \tnni_cv_init(&p->p_cv, &nni_pipe_lk);\n \n-\tif ((rv = nni_aio_init(&p->p_start_aio, nni_pipe_start_cb, p)) == 0) {\n-\t\tuint64_t id;\n-\t\tnni_mtx_lock(&nni_pipe_lk);\n-\t\tif ((rv = nni_idhash_alloc(nni_pipes, &id, p)) == 0) {\n-\t\t\tp->p_id = (uint32_t) id;\n-\t\t}\n-\t\tnni_mtx_unlock(&nni_pipe_lk);\n+\tnni_mtx_lock(&nni_pipe_lk);\n+\tif ((rv = nni_idhash_alloc(nni_pipes, &id, p)) == 0) {\n+\t\tp->p_id = (uint32_t) id;\n \t}\n+\tnni_mtx_unlock(&nni_pipe_lk);\n \n \tif ((rv != 0) ||\n \t    ((rv = pops->pipe_init(&p->p_proto_data, p, sdata)) != 0)) {\n@@ -296,16 +249,6 @@ nni_pipe_getopt(\n \treturn (NNG_ENOTSUP);\n }\n \n-void\n-nni_pipe_start(nni_pipe *p)\n-{\n-\tif (p->p_tran_ops.p_start == NULL) {\n-\t\tnni_aio_finish(p->p_start_aio, 0, 0);\n-\t} else {\n-\t\tp->p_tran_ops.p_start(p->p_tran_data, p->p_start_aio);\n-\t}\n-}\n-\n void *\n nni_pipe_get_proto_data(nni_pipe *p)\n {\ndiff --git a/src/core/pipe.h b/src/core/pipe.h\nindex 1d73ce517..1e2f2b5d6 100644\n--- a/src/core/pipe.h\n+++ b/src/core/pipe.h\n@@ -59,11 +59,6 @@ extern uint32_t nni_pipe_listener_id(nni_pipe *);\n // nni_pipe_dialer_id returns the dialer id for the pipe (or 0 if none).\n extern uint32_t nni_pipe_dialer_id(nni_pipe *);\n \n-// nni_pipe_closed returns true if nni_pipe_close was called.\n-// (This is used by the socket to determine if user closed the pipe\n-// during callback.)\n-extern bool nni_pipe_closed(nni_pipe *);\n-\n // nni_pipe_rele releases the hold on the pipe placed by nni_pipe_find.\n extern void nni_pipe_rele(nni_pipe *);\n \ndiff --git a/src/core/socket.c b/src/core/socket.c\nindex f4e59af50..0fa776f13 100644\n--- a/src/core/socket.c\n+++ b/src/core/socket.c\n@@ -399,16 +399,6 @@ nni_sock_rele(nni_sock *s)\n \tnni_mtx_unlock(&sock_lk);\n }\n \n-bool\n-nni_sock_closing(nni_sock *s)\n-{\n-\tbool rv;\n-\tnni_mtx_lock(&s->s_mx);\n-\trv = s->s_closing;\n-\tnni_mtx_unlock(&s->s_mx);\n-\treturn (rv);\n-}\n-\n static void\n sock_destroy(nni_sock *s)\n {\n@@ -1382,16 +1372,36 @@ nni_dialer_timer_start(nni_dialer *d)\n \tnni_mtx_unlock(&s->s_mx);\n }\n \n+static void\n+pipe_start(nni_pipe *p)\n+{\n+\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_PRE);\n+\n+\t// As the callback above that would close the pipe runs on\n+\t// this thread, we can skip the lock.\n+\tif (p->p_closed) {\n+\t\treturn;\n+\t}\n+\n+\tif (p->p_proto_ops.pipe_start(p->p_proto_data) != 0) {\n+\t\tnni_pipe_close(p);\n+\t\treturn;\n+\t}\n+\n+\tnni_pipe_run_cb(p, NNG_PIPE_EV_ADD_POST);\n+}\n+\n void\n-nni_dialer_add_pipe(nni_dialer *d, nni_pipe *p)\n+nni_dialer_add_pipe(nni_dialer *d, void *tpipe)\n {\n \tnni_sock *s = d->d_sock;\n+\tnni_pipe *p;\n \n \tnni_mtx_lock(&s->s_mx);\n \n-\tif (s->s_closed || d->d_closing) {\n+\tif (s->s_closed || d->d_closing ||\n+\t    (nni_pipe_create(&p, d->d_sock, d->d_tran, tpipe) != 0)) {\n \t\tnni_mtx_unlock(&s->s_mx);\n-\t\tnni_pipe_close(p);\n \t\treturn;\n \t}\n \n@@ -1403,7 +1413,7 @@ nni_dialer_add_pipe(nni_dialer *d, nni_pipe *p)\n \tnni_mtx_unlock(&s->s_mx);\n \n \t// Start the initial negotiation I/O...\n-\tnni_pipe_start(p);\n+\tpipe_start(p);\n }\n \n static void\n@@ -1473,14 +1483,15 @@ nni_dialer_reap(nni_dialer *d)\n }\n \n void\n-nni_listener_add_pipe(nni_listener *l, nni_pipe *p)\n+nni_listener_add_pipe(nni_listener *l, void *tpipe)\n {\n \tnni_sock *s = l->l_sock;\n+\tnni_pipe *p;\n \n \tnni_mtx_lock(&s->s_mx);\n-\tif (s->s_closed || l->l_closing) {\n+\tif (s->s_closed || l->l_closing ||\n+\t    (nni_pipe_create(&p, l->l_sock, l->l_tran, tpipe) != 0)) {\n \t\tnni_mtx_unlock(&s->s_mx);\n-\t\tnni_pipe_close(p);\n \t\treturn;\n \t}\n \tp->p_listener = l;\n@@ -1489,7 +1500,7 @@ nni_listener_add_pipe(nni_listener *l, nni_pipe *p)\n \tnni_mtx_unlock(&s->s_mx);\n \n \t// Start the initial negotiation I/O...\n-\tnni_pipe_start(p);\n+\tpipe_start(p);\n }\n \n static void\n@@ -1600,7 +1611,10 @@ nni_pipe_remove(nni_pipe *p)\n \tp->p_dialer   = NULL;\n \tif ((d != NULL) && (d->d_pipe == p)) {\n \t\td->d_pipe = NULL;\n-\t\tdialer_timer_start_locked(d); // Kick the timer to redial.\n+\t\tif (!s->s_closing) {\n+\t\t\tdialer_timer_start_locked(\n+\t\t\t    d); // Kick the timer to redial.\n+\t\t}\n \t}\n \tif (s->s_closing) {\n \t\tnni_cv_wake(&s->s_cv);\ndiff --git a/src/core/socket.h b/src/core/socket.h\nindex 4b9c46429..cebe87ca4 100644\n--- a/src/core/socket.h\n+++ b/src/core/socket.h\n@@ -62,8 +62,6 @@ extern uint32_t nni_sock_flags(nni_sock *);\n // should be executed.\n extern void nni_sock_set_pipe_cb(nni_sock *sock, int, nng_pipe_cb, void *);\n \n-extern bool nni_sock_closing(nni_sock *sock);\n-\n // nni_ctx_open is used to open/create a new context structure.\n // Contexts are not supported by most protocols, but for those that do,\n // this can offer some improvements for massive concurrency/scalability.\ndiff --git a/src/core/sockimpl.h b/src/core/sockimpl.h\nindex 569e5caed..29e83f7a0 100644\n--- a/src/core/sockimpl.h\n+++ b/src/core/sockimpl.h\n@@ -78,7 +78,6 @@ struct nni_pipe {\n \tnni_mtx            p_mtx;\n \tnni_cv             p_cv;\n \tnni_reap_item      p_reap;\n-\tnni_aio *          p_start_aio;\n };\n \n extern int  nni_sock_add_dialer(nni_sock *, nni_dialer *);\n@@ -87,14 +86,14 @@ extern void nni_sock_remove_dialer(nni_sock *, nni_dialer *);\n extern int  nni_sock_add_listener(nni_sock *, nni_listener *);\n extern void nni_sock_remove_listener(nni_sock *, nni_listener *);\n \n-extern void nni_dialer_add_pipe(nni_dialer *, nni_pipe *);\n+extern void nni_dialer_add_pipe(nni_dialer *, void *);\n extern void nni_dialer_shutdown(nni_dialer *);\n extern void nni_dialer_reap(nni_dialer *);\n extern void nni_dialer_destroy(nni_dialer *);\n extern void nni_dialer_timer_start(nni_dialer *);\n extern void nni_dialer_close_rele(nni_dialer *);\n \n-extern void nni_listener_add_pipe(nni_listener *, nni_pipe *);\n+extern void nni_listener_add_pipe(nni_listener *, void *);\n extern void nni_listener_shutdown(nni_listener *);\n extern void nni_listener_reap(nni_listener *);\n extern void nni_listener_destroy(nni_listener *);\ndiff --git a/src/core/transport.h b/src/core/transport.h\nindex 257d232d5..458bfda4d 100644\n--- a/src/core/transport.h\n+++ b/src/core/transport.h\n@@ -30,7 +30,8 @@ enum nni_ep_mode {\n #define NNI_TRANSPORT_V1 0x54520001\n #define NNI_TRANSPORT_V2 0x54520002\n #define NNI_TRANSPORT_V3 0x54520003\n-#define NNI_TRANSPORT_VERSION NNI_TRANSPORT_V3\n+#define NNI_TRANSPORT_V4 0x54520004\n+#define NNI_TRANSPORT_VERSION NNI_TRANSPORT_V4\n \n // Option handlers.\n struct nni_tran_option {\n@@ -131,19 +132,12 @@ struct nni_tran_pipe_ops {\n \t// make further calls on the same pipe.\n \tvoid (*p_fini)(void *);\n \n-\t// p_start starts the pipe running.  This gives the transport a\n-\t// chance to hook into any transport specific negotiation\n-\t// phase. The pipe will not have its p_send or p_recv calls\n-\t// started, and will not be access by the \"socket\" until the\n-\t// pipe has indicated its readiness by finishing the aio.\n-\tvoid (*p_start)(void *, nni_aio *);\n-\n \t// p_stop stops the pipe, waiting for any callbacks that are\n \t// outstanding to complete.  This is done before tearing down\n \t// resources with p_fini.\n \tvoid (*p_stop)(void *);\n \n-\t// p_aio_send queues the message for transmit.  If this fails,\n+\t// p_send queues the message for transmit.  If this fails,\n \t// then the caller may try again with the same message (or free\n \t// it).  If the call succeeds, then the transport has taken\n \t// ownership of the message, and the caller may not use it\ndiff --git a/src/platform/posix/posix_ipcconn.c b/src/platform/posix/posix_ipcconn.c\nindex 2b46fb12e..539a00ba9 100644\n--- a/src/platform/posix/posix_ipcconn.c\n+++ b/src/platform/posix/posix_ipcconn.c\n@@ -47,6 +47,10 @@ ipc_conn_dowrite(nni_ipc_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->writeq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \n@@ -129,6 +133,10 @@ ipc_conn_doread(nni_ipc_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->readq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \ndiff --git a/src/platform/posix/posix_tcpconn.c b/src/platform/posix/posix_tcpconn.c\nindex c0352c552..cf85e8e8c 100644\n--- a/src/platform/posix/posix_tcpconn.c\n+++ b/src/platform/posix/posix_tcpconn.c\n@@ -43,6 +43,10 @@ tcp_conn_dowrite(nni_tcp_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->writeq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \n@@ -125,6 +129,10 @@ tcp_conn_doread(nni_tcp_conn *c)\n \tint      fd;\n \n \tif (c->closed || ((fd = nni_posix_pfd_fd(c->pfd)) < 0)) {\n+\t\twhile ((aio = nni_list_first(&c->readq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\t}\n \t\treturn;\n \t}\n \ndiff --git a/src/transport/ipc/ipc.c b/src/transport/ipc/ipc.c\nindex ee72d6d87..3d798d4c1 100644\n--- a/src/transport/ipc/ipc.c\n+++ b/src/transport/ipc/ipc.c\n@@ -23,14 +23,20 @@\n typedef struct ipctran_pipe     ipctran_pipe;\n typedef struct ipctran_dialer   ipctran_dialer;\n typedef struct ipctran_listener ipctran_listener;\n+typedef struct ipctran_ep       ipctran_ep;\n \n // ipc_pipe is one end of an IPC connection.\n struct ipctran_pipe {\n-\tnni_ipc_conn *conn;\n-\tuint16_t      peer;\n-\tuint16_t      proto;\n-\tsize_t        rcvmax;\n-\tnni_sockaddr  sa;\n+\tnni_ipc_conn *  conn;\n+\tuint16_t        peer;\n+\tuint16_t        proto;\n+\tsize_t          rcvmax;\n+\tnni_atomic_flag reaped;\n+\tnni_sockaddr    sa;\n+\tnni_list_node   node;\n+\tipctran_ep *    ep;\n+\tnni_reap_item   reap;\n+\tbool            closed;\n \n \tuint8_t txhead[1 + sizeof(uint64_t)];\n \tuint8_t rxhead[1 + sizeof(uint64_t)];\n@@ -41,32 +47,34 @@ struct ipctran_pipe {\n \n \tnni_list recvq;\n \tnni_list sendq;\n-\tnni_aio *user_negaio;\n+\tnni_aio *useraio;\n \tnni_aio *txaio;\n \tnni_aio *rxaio;\n-\tnni_aio *negaio;\n+\tnni_aio *negoaio;\n+\tnni_aio *connaio;\n \tnni_msg *rxmsg;\n \tnni_mtx  mtx;\n };\n \n+struct ipctran_ep {\n+\tnni_mtx       mtx;\n+\tnni_list      pipes;\n+\tbool          fini;\n+\tsize_t        rcvmax;\n+\tuint16_t      proto;\n+\tnni_cb        dtor;\n+\tnni_sockaddr  sa;\n+\tnni_reap_item reap;\n+};\n+\n struct ipctran_dialer {\n-\tnni_sockaddr    sa;\n+\tipctran_ep      ep;\n \tnni_ipc_dialer *dialer;\n-\tuint16_t        proto;\n-\tsize_t          rcvmax;\n-\tnni_aio *       aio;\n-\tnni_aio *       user_aio;\n-\tnni_mtx         mtx;\n };\n \n struct ipctran_listener {\n-\tnni_sockaddr      sa;\n+\tipctran_ep        ep;\n \tnni_ipc_listener *listener;\n-\tuint16_t          proto;\n-\tsize_t            rcvmax;\n-\tnni_aio *         aio;\n-\tnni_aio *         user_aio;\n-\tnni_mtx           mtx;\n };\n \n static void ipctran_pipe_send_start(ipctran_pipe *);\n@@ -74,8 +82,8 @@ static void ipctran_pipe_recv_start(ipctran_pipe *);\n static void ipctran_pipe_send_cb(void *);\n static void ipctran_pipe_recv_cb(void *);\n static void ipctran_pipe_nego_cb(void *);\n-static void ipctran_dialer_cb(void *);\n-static void ipctran_listener_cb(void *);\n+static void ipctran_pipe_conn_cb(void *);\n+static void ipctran_pipe_reap(ipctran_pipe *);\n \n static int\n ipctran_init(void)\n@@ -95,7 +103,8 @@ ipctran_pipe_close(void *arg)\n \n \tnni_aio_close(p->rxaio);\n \tnni_aio_close(p->txaio);\n-\tnni_aio_close(p->negaio);\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n \n \tnni_ipc_conn_close(p->conn);\n }\n@@ -105,19 +114,39 @@ ipctran_pipe_stop(void *arg)\n {\n \tipctran_pipe *p = arg;\n \n+\tnni_mtx_lock(&p->mtx);\n+\tp->closed = true;\n+\tnni_mtx_unlock(&p->mtx);\n+\n \tnni_aio_stop(p->rxaio);\n \tnni_aio_stop(p->txaio);\n-\tnni_aio_stop(p->negaio);\n+\tnni_aio_stop(p->negoaio);\n+\tnni_aio_stop(p->connaio);\n }\n \n static void\n ipctran_pipe_fini(void *arg)\n {\n \tipctran_pipe *p = arg;\n+\tipctran_ep *  ep;\n+\n+\tif (p == NULL) {\n+\t\treturn;\n+\t}\n+\tipctran_pipe_stop(p);\n+\tif ((ep = p->ep) != NULL) {\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tnni_list_remove(&ep->pipes, p);\n+\t\tif (ep->fini && nni_list_empty(&ep->pipes)) {\n+\t\t\tnni_reap(&ep->reap, ep->dtor, ep);\n+\t\t}\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t}\n \n \tnni_aio_fini(p->rxaio);\n \tnni_aio_fini(p->txaio);\n-\tnni_aio_fini(p->negaio);\n+\tnni_aio_fini(p->negoaio);\n+\tnni_aio_fini(p->connaio);\n \tif (p->conn != NULL) {\n \t\tnni_ipc_conn_fini(p->conn);\n \t}\n@@ -128,8 +157,16 @@ ipctran_pipe_fini(void *arg)\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+ipctran_pipe_reap(ipctran_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n+\t\tnni_reap(&p->reap, ipctran_pipe_fini, p);\n+\t}\n+}\n+\n static int\n-ipctran_pipe_init(ipctran_pipe **pipep, void *conn)\n+ipctran_pipe_init(ipctran_pipe **pipep, ipctran_ep *ep)\n {\n \tipctran_pipe *p;\n \tint           rv;\n@@ -138,51 +175,75 @@ ipctran_pipe_init(ipctran_pipe **pipep, void *conn)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&p->mtx);\n+\tNNI_LIST_NODE_INIT(&p->node);\n \tif (((rv = nni_aio_init(&p->txaio, ipctran_pipe_send_cb, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->rxaio, ipctran_pipe_recv_cb, p)) != 0) ||\n-\t    ((rv = nni_aio_init(&p->negaio, ipctran_pipe_nego_cb, p)) != 0)) {\n-\t\tipctran_pipe_fini(p);\n+\t    ((rv = nni_aio_init(&p->negoaio, ipctran_pipe_nego_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->connaio, ipctran_pipe_conn_cb, p)) != 0)) {\n+\t\tipctran_pipe_reap(p);\n \t\treturn (rv);\n \t}\n \tnni_aio_list_init(&p->sendq);\n \tnni_aio_list_init(&p->recvq);\n \n-\tp->conn = conn;\n-#if 0\n-\tp->proto              = ep->proto;\n-\tp->rcvmax             = ep->rcvmax;\n-\tp->sa.s_ipc.sa_family = NNG_AF_IPC;\n-\tp->sa                 = ep->sa;\n-#endif\n+\tnni_list_append(&ep->pipes, p);\n+\tp->ep     = ep;\n+\tp->proto  = ep->proto;\n+\tp->rcvmax = ep->rcvmax;\n+\tp->sa     = ep->sa;\n+\n \t*pipep = p;\n \treturn (0);\n }\n \n static void\n-ipctran_pipe_nego_cancel(nni_aio *aio, int rv)\n+ipctran_pipe_conn_cb(void *arg)\n {\n-\tipctran_pipe *p = nni_aio_get_prov_data(aio);\n+\tipctran_pipe *p   = arg;\n+\tnni_aio *     aio = p->connaio;\n+\tnni_iov       iov;\n+\tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n-\tif (p->user_negaio != aio) {\n-\t\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\tipctran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tp->user_negaio = NULL;\n-\tnni_mtx_unlock(&p->mtx);\n \n-\tnni_aio_abort(p->negaio, rv);\n-\tnni_aio_finish_error(aio, rv);\n+\tp->conn      = nni_aio_get_output(aio, 0);\n+\tp->txhead[0] = 0;\n+\tp->txhead[1] = 'S';\n+\tp->txhead[2] = 'P';\n+\tp->txhead[3] = 0;\n+\tNNI_PUT16(&p->txhead[4], p->proto);\n+\tNNI_PUT16(&p->txhead[6], 0);\n+\n+\tp->gotrxhead  = 0;\n+\tp->gottxhead  = 0;\n+\tp->wantrxhead = 8;\n+\tp->wanttxhead = 8;\n+\tiov.iov_len   = 8;\n+\tiov.iov_buf   = &p->txhead[0];\n+\tnni_aio_set_iov(p->negoaio, 1, &iov);\n+\tnni_ipc_conn_send(p->conn, p->negoaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n }\n \n static void\n ipctran_pipe_nego_cb(void *arg)\n {\n \tipctran_pipe *p   = arg;\n-\tnni_aio *     aio = p->negaio;\n+\tnni_aio *     aio = p->negoaio;\n+\tnni_aio *     uaio;\n \tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n \tif ((rv = nni_aio_result(aio)) != 0) {\n \t\tgoto done;\n \t}\n@@ -201,7 +262,7 @@ ipctran_pipe_nego_cb(void *arg)\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\t// send it down...\n \t\tnni_ipc_conn_send(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \tif (p->gotrxhead < p->wantrxhead) {\n@@ -210,7 +271,7 @@ ipctran_pipe_nego_cb(void *arg)\n \t\tiov.iov_buf = &p->rxhead[p->gotrxhead];\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_ipc_conn_recv(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \t// We have both sent and received the headers.  Lets check the\n@@ -225,11 +286,19 @@ ipctran_pipe_nego_cb(void *arg)\n \tNNI_GET16(&p->rxhead[4], p->peer);\n \n done:\n-\tif ((aio = p->user_negaio) != NULL) {\n-\t\tp->user_negaio = NULL;\n-\t\tnni_aio_finish(aio, rv, 0);\n+\n+\tif ((uaio = p->useraio) != NULL) {\n+\t\tp->useraio = NULL;\n+\t\tif (rv == 0) {\n+\t\t\tnni_aio_set_output(uaio, 0, p);\n+\t\t\tnni_aio_finish(uaio, 0, 0);\n+\t\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\t\treturn;\n+\t\t}\n+\t\tnni_aio_finish_error(uaio, rv);\n \t}\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&p->ep->mtx);\n+\tipctran_pipe_reap(p);\n }\n \n static void\n@@ -243,17 +312,20 @@ ipctran_pipe_send_cb(void *arg)\n \tnni_aio *     txaio = p->txaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->sendq);\n \n-\tif ((rv = nni_aio_result(txaio)) != 0) {\n+\trv = p->closed ? NNG_ECLOSED : nni_aio_result(txaio);\n+\n+\tif (rv != 0) {\n \t\t// Intentionally we do not queue up another transfer.\n \t\t// There's an excellent chance that the pipe is no longer\n \t\t// usable, with a partial transfer.\n \t\t// The protocol should see this error, and close the\n \t\t// pipe itself, we hope.\n-\t\tnni_aio_list_remove(aio);\n+\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, rv);\n+\t\t}\n \t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n \t\treturn;\n \t}\n \n@@ -265,6 +337,7 @@ ipctran_pipe_send_cb(void *arg)\n \t\treturn;\n \t}\n \n+\taio = nni_list_first(&p->sendq);\n \tnni_aio_list_remove(aio);\n \tipctran_pipe_send_start(p);\n \n@@ -288,7 +361,6 @@ ipctran_pipe_recv_cb(void *arg)\n \tnni_aio *     rxaio = p->rxaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->recvq);\n \n \tif ((rv = nni_aio_result(rxaio)) != 0) {\n \t\t// Error on receive.  This has to cause an error back\n@@ -296,6 +368,10 @@ ipctran_pipe_recv_cb(void *arg)\n \t\t// toss it.\n \t\tgoto recv_error;\n \t}\n+\tif (p->closed) {\n+\t\trv = NNG_ECLOSED;\n+\t\tgoto recv_error;\n+\t}\n \n \tn = nni_aio_count(rxaio);\n \tnni_aio_iov_advance(rxaio, n);\n@@ -354,6 +430,7 @@ ipctran_pipe_recv_cb(void *arg)\n \t// Otherwise we got a message read completely.  Let the user know the\n \t// good news.\n \n+\taio = nni_list_first(&p->recvq);\n \tnni_aio_list_remove(aio);\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n@@ -367,7 +444,10 @@ ipctran_pipe_recv_cb(void *arg)\n \treturn;\n \n recv_error:\n-\tnni_aio_list_remove(aio);\n+\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n+\t\tnni_aio_list_remove(aio);\n+\t\tnni_aio_finish_error(aio, rv);\n+\t}\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n \t// Intentionally, we do not queue up another receive.\n@@ -375,7 +455,6 @@ ipctran_pipe_recv_cb(void *arg)\n \tnni_mtx_unlock(&p->mtx);\n \n \tnni_msg_free(msg);\n-\tnni_aio_finish_error(aio, rv);\n }\n \n static void\n@@ -452,6 +531,11 @@ ipctran_pipe_send(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, ipctran_pipe_send_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -514,6 +598,11 @@ ipctran_pipe_recv(void *arg, nni_aio *aio)\n \t}\n \tnni_mtx_lock(&p->mtx);\n \n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, ipctran_pipe_recv_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -527,43 +616,6 @@ ipctran_pipe_recv(void *arg, nni_aio *aio)\n \tnni_mtx_unlock(&p->mtx);\n }\n \n-static void\n-ipctran_pipe_start(void *arg, nni_aio *aio)\n-{\n-\tipctran_pipe *p = arg;\n-\tnni_aio *     negaio;\n-\tnni_iov       iov;\n-\tint           rv;\n-\n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n-\t}\n-\tnni_mtx_lock(&p->mtx);\n-\tif ((rv = nni_aio_schedule(aio, ipctran_pipe_nego_cancel, p)) != 0) {\n-\t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tp->txhead[0] = 0;\n-\tp->txhead[1] = 'S';\n-\tp->txhead[2] = 'P';\n-\tp->txhead[3] = 0;\n-\tNNI_PUT16(&p->txhead[4], p->proto);\n-\tNNI_PUT16(&p->txhead[6], 0);\n-\n-\tp->user_negaio = aio;\n-\tp->gotrxhead   = 0;\n-\tp->gottxhead   = 0;\n-\tp->wantrxhead  = 8;\n-\tp->wanttxhead  = 8;\n-\tnegaio         = p->negaio;\n-\tiov.iov_len    = 8;\n-\tiov.iov_buf    = &p->txhead[0];\n-\tnni_aio_set_iov(negaio, 1, &iov);\n-\tnni_ipc_conn_send(p->conn, negaio);\n-\tnni_mtx_unlock(&p->mtx);\n-}\n-\n static uint16_t\n ipctran_pipe_peer(void *arg)\n {\n@@ -632,21 +684,42 @@ ipctran_dialer_fini(void *arg)\n {\n \tipctran_dialer *d = arg;\n \n-\tnni_aio_stop(d->aio);\n+\tnni_mtx_lock(&d->ep.mtx);\n \tif (d->dialer != NULL) {\n \t\tnni_ipc_dialer_fini(d->dialer);\n+\t\td->dialer = NULL;\n+\t}\n+\td->ep.fini = true;\n+\tif (!nni_list_empty(&d->ep.pipes)) {\n+\t\tnni_mtx_unlock(&d->ep.mtx);\n+\t\treturn;\n \t}\n-\tnni_aio_fini(d->aio);\n-\tnni_mtx_fini(&d->mtx);\n+\tnni_mtx_unlock(&d->ep.mtx);\n+\n+\tnni_mtx_fini(&d->ep.mtx);\n \tNNI_FREE_STRUCT(d);\n }\n \n+static void\n+ipctran_ep_close(void *arg)\n+{\n+\tipctran_ep *  ep = arg;\n+\tipctran_pipe *p;\n+\n+\tnni_mtx_lock(&ep->mtx);\n+\tNNI_LIST_FOREACH (&ep->pipes, p) {\n+\t\tnni_aio_close(p->negoaio);\n+\t\tnni_aio_close(p->connaio);\n+\t}\n+\tnni_mtx_unlock(&ep->mtx);\n+}\n+\n static void\n ipctran_dialer_close(void *arg)\n {\n \tipctran_dialer *d = arg;\n \n-\tnni_aio_close(d->aio);\n+\tipctran_ep_close(&d->ep);\n \tnni_ipc_dialer_close(d->dialer);\n }\n \n@@ -660,90 +733,46 @@ ipctran_dialer_init(void **dp, nni_url *url, nni_sock *sock)\n \tif ((d = NNI_ALLOC_STRUCT(d)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&d->mtx);\n+\tnni_mtx_init(&d->ep.mtx);\n+\tNNI_LIST_INIT(&d->ep.pipes, ipctran_pipe, node);\n \n-\tsz                    = sizeof(d->sa.s_ipc.sa_path);\n-\td->sa.s_ipc.sa_family = NNG_AF_IPC;\n+\tsz                       = sizeof(d->ep.sa.s_ipc.sa_path);\n+\td->ep.sa.s_ipc.sa_family = NNG_AF_IPC;\n+\td->ep.proto              = nni_sock_proto_id(sock);\n+\td->ep.dtor               = ipctran_dialer_fini;\n \n-\tif (nni_strlcpy(d->sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n+\tif (nni_strlcpy(d->ep.sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n \t\tipctran_dialer_fini(d);\n \t\treturn (NNG_EADDRINVAL);\n \t}\n \n-\tif (((rv = nni_ipc_dialer_init(&d->dialer)) != 0) ||\n-\t    ((rv = nni_aio_init(&d->aio, ipctran_dialer_cb, d)) != 0)) {\n+\tif ((rv = nni_ipc_dialer_init(&d->dialer)) != 0) {\n \t\tipctran_dialer_fini(d);\n \t\treturn (rv);\n \t}\n \n-\td->proto = nni_sock_proto_id(sock);\n-\n \t*dp = d;\n \treturn (0);\n }\n \n static void\n-ipctran_dialer_cb(void *arg)\n+ipctran_pipe_conn_cancel(nni_aio *aio, int rv)\n {\n-\tipctran_dialer *d = arg;\n-\tipctran_pipe *  p;\n-\tnni_ipc_conn *  conn;\n-\tnni_aio *       aio;\n-\tint             rv;\n-\n-\tnni_mtx_lock(&d->mtx);\n-\taio = d->user_aio;\n-\trv  = nni_aio_result(d->aio);\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(d->aio, 0);\n-\t\t\tnni_ipc_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\td->user_aio = NULL;\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n+\tipctran_pipe *p = nni_aio_get_prov_data(aio);\n \n-\td->user_aio = NULL;\n-\tconn        = nni_aio_get_output(d->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\tif ((rv = ipctran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_ipc_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif (p->useraio != aio) {\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \n-\tp->proto  = d->proto;\n-\tp->rcvmax = d->rcvmax;\n-\tp->sa     = d->sa;\n-\tnni_mtx_unlock(&d->mtx);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-ipctran_dialer_cancel(nni_aio *aio, int rv)\n-{\n-\tipctran_dialer *d = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&d->mtx);\n-\tif (d->user_aio != aio) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tnni_mtx_unlock(&d->mtx);\n+\t// Close the underlying AIOs.  This will abort the operation.\n+\t// The pipe is removed from pending list at completion callback.\n+\tp->useraio = NULL;\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n \n-\tnni_aio_abort(d->aio, rv);\n \tnni_aio_finish_error(aio, rv);\n }\n \n@@ -751,47 +780,48 @@ static void\n ipctran_dialer_connect(void *arg, nni_aio *aio)\n {\n \tipctran_dialer *d = arg;\n+\tipctran_pipe *  p = NULL;\n \tint             rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&d->mtx);\n-\tNNI_ASSERT(d->user_aio == NULL);\n \n-\tif ((rv = nni_aio_schedule(aio, ipctran_dialer_cancel, d)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n+\tnni_mtx_lock(&d->ep.mtx);\n+\tif (((rv = ipctran_pipe_init(&p, &d->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, ipctran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&d->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\tipctran_pipe_reap(p);\n \t\treturn;\n \t}\n-\td->user_aio = aio;\n+\tp->useraio = aio;\n \n-\tnni_ipc_dialer_dial(d->dialer, &d->sa, d->aio);\n-\tnni_mtx_unlock(&d->mtx);\n+\tnni_ipc_dialer_dial(d->dialer, &p->sa, p->connaio);\n+\tnni_mtx_unlock(&d->ep.mtx);\n }\n \n static int\n-ipctran_dialer_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n+ipctran_ep_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\tipctran_dialer *d = arg;\n-\tint             rv;\n-\tnni_mtx_lock(&d->mtx);\n-\trv = nni_copyout_size(d->rcvmax, v, szp, t);\n-\tnni_mtx_unlock(&d->mtx);\n+\tipctran_ep *ep = arg;\n+\tint         rv;\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_size(ep->rcvmax, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n \treturn (rv);\n }\n \n static int\n-ipctran_dialer_set_recvmaxsz(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n+ipctran_ep_set_recvmaxsz(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\tipctran_dialer *d = arg;\n-\tsize_t          val;\n-\tint             rv;\n+\tipctran_ep *ep = arg;\n+\tsize_t      val;\n+\tint         rv;\n \tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->rcvmax = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->rcvmax = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n@@ -801,12 +831,19 @@ ipctran_listener_fini(void *arg)\n {\n \tipctran_listener *l = arg;\n \n-\tnni_aio_stop(l->aio);\n+\tnni_mtx_lock(&l->ep.mtx);\n \tif (l->listener != NULL) {\n \t\tnni_ipc_listener_fini(l->listener);\n+\t\tl->listener = NULL;\n+\t}\n+\tl->ep.fini = true;\n+\tif (!nni_list_empty(&l->ep.pipes)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n+\t\treturn;\n \t}\n-\tnni_aio_fini(l->aio);\n-\tnni_mtx_fini(&l->mtx);\n+\tnni_mtx_unlock(&l->ep.mtx);\n+\n+\tnni_mtx_fini(&l->ep.mtx);\n \tNNI_FREE_STRUCT(l);\n }\n \n@@ -820,24 +857,24 @@ ipctran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \tif ((l = NNI_ALLOC_STRUCT(l)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&l->mtx);\n+\tnni_mtx_init(&l->ep.mtx);\n+\tNNI_LIST_INIT(&l->ep.pipes, ipctran_pipe, node);\n \n-\tsz                    = sizeof(l->sa.s_ipc.sa_path);\n-\tl->sa.s_ipc.sa_family = NNG_AF_IPC;\n+\tsz                       = sizeof(l->ep.sa.s_ipc.sa_path);\n+\tl->ep.sa.s_ipc.sa_family = NNG_AF_IPC;\n+\tl->ep.proto              = nni_sock_proto_id(sock);\n+\tl->ep.dtor               = ipctran_listener_fini;\n \n-\tif (nni_strlcpy(l->sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n+\tif (nni_strlcpy(l->ep.sa.s_ipc.sa_path, url->u_path, sz) >= sz) {\n \t\tipctran_listener_fini(l);\n \t\treturn (NNG_EADDRINVAL);\n \t}\n \n-\tif (((rv = nni_ipc_listener_init(&l->listener)) != 0) ||\n-\t    ((rv = nni_aio_init(&l->aio, ipctran_listener_cb, l)) != 0)) {\n+\tif ((rv = nni_ipc_listener_init(&l->listener)) != 0) {\n \t\tipctran_listener_fini(l);\n \t\treturn (rv);\n \t}\n \n-\tl->proto = nni_sock_proto_id(sock);\n-\n \t*lp = l;\n \treturn (0);\n }\n@@ -847,7 +884,7 @@ ipctran_listener_close(void *arg)\n {\n \tipctran_listener *l = arg;\n \n-\tnni_aio_close(l->aio);\n+\tipctran_ep_close(&l->ep);\n \tnni_ipc_listener_close(l->listener);\n }\n \n@@ -857,128 +894,35 @@ ipctran_listener_bind(void *arg)\n \tipctran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_ipc_listener_listen(l->listener, &l->sa);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\trv = nni_ipc_listener_listen(l->listener, &l->ep.sa);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \treturn (rv);\n }\n \n-static void\n-ipctran_listener_cb(void *arg)\n-{\n-\tipctran_listener *l = arg;\n-\tnni_aio *         aio;\n-\tint               rv;\n-\tipctran_pipe *    p = NULL;\n-\tnni_ipc_conn *    conn;\n-\n-\tnni_mtx_lock(&l->mtx);\n-\trv          = nni_aio_result(l->aio);\n-\taio         = l->user_aio;\n-\tl->user_aio = NULL;\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(l->aio, 0);\n-\t\t\tnni_ipc_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tconn = nni_aio_get_output(l->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\n-\t// Attempt to allocate the parent pipe.  If this fails we'll\n-\t// drop the connection (ENOMEM probably).\n-\tif ((rv = ipctran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_ipc_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tp->proto  = l->proto;\n-\tp->rcvmax = l->rcvmax;\n-\tp->sa     = l->sa;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-ipctran_listener_cancel(nni_aio *aio, int rv)\n-{\n-\tipctran_listener *l = nni_aio_get_prov_data(aio);\n-\n-\tNNI_ASSERT(rv != 0);\n-\tnni_mtx_lock(&l->mtx);\n-\tif (l->user_aio != aio) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\treturn;\n-\t}\n-\tl->user_aio = NULL;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\tnni_aio_abort(l->aio, rv);\n-\tnni_aio_finish_error(aio, rv);\n-}\n-\n static void\n ipctran_listener_accept(void *arg, nni_aio *aio)\n {\n \tipctran_listener *l = arg;\n+\tipctran_pipe *    p;\n \tint               rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&l->mtx);\n-\tNNI_ASSERT(l->user_aio == NULL);\n \n-\tif ((rv = nni_aio_schedule(aio, ipctran_listener_cancel, l)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\tif (((rv = ipctran_pipe_init(&p, &l->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, ipctran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\tipctran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tl->user_aio = aio;\n-\n-\tnni_ipc_listener_accept(l->listener, l->aio);\n-\tnni_mtx_unlock(&l->mtx);\n-}\n-\n-static int\n-ipctran_listener_set_recvmaxsz(\n-    void *arg, const void *data, size_t sz, nni_opt_type t)\n-{\n-\tipctran_listener *l = arg;\n-\tsize_t            val;\n-\tint               rv;\n-\n-\tif ((rv = nni_copyin_size(&val, data, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->rcvmax = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n+\tp->useraio = aio;\n \n-static int\n-ipctran_listener_get_recvmaxsz(\n-    void *arg, void *data, size_t *szp, nni_opt_type t)\n-{\n-\tipctran_listener *l = arg;\n-\tint               rv;\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_size(l->rcvmax, data, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n+\tnni_ipc_listener_accept(l->listener, p->connaio);\n+\tnni_mtx_unlock(&l->ep.mtx);\n }\n \n static int\n@@ -987,9 +931,9 @@ ipctran_listener_get_locaddr(void *arg, void *buf, size_t *szp, nni_opt_type t)\n \tipctran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_sockaddr(&l->sa, buf, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\trv = nni_copyout_sockaddr(&l->ep.sa, buf, szp, t);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \treturn (rv);\n }\n \n@@ -1010,9 +954,9 @@ ipctran_listener_set_perms(\n \t// Probably we could further limit this -- most systems don't have\n \t// meaningful chmod beyond the lower 9 bits.\n \tif ((rv = nni_copyin_int(&val, data, sz, 0, 0x7FFFFFFF, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n+\t\tnni_mtx_lock(&l->ep.mtx);\n \t\trv = nni_ipc_listener_set_permissions(l->listener, val);\n-\t\tnni_mtx_unlock(&l->mtx);\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t}\n \treturn (rv);\n }\n@@ -1032,10 +976,10 @@ ipctran_listener_set_sec_desc(\n \tint               rv;\n \n \tif ((rv = nni_copyin_ptr(&ptr, data, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n+\t\tnni_mtx_lock(&l->ep.mtx);\n \t\trv =\n \t\t    nni_ipc_listener_set_security_descriptor(l->listener, ptr);\n-\t\tnni_mtx_unlock(&l->mtx);\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t}\n \treturn (rv);\n }\n@@ -1085,7 +1029,6 @@ static nni_tran_option ipctran_pipe_options[] = {\n \n static nni_tran_pipe_ops ipctran_pipe_ops = {\n \t.p_fini    = ipctran_pipe_fini,\n-\t.p_start   = ipctran_pipe_start,\n \t.p_stop    = ipctran_pipe_stop,\n \t.p_send    = ipctran_pipe_send,\n \t.p_recv    = ipctran_pipe_recv,\n@@ -1098,8 +1041,8 @@ static nni_tran_option ipctran_dialer_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = ipctran_dialer_get_recvmaxsz,\n-\t    .o_set  = ipctran_dialer_set_recvmaxsz,\n+\t    .o_get  = ipctran_ep_get_recvmaxsz,\n+\t    .o_set  = ipctran_ep_set_recvmaxsz,\n \t    .o_chk  = ipctran_check_recvmaxsz,\n \t},\n \t// terminate list\n@@ -1112,8 +1055,8 @@ static nni_tran_option ipctran_listener_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = ipctran_listener_get_recvmaxsz,\n-\t    .o_set  = ipctran_listener_set_recvmaxsz,\n+\t    .o_get  = ipctran_ep_get_recvmaxsz,\n+\t    .o_set  = ipctran_ep_set_recvmaxsz,\n \t    .o_chk  = ipctran_check_recvmaxsz,\n \t},\n \t{\ndiff --git a/src/transport/tcp/tcp.c b/src/transport/tcp/tcp.c\nindex 0d47529e6..6cf699721 100644\n--- a/src/transport/tcp/tcp.c\n+++ b/src/transport/tcp/tcp.c\n@@ -20,19 +20,26 @@\n typedef struct tcptran_pipe     tcptran_pipe;\n typedef struct tcptran_dialer   tcptran_dialer;\n typedef struct tcptran_listener tcptran_listener;\n+typedef struct tcptran_ep       tcptran_ep;\n \n // tcp_pipe is one end of a TCP connection.\n struct tcptran_pipe {\n-\tnni_tcp_conn *conn;\n-\tuint16_t      peer;\n-\tuint16_t      proto;\n-\tsize_t        rcvmax;\n-\tbool          nodelay;\n-\tbool          keepalive;\n+\tnni_tcp_conn *  conn;\n+\tuint16_t        peer;\n+\tuint16_t        proto;\n+\tsize_t          rcvmax;\n+\tnni_sockaddr    sa;\n+\tbool            nodelay;\n+\tbool            keepalive;\n+\tbool            closed;\n+\tnni_atomic_flag reaped;\n+\tnni_list_node   node;\n+\tnni_reap_item   reap;\n+\ttcptran_ep *    ep;\n \n \tnni_list recvq;\n \tnni_list sendq;\n-\tnni_aio *user_negaio;\n+\tnni_aio *useraio;\n \n \tuint8_t  txlen[sizeof(uint64_t)];\n \tuint8_t  rxlen[sizeof(uint64_t)];\n@@ -42,47 +49,48 @@ struct tcptran_pipe {\n \tsize_t   wantrxhead;\n \tnni_aio *txaio;\n \tnni_aio *rxaio;\n-\tnni_aio *negaio;\n+\tnni_aio *negoaio;\n+\tnni_aio *connaio;\n+\tnni_aio *rslvaio;\n \tnni_msg *rxmsg;\n \tnni_mtx  mtx;\n };\n \n+struct tcptran_ep {\n+\tnni_mtx       mtx;\n+\tnni_list      pipes;\n+\tnni_url *     url;\n+\tsize_t        rcvmax;\n+\tbool          nodelay;\n+\tbool          keepalive;\n+\tbool          fini;\n+\tuint16_t      proto;\n+\tnni_cb        dtor;\n+\tnni_reap_item reap;\n+};\n+\n struct tcptran_dialer {\n+\ttcptran_ep      ep;\n \tnni_tcp_dialer *dialer;\n-\tuint16_t        proto;\n-\tuint16_t        af;\n-\tsize_t          rcvmax;\n-\tbool            nodelay;\n-\tbool            keepalive;\n-\tbool            resolving;\n \tnng_sockaddr    sa;\n-\tnni_aio *       aio;\n-\tnni_aio *       user_aio;\n-\tnni_url *       url;\n-\tnni_mtx         mtx;\n+\tuint16_t        af;\n };\n \n struct tcptran_listener {\n+\ttcptran_ep        ep;\n \tnni_tcp_listener *listener;\n-\tuint16_t          proto;\n-\tsize_t            rcvmax;\n-\tbool              nodelay;\n-\tbool              keepalive;\n-\tnni_aio *         aio;\n-\tnni_aio *         user_aio;\n-\tnni_url *         url;\n \tnng_sockaddr      sa;\n \tnng_sockaddr      bsa; // bound addr\n-\tnni_mtx           mtx;\n };\n \n static void tcptran_pipe_send_start(tcptran_pipe *);\n static void tcptran_pipe_recv_start(tcptran_pipe *);\n static void tcptran_pipe_send_cb(void *);\n static void tcptran_pipe_recv_cb(void *);\n+static void tcptran_pipe_rslv_cb(void *);\n static void tcptran_pipe_nego_cb(void *);\n-static void tcptran_dialer_cb(void *arg);\n-static void tcptran_listener_cb(void *arg);\n+static void tcptran_pipe_conn_cb(void *);\n+static void tcptran_pipe_reap(tcptran_pipe *);\n \n static int\n tcptran_init(void)\n@@ -100,9 +108,15 @@ tcptran_pipe_close(void *arg)\n {\n \ttcptran_pipe *p = arg;\n \n+\tnni_mtx_lock(&p->mtx);\n+\tp->closed = true;\n+\tnni_mtx_unlock(&p->mtx);\n+\n \tnni_aio_close(p->rxaio);\n \tnni_aio_close(p->txaio);\n-\tnni_aio_close(p->negaio);\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n \n \tnni_tcp_conn_close(p->conn);\n }\n@@ -114,17 +128,34 @@ tcptran_pipe_stop(void *arg)\n \n \tnni_aio_stop(p->rxaio);\n \tnni_aio_stop(p->txaio);\n-\tnni_aio_stop(p->negaio);\n+\tnni_aio_stop(p->negoaio);\n+\tnni_aio_stop(p->connaio);\n+\tnni_aio_stop(p->rslvaio);\n }\n \n static void\n tcptran_pipe_fini(void *arg)\n {\n \ttcptran_pipe *p = arg;\n+\ttcptran_ep *  ep;\n \n+\tif (p == NULL) {\n+\t\treturn;\n+\t}\n+\ttcptran_pipe_stop(p);\n+\tif ((ep = p->ep) != NULL) {\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tnni_list_remove(&ep->pipes, p);\n+\t\tif (ep->fini && nni_list_empty(&ep->pipes)) {\n+\t\t\tnni_reap(&ep->reap, ep->dtor, ep);\n+\t\t}\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t}\n \tnni_aio_fini(p->rxaio);\n \tnni_aio_fini(p->txaio);\n-\tnni_aio_fini(p->negaio);\n+\tnni_aio_fini(p->negoaio);\n+\tnni_aio_fini(p->connaio);\n+\tnni_aio_fini(p->rslvaio);\n \tif (p->conn != NULL) {\n \t\tnni_tcp_conn_fini(p->conn);\n \t}\n@@ -133,8 +164,16 @@ tcptran_pipe_fini(void *arg)\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+tcptran_pipe_reap(tcptran_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n+\t\tnni_reap(&p->reap, tcptran_pipe_fini, p);\n+\t}\n+}\n+\n static int\n-tcptran_pipe_init(tcptran_pipe **pipep, void *conn)\n+tcptran_pipe_init(tcptran_pipe **pipep, tcptran_ep *ep)\n {\n \ttcptran_pipe *p;\n \tint           rv;\n@@ -143,45 +182,108 @@ tcptran_pipe_init(tcptran_pipe **pipep, void *conn)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&p->mtx);\n+\tNNI_LIST_NODE_INIT(&p->node);\n+\tnni_aio_list_init(&p->recvq);\n+\tnni_aio_list_init(&p->sendq);\n+\tnni_atomic_flag_reset(&p->reaped);\n+\n \tif (((rv = nni_aio_init(&p->txaio, tcptran_pipe_send_cb, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->rxaio, tcptran_pipe_recv_cb, p)) != 0) ||\n-\t    ((rv = nni_aio_init(&p->negaio, tcptran_pipe_nego_cb, p)) != 0)) {\n-\t\ttcptran_pipe_fini(p);\n+\t    ((rv = nni_aio_init(&p->rslvaio, tcptran_pipe_rslv_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->connaio, tcptran_pipe_conn_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->negoaio, tcptran_pipe_nego_cb, p)) != 0)) {\n+\t\ttcptran_pipe_reap(p);\n \t\treturn (rv);\n \t}\n-\tnni_aio_list_init(&p->recvq);\n-\tnni_aio_list_init(&p->sendq);\n+\tnni_list_append(&ep->pipes, p);\n+\tp->ep        = ep;\n+\tp->proto     = ep->proto;\n+\tp->rcvmax    = ep->rcvmax;\n+\tp->keepalive = ep->keepalive;\n+\tp->nodelay   = ep->nodelay;\n \n-\tp->conn = conn;\n-\t*pipep  = p;\n+\t*pipep = p;\n \treturn (0);\n }\n \n static void\n-tcptran_pipe_nego_cancel(nni_aio *aio, int rv)\n+tcptran_pipe_rslv_cb(void *arg)\n {\n-\ttcptran_pipe *p = nni_aio_get_prov_data(aio);\n+\ttcptran_pipe *  p = arg;\n+\ttcptran_dialer *d;\n+\tnni_aio *       aio = p->rslvaio;\n+\tint             rv;\n \n-\tnni_mtx_lock(&p->mtx);\n-\tif (p->user_negaio != aio) {\n-\t\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttcptran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tp->user_negaio = NULL;\n-\tnni_mtx_unlock(&p->mtx);\n+\td = (void *) p->ep;\n+\tif (d->dialer != NULL) {\n+\t\tnni_tcp_dialer_dial(d->dialer, &p->sa, p->connaio);\n+\t}\n+\tnni_mtx_unlock(&p->ep->mtx);\n+}\n \n-\tnni_aio_abort(p->negaio, rv);\n-\tnni_aio_finish_error(aio, rv);\n+static void\n+tcptran_pipe_conn_cb(void *arg)\n+{\n+\ttcptran_pipe *p   = arg;\n+\tnni_aio *     aio = p->connaio;\n+\tnni_iov       iov;\n+\tint           rv;\n+\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttcptran_pipe_reap(p);\n+\t\treturn;\n+\t}\n+\n+\tp->conn = nni_aio_get_output(aio, 0);\n+\n+\t(void) nni_tcp_conn_set_nodelay(p->conn, p->nodelay);\n+\t(void) nni_tcp_conn_set_keepalive(p->conn, p->keepalive);\n+\n+\tp->txlen[0] = 0;\n+\tp->txlen[1] = 'S';\n+\tp->txlen[2] = 'P';\n+\tp->txlen[3] = 0;\n+\tNNI_PUT16(&p->txlen[4], p->proto);\n+\tNNI_PUT16(&p->txlen[6], 0);\n+\n+\tp->gotrxhead  = 0;\n+\tp->gottxhead  = 0;\n+\tp->wantrxhead = 8;\n+\tp->wanttxhead = 8;\n+\tiov.iov_len   = 8;\n+\tiov.iov_buf   = &p->txlen[0];\n+\tnni_aio_set_iov(p->negoaio, 1, &iov);\n+\tnni_tcp_conn_send(p->conn, p->negoaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n }\n \n static void\n tcptran_pipe_nego_cb(void *arg)\n {\n \ttcptran_pipe *p   = arg;\n-\tnni_aio *     aio = p->negaio;\n+\tnni_aio *     aio = p->negoaio;\n+\tnni_aio *     uaio;\n \tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n \tif ((rv = nni_aio_result(aio)) != 0) {\n \t\tgoto done;\n \t}\n@@ -200,7 +302,7 @@ tcptran_pipe_nego_cb(void *arg)\n \t\t// send it down...\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_tcp_conn_send(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \tif (p->gotrxhead < p->wantrxhead) {\n@@ -209,7 +311,7 @@ tcptran_pipe_nego_cb(void *arg)\n \t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_tcp_conn_recv(p->conn, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \t// We have both sent and received the headers.  Lets check the\n@@ -224,11 +326,18 @@ tcptran_pipe_nego_cb(void *arg)\n \tNNI_GET16(&p->rxlen[4], p->peer);\n \n done:\n-\tif ((aio = p->user_negaio) != NULL) {\n-\t\tp->user_negaio = NULL;\n-\t\tnni_aio_finish(aio, rv, 0);\n+\tif ((uaio = p->useraio) != NULL) {\n+\t\tp->useraio = NULL;\n+\t\tif (rv == 0) {\n+\t\t\tnni_aio_set_output(uaio, 0, p);\n+\t\t\tnni_aio_finish(uaio, 0, 0);\n+\t\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\t\treturn;\n+\t\t}\n+\t\tnni_aio_finish_error(uaio, rv);\n \t}\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&p->ep->mtx);\n+\ttcptran_pipe_reap(p);\n }\n \n static void\n@@ -242,17 +351,19 @@ tcptran_pipe_send_cb(void *arg)\n \tnni_aio *     txaio = p->txaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->sendq);\n+\trv = p->closed ? NNG_ECLOSED : nni_aio_result(txaio);\n \n-\tif ((rv = nni_aio_result(txaio)) != 0) {\n+\tif (rv != 0) {\n \t\t// Intentionally we do not queue up another transfer.\n \t\t// There's an excellent chance that the pipe is no longer\n \t\t// usable, with a partial transfer.\n \t\t// The protocol should see this error, and close the\n \t\t// pipe itself, we hope.\n-\t\tnni_aio_list_remove(aio);\n+\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, rv);\n+\t\t}\n \t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n \t\treturn;\n \t}\n \n@@ -264,6 +375,7 @@ tcptran_pipe_send_cb(void *arg)\n \t\treturn;\n \t}\n \n+\taio = nni_list_first(&p->sendq);\n \tnni_aio_list_remove(aio);\n \ttcptran_pipe_send_start(p);\n \n@@ -287,11 +399,14 @@ tcptran_pipe_recv_cb(void *arg)\n \tnni_aio *     rxaio = p->rxaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->recvq);\n \n \tif ((rv = nni_aio_result(rxaio)) != 0) {\n \t\tgoto recv_error;\n \t}\n+\tif (p->closed) {\n+\t\trv = NNG_ECLOSED;\n+\t\tgoto recv_error;\n+\t}\n \n \tn = nni_aio_count(rxaio);\n \tnni_aio_iov_advance(rxaio, n);\n@@ -335,6 +450,7 @@ tcptran_pipe_recv_cb(void *arg)\n \t}\n \n \t// We read a message completely.  Let the user know the good news.\n+\taio = nni_list_first(&p->recvq);\n \tnni_aio_list_remove(aio);\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n@@ -348,7 +464,10 @@ tcptran_pipe_recv_cb(void *arg)\n \treturn;\n \n recv_error:\n-\tnni_aio_list_remove(aio);\n+\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n+\t\tnni_aio_list_remove(aio);\n+\t\tnni_aio_finish_error(aio, rv);\n+\t}\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n \t// Intentionally, we do not queue up another receive.\n@@ -356,7 +475,6 @@ tcptran_pipe_recv_cb(void *arg)\n \tnni_mtx_unlock(&p->mtx);\n \n \tnni_msg_free(msg);\n-\tnni_aio_finish_error(aio, rv);\n }\n \n static void\n@@ -432,6 +550,11 @@ tcptran_pipe_send(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tcptran_pipe_send_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -474,7 +597,7 @@ tcptran_pipe_recv_start(tcptran_pipe *p)\n \tnni_iov  iov;\n \tNNI_ASSERT(p->rxmsg == NULL);\n \n-\t// Schedule a read of the IPC header.\n+\t// Schedule a read of the header.\n \trxaio       = p->rxaio;\n \tiov.iov_buf = p->rxlen;\n \tiov.iov_len = sizeof(p->rxlen);\n@@ -493,6 +616,11 @@ tcptran_pipe_recv(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tcptran_pipe_recv_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -557,54 +685,36 @@ tcptran_pipe_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n }\n \n static void\n-tcptran_pipe_start(void *arg, nni_aio *aio)\n+tcptran_dialer_fini(void *arg)\n {\n-\ttcptran_pipe *p = arg;\n-\tnni_aio *     negaio;\n-\tnni_iov       iov;\n-\tint           rv;\n+\ttcptran_dialer *d = arg;\n \n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n+\tnni_mtx_lock(&d->ep.mtx);\n+\tif (d->dialer != NULL) {\n+\t\tnni_tcp_dialer_fini(d->dialer);\n+\t\td->dialer = NULL;\n \t}\n-\tnni_mtx_lock(&p->mtx);\n-\tif ((rv = nni_aio_schedule(aio, tcptran_pipe_nego_cancel, p)) != 0) {\n-\t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n+\td->ep.fini = true;\n+\tif (!nni_list_empty(&d->ep.pipes)) {\n+\t\tnni_mtx_unlock(&d->ep.mtx);\n \t\treturn;\n \t}\n-\tp->txlen[0] = 0;\n-\tp->txlen[1] = 'S';\n-\tp->txlen[2] = 'P';\n-\tp->txlen[3] = 0;\n-\tNNI_PUT16(&p->txlen[4], p->proto);\n-\tNNI_PUT16(&p->txlen[6], 0);\n-\n-\tp->user_negaio = aio;\n-\tp->gotrxhead   = 0;\n-\tp->gottxhead   = 0;\n-\tp->wantrxhead  = 8;\n-\tp->wanttxhead  = 8;\n-\tnegaio         = p->negaio;\n-\tiov.iov_len    = 8;\n-\tiov.iov_buf    = &p->txlen[0];\n-\tnni_aio_set_iov(negaio, 1, &iov);\n-\tnni_tcp_conn_send(p->conn, negaio);\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&d->ep.mtx);\n+\tnni_mtx_fini(&d->ep.mtx);\n+\tNNI_FREE_STRUCT(d);\n }\n \n static void\n-tcptran_dialer_fini(void *arg)\n+tcptran_ep_close(tcptran_ep *ep)\n {\n-\ttcptran_dialer *d = arg;\n-\n-\tnni_aio_stop(d->aio);\n-\tif (d->dialer != NULL) {\n-\t\tnni_tcp_dialer_fini(d->dialer);\n+\ttcptran_pipe *p;\n+\tnni_mtx_lock(&ep->mtx);\n+\tNNI_LIST_FOREACH (&ep->pipes, p) {\n+\t\tnni_aio_close(p->negoaio);\n+\t\tnni_aio_close(p->connaio);\n+\t\tnni_aio_close(p->rslvaio);\n \t}\n-\tnni_aio_fini(d->aio);\n-\tnni_mtx_fini(&d->mtx);\n-\tNNI_FREE_STRUCT(d);\n+\tnni_mtx_unlock(&ep->mtx);\n }\n \n static void\n@@ -612,7 +722,7 @@ tcptran_dialer_close(void *arg)\n {\n \ttcptran_dialer *d = arg;\n \n-\tnni_aio_close(d->aio);\n+\ttcptran_ep_close(&d->ep);\n \tnni_tcp_dialer_close(d->dialer);\n }\n \n@@ -646,127 +756,72 @@ tcptran_dialer_init(void **dp, nni_url *url, nni_sock *sock)\n \tif ((d = NNI_ALLOC_STRUCT(d)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&d->mtx);\n+\tnni_mtx_init(&d->ep.mtx);\n+\tNNI_LIST_INIT(&d->ep.pipes, tcptran_pipe, node);\n+\td->ep.dtor      = tcptran_dialer_fini;\n+\td->ep.nodelay   = true;\n+\td->ep.keepalive = false;\n+\td->ep.proto     = nni_sock_proto_id(sock);\n+\td->ep.url       = url;\n+\td->af           = af;\n \n-\tif (((rv = nni_tcp_dialer_init(&d->dialer)) != 0) ||\n-\t    ((rv = nni_aio_init(&d->aio, tcptran_dialer_cb, d)) != 0)) {\n+\tif ((rv = nni_tcp_dialer_init(&d->dialer)) != 0) {\n \t\ttcptran_dialer_fini(d);\n \t\treturn (rv);\n \t}\n \n-\td->url       = url;\n-\td->proto     = nni_sock_proto_id(sock);\n-\td->nodelay   = true;\n-\td->keepalive = false;\n-\td->af        = af;\n-\n \t*dp = d;\n \treturn (0);\n }\n \n static void\n-tcptran_dialer_cb(void *arg)\n+tcptran_pipe_conn_cancel(nni_aio *aio, int rv)\n {\n-\ttcptran_dialer *d = arg;\n-\ttcptran_pipe *  p;\n-\tnni_tcp_conn *  conn;\n-\tnni_aio *       aio;\n-\tint             rv;\n-\n-\tnni_mtx_lock(&d->mtx);\n-\taio = d->user_aio;\n-\trv  = nni_aio_result(d->aio);\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tif ((rv == 0) && !d->resolving) {\n-\t\t\tconn = nni_aio_get_output(d->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\td->user_aio = NULL;\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tif (d->resolving) {\n-\t\t// Name resolution complete.  Now go to next step.\n-\t\td->resolving = false;\n-\t\tnni_tcp_dialer_dial(d->dialer, &d->sa, d->aio);\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\treturn;\n-\t}\n+\ttcptran_pipe *p = nni_aio_get_prov_data(aio);\n \n-\td->user_aio = NULL;\n-\tconn        = nni_aio_get_output(d->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\tif ((rv = tcptran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif (p->useraio != aio) {\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \n-\tp->proto     = d->proto;\n-\tp->rcvmax    = d->rcvmax;\n-\tp->nodelay   = d->nodelay;\n-\tp->keepalive = d->keepalive;\n-\tnni_mtx_unlock(&d->mtx);\n+\t// Close the underlying AIOs.  This will abort the operation.\n+\t// The pipe is removed from pending list at completion callback.\n+\tp->useraio = NULL;\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n \n-\t(void) nni_tcp_conn_set_nodelay(conn, p->nodelay);\n-\t(void) nni_tcp_conn_set_keepalive(conn, p->keepalive);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-tcptran_dialer_cancel(nni_aio *aio, int rv)\n-{\n-\ttcptran_dialer *d = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&d->mtx);\n-\tif (d->user_aio != aio) {\n-\t\tnni_mtx_unlock(&d->mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tnni_mtx_unlock(&d->mtx);\n-\n-\tnni_aio_abort(d->aio, rv);\n \tnni_aio_finish_error(aio, rv);\n }\n \n static void\n tcptran_dialer_connect(void *arg, nni_aio *aio)\n {\n-\ttcptran_dialer *d = arg;\n+\ttcptran_dialer *d  = arg;\n+\ttcptran_ep *    ep = &d->ep;\n+\ttcptran_pipe *  p  = NULL;\n \tint             rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&d->mtx);\n-\tNNI_ASSERT(d->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tcptran_dialer_cancel, d)) != 0) {\n-\t\tnni_mtx_unlock(&d->mtx);\n+\tnni_mtx_lock(&ep->mtx);\n+\tif (((rv = tcptran_pipe_init(&p, ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tcptran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttcptran_pipe_reap(p);\n \t\treturn;\n \t}\n-\td->user_aio = aio;\n-\n-\td->resolving = true;\n+\tp->useraio = aio;\n \n-\t// Start the name resolution.  Callback will see resolving, and then\n-\t// switch to doing actual connect.\n-\tnni_aio_set_input(d->aio, 0, &d->sa);\n-\tnni_tcp_resolv(d->url->u_hostname, d->url->u_port, d->af, 0, d->aio);\n-\tnni_mtx_unlock(&d->mtx);\n+\t// Start the name resolution as first step.\n+\tnni_aio_set_input(p->rslvaio, 0, &p->sa);\n+\tnni_tcp_resolv(\n+\t    ep->url->u_hostname, ep->url->u_port, d->af, 0, p->rslvaio);\n+\tnni_mtx_unlock(&ep->mtx);\n }\n \n static int\n@@ -774,79 +829,81 @@ tcptran_dialer_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n \ttcptran_dialer *d = arg;\n \n-\treturn (nni_copyout_str(d->url->u_rawurl, v, szp, t));\n+\treturn (nni_copyout_str(d->ep.url->u_rawurl, v, szp, t));\n }\n \n static int\n-tcptran_dialer_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n+tcptran_ep_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tint         rv;\n \n-\tnni_mtx_lock(&d->mtx);\n-\trv = nni_copyout_size(d->rcvmax, v, szp, t);\n-\tnni_mtx_unlock(&d->mtx);\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_size(ep->rcvmax, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_set_recvmaxsz(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n+tcptran_ep_set_recvmaxsz(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tsize_t          val;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tsize_t      val;\n+\tint         rv;\n \tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->rcvmax = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->rcvmax = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n+tcptran_ep_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tint             rv;\n-\tnni_mtx_lock(&d->mtx);\n-\trv = nni_copyout_bool(d->nodelay, v, szp, t);\n-\tnni_mtx_unlock(&d->mtx);\n+\ttcptran_ep *ep = arg;\n+\tint         rv;\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_bool(ep->nodelay, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_set_nodelay(void *arg, const void *v, size_t sz, nni_opt_type t)\n+tcptran_ep_set_nodelay(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tbool            val;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tbool        val;\n+\tint         rv;\n \tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->nodelay = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->nodelay = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n \n static int\n-tcptran_dialer_get_keepalive(void *arg, void *v, size_t *szp, nni_opt_type t)\n+tcptran_ep_get_keepalive(void *arg, void *v, size_t *szp, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\treturn (nni_copyout_bool(d->keepalive, v, szp, t));\n+\ttcptran_ep *ep = arg;\n+\tint         rv;\n+\tnni_mtx_lock(&ep->mtx);\n+\trv = nni_copyout_bool(ep->keepalive, v, szp, t);\n+\tnni_mtx_unlock(&ep->mtx);\n+\treturn (rv);\n }\n \n static int\n-tcptran_dialer_set_keepalive(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n+tcptran_ep_set_keepalive(void *arg, const void *v, size_t sz, nni_opt_type t)\n {\n-\ttcptran_dialer *d = arg;\n-\tbool            val;\n-\tint             rv;\n+\ttcptran_ep *ep = arg;\n+\tbool        val;\n+\tint         rv;\n \tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&d->mtx);\n-\t\td->keepalive = val;\n-\t\tnni_mtx_unlock(&d->mtx);\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tep->keepalive = val;\n+\t\tnni_mtx_unlock(&ep->mtx);\n \t}\n \treturn (rv);\n }\n@@ -856,12 +913,18 @@ tcptran_listener_fini(void *arg)\n {\n \ttcptran_listener *l = arg;\n \n-\tnni_aio_stop(l->aio);\n+\tnni_mtx_lock(&l->ep.mtx);\n \tif (l->listener != NULL) {\n \t\tnni_tcp_listener_fini(l->listener);\n+\t\tl->listener = NULL;\n \t}\n-\tnni_aio_fini(l->aio);\n-\tnni_mtx_fini(&l->mtx);\n+\tl->ep.fini = true;\n+\tif (!nni_list_empty(&l->ep.pipes)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n+\t\treturn;\n+\t}\n+\tnni_mtx_unlock(&l->ep.mtx);\n+\tnni_mtx_fini(&l->ep.mtx);\n \tNNI_FREE_STRUCT(l);\n }\n \n@@ -896,8 +959,13 @@ tcptran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \tif ((l = NNI_ALLOC_STRUCT(l)) == NULL) {\n \t\treturn (NNG_ENOMEM);\n \t}\n-\tnni_mtx_init(&l->mtx);\n-\tl->url = url;\n+\tnni_mtx_init(&l->ep.mtx);\n+\tNNI_LIST_INIT(&l->ep.pipes, tcptran_pipe, node);\n+\tl->ep.dtor      = tcptran_listener_fini;\n+\tl->ep.url       = url;\n+\tl->ep.proto     = nni_sock_proto_id(sock);\n+\tl->ep.nodelay   = true;\n+\tl->ep.keepalive = false;\n \n \tif (strlen(url->u_hostname) == 0) {\n \t\thost = NULL;\n@@ -923,21 +991,12 @@ tcptran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \trv = nni_aio_result(aio);\n \tnni_aio_fini(aio);\n \n-\tif (rv != 0) {\n+\tif ((rv != 0) || ((rv = nni_tcp_listener_init(&l->listener)) != 0)) {\n \t\ttcptran_listener_fini(l);\n \t\treturn (rv);\n \t}\n \n-\tif (((rv = nni_tcp_listener_init(&l->listener)) != 0) ||\n-\t    ((rv = nni_aio_init(&l->aio, tcptran_listener_cb, l)) != 0)) {\n-\t\ttcptran_listener_fini(l);\n-\t\treturn (rv);\n-\t}\n-\n-\tl->proto     = nni_sock_proto_id(sock);\n-\tl->nodelay   = true;\n-\tl->keepalive = false;\n-\tl->bsa       = l->sa;\n+\tl->bsa = l->sa;\n \n \t*lp = l;\n \treturn (0);\n@@ -948,7 +1007,7 @@ tcptran_listener_close(void *arg)\n {\n \ttcptran_listener *l = arg;\n \n-\tnni_aio_close(l->aio);\n+\ttcptran_ep_close(&l->ep);\n \tnni_tcp_listener_close(l->listener);\n }\n \n@@ -958,171 +1017,36 @@ tcptran_listener_bind(void *arg)\n \ttcptran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n \tl->bsa = l->sa;\n \trv     = nni_tcp_listener_listen(l->listener, &l->bsa);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \n \treturn (rv);\n }\n \n-static void\n-tcptran_listener_cb(void *arg)\n-{\n-\ttcptran_listener *l = arg;\n-\tnni_aio *         aio;\n-\tint               rv;\n-\ttcptran_pipe *    p = NULL;\n-\tnni_tcp_conn *    conn;\n-\n-\tnni_mtx_lock(&l->mtx);\n-\trv          = nni_aio_result(l->aio);\n-\taio         = l->user_aio;\n-\tl->user_aio = NULL;\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(l->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tconn = nni_aio_get_output(l->aio, 0);\n-\n-\tNNI_ASSERT(conn != NULL);\n-\tif ((rv = tcptran_pipe_init(&p, conn)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tp->proto     = l->proto;\n-\tp->rcvmax    = l->rcvmax;\n-\tp->nodelay   = l->nodelay;\n-\tp->keepalive = l->keepalive;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\t(void) nni_tcp_conn_set_nodelay(conn, p->nodelay);\n-\t(void) nni_tcp_conn_set_keepalive(conn, p->keepalive);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-tcptran_listener_cancel(nni_aio *aio, int rv)\n-{\n-\ttcptran_listener *l = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&l->mtx);\n-\tif (l->user_aio != aio) {\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t\treturn;\n-\t}\n-\tl->user_aio = NULL;\n-\tnni_mtx_unlock(&l->mtx);\n-\n-\tnni_aio_abort(l->aio, rv);\n-\tnni_aio_finish_error(aio, rv);\n-}\n-\n static void\n tcptran_listener_accept(void *arg, nni_aio *aio)\n {\n \ttcptran_listener *l = arg;\n+\ttcptran_pipe *    p = NULL;\n \tint               rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n-\tnni_mtx_lock(&l->mtx);\n-\tNNI_ASSERT(l->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tcptran_listener_cancel, l)) != 0) {\n-\t\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n+\tif (((rv = tcptran_pipe_init(&p, &l->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tcptran_pipe_conn_cancel, p)) != 0)) {\n+\t\tnni_mtx_unlock(&l->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttcptran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tl->user_aio = aio;\n-\n-\tnni_tcp_listener_accept(l->listener, l->aio);\n-\tnni_mtx_unlock(&l->mtx);\n-}\n-\n-static int\n-tcptran_listener_set_nodelay(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tbool              val;\n-\tint               rv;\n-\tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->nodelay = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n-\n-static int\n-tcptran_listener_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tint               rv;\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_bool(l->nodelay, v, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n-}\n-\n-static int\n-tcptran_listener_set_recvmaxsz(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tsize_t            val;\n-\tint               rv;\n-\tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->rcvmax = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n+\tp->useraio = aio;\n \n-static int\n-tcptran_listener_set_keepalive(\n-    void *arg, const void *v, size_t sz, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tbool              val;\n-\tint               rv;\n-\tif ((rv = nni_copyin_bool(&val, v, sz, t)) == 0) {\n-\t\tnni_mtx_lock(&l->mtx);\n-\t\tl->keepalive = val;\n-\t\tnni_mtx_unlock(&l->mtx);\n-\t}\n-\treturn (rv);\n-}\n-\n-static int\n-tcptran_listener_get_keepalive(void *arg, void *v, size_t *szp, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tint               rv;\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_bool(l->keepalive, v, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n+\tnni_tcp_listener_accept(l->listener, p->connaio);\n+\tnni_mtx_unlock(&l->ep.mtx);\n }\n \n static int\n@@ -1138,27 +1062,15 @@ tcptran_listener_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n \treturn (nni_copyout_str(ustr, v, szp, t));\n }\n \n-static int\n-tcptran_listener_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n-{\n-\ttcptran_listener *l = arg;\n-\tint               rv;\n-\n-\tnni_mtx_lock(&l->mtx);\n-\trv = nni_copyout_size(l->rcvmax, v, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n-\treturn (rv);\n-}\n-\n static int\n tcptran_listener_get_locaddr(void *arg, void *buf, size_t *szp, nni_opt_type t)\n {\n \ttcptran_listener *l = arg;\n \tint               rv;\n \n-\tnni_mtx_lock(&l->mtx);\n+\tnni_mtx_lock(&l->ep.mtx);\n \trv = nni_copyout_sockaddr(&l->bsa, buf, szp, t);\n-\tnni_mtx_unlock(&l->mtx);\n+\tnni_mtx_unlock(&l->ep.mtx);\n \treturn (rv);\n }\n \n@@ -1203,7 +1115,6 @@ static nni_tran_option tcptran_pipe_options[] = {\n \n static nni_tran_pipe_ops tcptran_pipe_ops = {\n \t.p_fini    = tcptran_pipe_fini,\n-\t.p_start   = tcptran_pipe_start,\n \t.p_stop    = tcptran_pipe_stop,\n \t.p_send    = tcptran_pipe_send,\n \t.p_recv    = tcptran_pipe_recv,\n@@ -1216,8 +1127,8 @@ static nni_tran_option tcptran_dialer_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = tcptran_dialer_get_recvmaxsz,\n-\t    .o_set  = tcptran_dialer_set_recvmaxsz,\n+\t    .o_get  = tcptran_ep_get_recvmaxsz,\n+\t    .o_set  = tcptran_ep_set_recvmaxsz,\n \t    .o_chk  = tcptran_check_recvmaxsz,\n \t},\n \t{\n@@ -1228,15 +1139,15 @@ static nni_tran_option tcptran_dialer_options[] = {\n \t{\n \t    .o_name = NNG_OPT_TCP_NODELAY,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_dialer_get_nodelay,\n-\t    .o_set  = tcptran_dialer_set_nodelay,\n+\t    .o_get  = tcptran_ep_get_nodelay,\n+\t    .o_set  = tcptran_ep_set_nodelay,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t{\n \t    .o_name = NNG_OPT_TCP_KEEPALIVE,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_dialer_get_keepalive,\n-\t    .o_set  = tcptran_dialer_set_keepalive,\n+\t    .o_get  = tcptran_ep_get_keepalive,\n+\t    .o_set  = tcptran_ep_set_keepalive,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t// terminate list\n@@ -1249,8 +1160,8 @@ static nni_tran_option tcptran_listener_options[] = {\n \t{\n \t    .o_name = NNG_OPT_RECVMAXSZ,\n \t    .o_type = NNI_TYPE_SIZE,\n-\t    .o_get  = tcptran_listener_get_recvmaxsz,\n-\t    .o_set  = tcptran_listener_set_recvmaxsz,\n+\t    .o_get  = tcptran_ep_get_recvmaxsz,\n+\t    .o_set  = tcptran_ep_set_recvmaxsz,\n \t    .o_chk  = tcptran_check_recvmaxsz,\n \t},\n \t{\n@@ -1266,15 +1177,15 @@ static nni_tran_option tcptran_listener_options[] = {\n \t{\n \t    .o_name = NNG_OPT_TCP_NODELAY,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_listener_get_nodelay,\n-\t    .o_set  = tcptran_listener_set_nodelay,\n+\t    .o_get  = tcptran_ep_get_nodelay,\n+\t    .o_set  = tcptran_ep_set_nodelay,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t{\n \t    .o_name = NNG_OPT_TCP_KEEPALIVE,\n \t    .o_type = NNI_TYPE_BOOL,\n-\t    .o_get  = tcptran_listener_get_keepalive,\n-\t    .o_set  = tcptran_listener_set_keepalive,\n+\t    .o_get  = tcptran_ep_get_keepalive,\n+\t    .o_set  = tcptran_ep_set_keepalive,\n \t    .o_chk  = tcptran_check_bool,\n \t},\n \t// terminate list\ndiff --git a/src/transport/tls/tls.c b/src/transport/tls/tls.c\nindex e6701f5f5..88e201b9f 100644\n--- a/src/transport/tls/tls.c\n+++ b/src/transport/tls/tls.c\n@@ -29,16 +29,23 @@ typedef struct tlstran_pipe     tlstran_pipe;\n \n // tlstran_pipe is one end of a TLS connection.\n struct tlstran_pipe {\n-\tnni_tls *tls;\n-\tuint16_t peer;\n-\tuint16_t proto;\n-\tsize_t   rcvmax;\n-\tbool     nodelay;\n-\tbool     keepalive;\n+\tnni_tls *       tls;\n+\tuint16_t        peer;\n+\tuint16_t        proto;\n+\tsize_t          rcvmax;\n+\tbool            nodelay;\n+\tbool            keepalive;\n+\tnni_atomic_flag reaped;\n+\tnni_list_node   node; // When pending, we are on ep list.\n+\ttlstran_ep *    ep;\n+\tnni_tcp_dialer *dialer; // Client side.\n+\tnni_sockaddr    sa;\n+\tnni_reap_item   reap;\n+\tbool            closed;\n \n \tnni_list sendq;\n \tnni_list recvq;\n-\tnni_aio *user_negaio;\n+\tnni_aio *useraio;\n \n \tuint8_t  txlen[sizeof(uint64_t)];\n \tuint8_t  rxlen[sizeof(uint64_t)];\n@@ -48,7 +55,9 @@ struct tlstran_pipe {\n \tsize_t   wantrxhead;\n \tnni_aio *txaio;\n \tnni_aio *rxaio;\n-\tnni_aio *negaio;\n+\tnni_aio *negoaio;\n+\tnni_aio *connaio;\n+\tnni_aio *rslvaio;\n \tnni_msg *rxmsg;\n \tnni_mtx  mtx;\n };\n@@ -59,27 +68,25 @@ struct tlstran_ep {\n \tsize_t          rcvmax;\n \tbool            nodelay;\n \tbool            keepalive;\n+\tbool            fini;\n+\tnni_reap_item   reap;\n+\tnni_cb          dtor;\n \tint             authmode;\n \tnng_tls_config *cfg;\n \tnni_url *       url;\n \tnni_mtx         mtx;\n+\tnni_list        pipes;\n };\n \n struct tlstran_dialer {\n \ttlstran_ep      ep; // must be first\n \tnni_tcp_dialer *dialer;\n \tuint16_t        af;\n-\tnni_aio *       aio;\n-\tnni_aio *       user_aio;\n-\tbool            resolving;\n-\tnng_sockaddr    sa;\n };\n \n struct tlstran_listener {\n \ttlstran_ep        ep; // must be first\n \tnni_tcp_listener *listener;\n-\tnni_aio *         aio;\n-\tnni_aio *         user_aio;\n \tnng_sockaddr      sa;\n \tnng_sockaddr      bsa; // bound addr\n };\n@@ -88,9 +95,10 @@ static void tlstran_pipe_send_start(tlstran_pipe *);\n static void tlstran_pipe_recv_start(tlstran_pipe *);\n static void tlstran_pipe_send_cb(void *);\n static void tlstran_pipe_recv_cb(void *);\n+static void tlstran_pipe_rslv_cb(void *);\n+static void tlstran_pipe_conn_cb(void *);\n static void tlstran_pipe_nego_cb(void *);\n-static void tlstran_dialer_cb(void *);\n-static void tlstran_listener_cb(void *);\n+static void tlstran_pipe_reap(tlstran_pipe *);\n \n static int\n tlstran_init(void)\n@@ -108,9 +116,15 @@ tlstran_pipe_close(void *arg)\n {\n \ttlstran_pipe *p = arg;\n \n+\tnni_mtx_lock(&p->mtx);\n+\tp->closed = true;\n+\tnni_mtx_unlock(&p->mtx);\n+\n \tnni_aio_close(p->rxaio);\n \tnni_aio_close(p->txaio);\n-\tnni_aio_close(p->negaio);\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n \n \tnni_tls_close(p->tls);\n }\n@@ -122,26 +136,53 @@ tlstran_pipe_stop(void *arg)\n \n \tnni_aio_stop(p->rxaio);\n \tnni_aio_stop(p->txaio);\n-\tnni_aio_stop(p->negaio);\n+\tnni_aio_stop(p->negoaio);\n+\tnni_aio_stop(p->connaio);\n+\tnni_aio_stop(p->rslvaio);\n }\n \n static void\n tlstran_pipe_fini(void *arg)\n {\n \ttlstran_pipe *p = arg;\n+\ttlstran_ep *  ep;\n+\n+\tif (p == NULL) {\n+\t\treturn;\n+\t}\n+\ttlstran_pipe_stop(p);\n+\tif ((ep = p->ep) != NULL) {\n+\t\tnni_mtx_lock(&ep->mtx);\n+\t\tnni_list_remove(&ep->pipes, p);\n+\t\tif (ep->fini && nni_list_empty(&ep->pipes)) {\n+\t\t\tnni_reap(&ep->reap, ep->dtor, ep);\n+\t\t}\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t}\n \n \tnni_aio_fini(p->rxaio);\n \tnni_aio_fini(p->txaio);\n-\tnni_aio_fini(p->negaio);\n+\tnni_aio_fini(p->negoaio);\n+\tnni_aio_fini(p->connaio);\n+\tnni_aio_fini(p->rslvaio);\n \tif (p->tls != NULL) {\n \t\tnni_tls_fini(p->tls);\n \t}\n \tnni_msg_free(p->rxmsg);\n+\tnni_mtx_fini(&p->mtx);\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+tlstran_pipe_reap(tlstran_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n+\t\tnni_reap(&p->reap, tlstran_pipe_fini, p);\n+\t}\n+}\n+\n static int\n-tlstran_pipe_init(tlstran_pipe **pipep, nni_tls *tls)\n+tlstran_pipe_init(tlstran_pipe **pipep, tlstran_ep *ep)\n {\n \ttlstran_pipe *p;\n \tint           rv;\n@@ -150,46 +191,110 @@ tlstran_pipe_init(tlstran_pipe **pipep, nni_tls *tls)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&p->mtx);\n+\tnni_aio_list_init(&p->recvq);\n+\tnni_aio_list_init(&p->sendq);\n+\tnni_atomic_flag_reset(&p->reaped);\n+\tnni_list_append(&ep->pipes, p);\n+\n+\tp->proto     = ep->proto;\n+\tp->rcvmax    = ep->rcvmax;\n+\tp->nodelay   = ep->nodelay;\n+\tp->keepalive = ep->keepalive;\n+\tp->ep        = ep;\n \n \tif (((rv = nni_aio_init(&p->txaio, tlstran_pipe_send_cb, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->rxaio, tlstran_pipe_recv_cb, p)) != 0) ||\n-\t    ((rv = nni_aio_init(&p->negaio, tlstran_pipe_nego_cb, p)) != 0)) {\n-\t\ttlstran_pipe_fini(p);\n+\t    ((rv = nni_aio_init(&p->rslvaio, tlstran_pipe_rslv_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->connaio, tlstran_pipe_conn_cb, p)) != 0) ||\n+\t    ((rv = nni_aio_init(&p->negoaio, tlstran_pipe_nego_cb, p)) != 0)) {\n+\t\ttlstran_pipe_reap(p);\n \t\treturn (rv);\n \t}\n-\tnni_aio_list_init(&p->recvq);\n-\tnni_aio_list_init(&p->sendq);\n \n-\tp->tls = tls;\n \t*pipep = p;\n \treturn (0);\n }\n \n static void\n-tlstran_pipe_cancel_nego(nni_aio *aio, int rv)\n+tlstran_pipe_rslv_cb(void *arg)\n {\n-\ttlstran_pipe *p = nni_aio_get_prov_data(aio);\n+\ttlstran_pipe *  p   = arg;\n+\ttlstran_dialer *d   = (void *) p->ep;\n+\tnni_aio *       aio = p->rslvaio;\n+\tint             rv;\n \n-\tnni_mtx_lock(&p->mtx);\n-\tif (p->user_negaio != aio) {\n-\t\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttlstran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tp->user_negaio = NULL;\n-\tnni_mtx_unlock(&p->mtx);\n+\tif (d->dialer != NULL) {\n+\t\tnni_tcp_dialer_dial(d->dialer, &p->sa, p->connaio);\n+\t}\n+\tnni_mtx_unlock(&p->ep->mtx);\n+}\n \n-\tnni_aio_abort(p->negaio, rv);\n-\tnni_aio_finish_error(aio, rv);\n+static void\n+tlstran_pipe_conn_cb(void *arg)\n+{\n+\ttlstran_pipe *p   = arg;\n+\tnni_aio *     aio = p->connaio;\n+\tnni_iov       iov;\n+\tint           rv;\n+\n+\tnni_mtx_lock(&p->ep->mtx);\n+\n+\tif ((rv = nni_aio_result(aio)) == 0) {\n+\t\tnni_tcp_conn *tcp = nni_aio_get_output(aio, 0);\n+\t\tif ((rv = nni_tls_init(&p->tls, p->ep->cfg, tcp)) != 0) {\n+\t\t\tnni_tcp_conn_fini(tcp);\n+\t\t}\n+\t}\n+\n+\tif (rv != 0) {\n+\t\tnni_aio *uaio;\n+\t\tif ((uaio = p->useraio) != NULL) {\n+\t\t\tp->useraio = NULL;\n+\t\t\tnni_aio_finish_error(uaio, rv);\n+\t\t}\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\ttlstran_pipe_reap(p);\n+\t\treturn;\n+\t}\n+\n+\tp->txlen[0] = 0;\n+\tp->txlen[1] = 'S';\n+\tp->txlen[2] = 'P';\n+\tp->txlen[3] = 0;\n+\tNNI_PUT16(&p->txlen[4], p->proto);\n+\tNNI_PUT16(&p->txlen[6], 0);\n+\n+\tp->gotrxhead  = 0;\n+\tp->gottxhead  = 0;\n+\tp->wantrxhead = 8;\n+\tp->wanttxhead = 8;\n+\tiov.iov_len   = 8;\n+\tiov.iov_buf   = &p->txlen[0];\n+\tnni_aio_set_iov(p->negoaio, 1, &iov);\n+\tnni_tls_send(p->tls, p->negoaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n }\n \n static void\n tlstran_pipe_nego_cb(void *arg)\n {\n \ttlstran_pipe *p   = arg;\n-\tnni_aio *     aio = p->negaio;\n+\tnni_aio *     aio = p->negoaio;\n+\tnni_aio *     uaio;\n \tint           rv;\n \n-\tnni_mtx_lock(&p->mtx);\n+\tnni_mtx_lock(&p->ep->mtx);\n \tif ((rv = nni_aio_result(aio)) != 0) {\n \t\tgoto done;\n \t}\n@@ -208,7 +313,7 @@ tlstran_pipe_nego_cb(void *arg)\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\t// send it down...\n \t\tnni_tls_send(p->tls, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \tif (p->gotrxhead < p->wantrxhead) {\n@@ -217,7 +322,7 @@ tlstran_pipe_nego_cb(void *arg)\n \t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n \t\tnni_aio_set_iov(aio, 1, &iov);\n \t\tnni_tls_recv(p->tls, aio);\n-\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \t// We have both sent and received the headers.  Lets check the\n@@ -232,17 +337,23 @@ tlstran_pipe_nego_cb(void *arg)\n \tNNI_GET16(&p->rxlen[4], p->peer);\n \n done:\n-\tif (rv == 0) {\n-\t\t// These can fail. Note that the TLS stack automatically\n-\t\t// starts out in NODELAY to make the handshake performant.\n-\t\t(void) nni_tls_set_nodelay(p->tls, p->nodelay);\n-\t\t(void) nni_tls_set_keepalive(p->tls, p->keepalive);\n-\t}\n-\tif ((aio = p->user_negaio) != NULL) {\n-\t\tp->user_negaio = NULL;\n-\t\tnni_aio_finish(aio, rv, 0);\n+\tif ((uaio = p->useraio) != NULL) {\n+\t\tp->useraio = NULL;\n+\t\tif (rv == 0) {\n+\t\t\t// These can fail. Note that the TLS stack\n+\t\t\t// automatically starts out in NODELAY to make the\n+\t\t\t// handshake performant.\n+\t\t\t(void) nni_tls_set_nodelay(p->tls, p->nodelay);\n+\t\t\t(void) nni_tls_set_keepalive(p->tls, p->keepalive);\n+\t\t\tnni_aio_set_output(uaio, 0, p);\n+\t\t\tnni_aio_finish(uaio, 0, 0);\n+\t\t\tnni_mtx_unlock(&p->ep->mtx);\n+\t\t\treturn;\n+\t\t}\n+\t\tnni_aio_finish_error(aio, rv);\n \t}\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&p->ep->mtx);\n+\ttlstran_pipe_reap(p);\n }\n \n static void\n@@ -256,17 +367,18 @@ tlstran_pipe_send_cb(void *arg)\n \tnni_aio *     txaio = p->txaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->sendq);\n-\n-\tif ((rv = nni_aio_result(txaio)) != 0) {\n+\trv = p->closed ? NNG_ECLOSED : nni_aio_result(txaio);\n+\tif (rv != 0) {\n \t\t// Intentionally we do not queue up another transfer.\n \t\t// There's an excellent chance that the pipe is no longer\n \t\t// usable, with a partial transfer.\n \t\t// The protocol should see this error, and close the\n \t\t// pipe itself, we hope.\n-\t\tnni_aio_list_remove(aio);\n+\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n+\t\t\tnni_aio_list_remove(aio);\n+\t\t\tnni_aio_finish_error(aio, rv);\n+\t\t}\n \t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n \t\treturn;\n \t}\n \n@@ -277,6 +389,7 @@ tlstran_pipe_send_cb(void *arg)\n \t\tnni_mtx_unlock(&p->mtx);\n \t\treturn;\n \t}\n+\taio = nni_list_first(&p->sendq);\n \tnni_aio_list_remove(aio);\n \ttlstran_pipe_send_start(p);\n \tnni_mtx_unlock(&p->mtx);\n@@ -299,11 +412,14 @@ tlstran_pipe_recv_cb(void *arg)\n \tnni_aio *     rxaio = p->rxaio;\n \n \tnni_mtx_lock(&p->mtx);\n-\taio = nni_list_first(&p->recvq);\n \n \tif ((rv = nni_aio_result(p->rxaio)) != 0) {\n \t\tgoto recv_error;\n \t}\n+\tif (p->closed) {\n+\t\trv = NNG_ECLOSED;\n+\t\tgoto recv_error;\n+\t}\n \n \tn = nni_aio_count(rxaio);\n \tnni_aio_iov_advance(rxaio, n);\n@@ -348,6 +464,7 @@ tlstran_pipe_recv_cb(void *arg)\n \t}\n \n \t// We read a message completely.  Let the user know the good news.\n+\taio = nni_list_first(&p->recvq);\n \tnni_aio_list_remove(aio);\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n@@ -361,14 +478,16 @@ tlstran_pipe_recv_cb(void *arg)\n \treturn;\n \n recv_error:\n-\tnni_aio_list_remove(aio);\n+\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n+\t\tnni_aio_list_remove(aio);\n+\t\tnni_aio_finish_error(aio, rv);\n+\t}\n \tmsg      = p->rxmsg;\n \tp->rxmsg = NULL;\n \t// Intentionally, we do not queue up another receive.\n \t// The protocol should notice this error and close the pipe.\n \tnni_mtx_unlock(&p->mtx);\n \tnni_msg_free(msg);\n-\tnni_aio_finish_error(aio, rv);\n }\n \n static void\n@@ -444,6 +563,11 @@ tlstran_pipe_send(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tlstran_pipe_send_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -486,7 +610,7 @@ tlstran_pipe_recv_start(tlstran_pipe *p)\n \tnni_iov  iov;\n \tNNI_ASSERT(p->rxmsg == NULL);\n \n-\t// Schedule a read of the IPC header.\n+\t// Schedule a read of the header.\n \trxaio       = p->rxaio;\n \tiov.iov_buf = p->rxlen;\n \tiov.iov_len = sizeof(p->rxlen);\n@@ -505,6 +629,11 @@ tlstran_pipe_recv(void *arg, nni_aio *aio)\n \t\treturn;\n \t}\n \tnni_mtx_lock(&p->mtx);\n+\tif (p->closed) {\n+\t\tnni_mtx_unlock(&p->mtx);\n+\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n+\t\treturn;\n+\t}\n \tif ((rv = nni_aio_schedule(aio, tlstran_pipe_recv_cancel, p)) != 0) {\n \t\tnni_mtx_unlock(&p->mtx);\n \t\tnni_aio_finish_error(aio, rv);\n@@ -569,56 +698,40 @@ tlstran_pipe_get_nodelay(void *arg, void *v, size_t *szp, nni_opt_type t)\n }\n \n static void\n-tlstran_pipe_start(void *arg, nni_aio *aio)\n+tlstran_ep_close(tlstran_ep *ep)\n {\n-\ttlstran_pipe *p = arg;\n-\tnni_aio *     negaio;\n-\tnni_iov       iov;\n-\tint           rv;\n-\n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n-\t}\n-\tnni_mtx_lock(&p->mtx);\n-\tif ((rv = nni_aio_schedule(aio, tlstran_pipe_cancel_nego, p)) != 0) {\n-\t\tnni_mtx_unlock(&p->mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n+\ttlstran_pipe *p;\n+\tnni_mtx_lock(&ep->mtx);\n+\tNNI_LIST_FOREACH (&ep->pipes, p) {\n+\t\tnni_aio_close(p->negoaio);\n+\t\tnni_aio_close(p->connaio);\n+\t\tnni_aio_close(p->rslvaio);\n \t}\n-\tp->txlen[0] = 0;\n-\tp->txlen[1] = 'S';\n-\tp->txlen[2] = 'P';\n-\tp->txlen[3] = 0;\n-\tNNI_PUT16(&p->txlen[4], p->proto);\n-\tNNI_PUT16(&p->txlen[6], 0);\n-\n-\tp->user_negaio = aio;\n-\tp->gotrxhead   = 0;\n-\tp->gottxhead   = 0;\n-\tp->wantrxhead  = 8;\n-\tp->wanttxhead  = 8;\n-\tnegaio         = p->negaio;\n-\tiov.iov_len    = 8;\n-\tiov.iov_buf    = &p->txlen[0];\n-\tnni_aio_set_iov(negaio, 1, &iov);\n-\tnni_tls_send(p->tls, negaio);\n-\tnni_mtx_unlock(&p->mtx);\n+\tnni_mtx_unlock(&ep->mtx);\n }\n \n static void\n tlstran_dialer_fini(void *arg)\n {\n-\ttlstran_dialer *d = arg;\n+\ttlstran_dialer *d  = arg;\n+\ttlstran_ep *    ep = &d->ep;\n \n-\tnni_aio_stop(d->aio);\n+\tnni_mtx_lock(&ep->mtx);\n+\td->ep.fini = true;\n \tif (d->dialer != NULL) {\n \t\tnni_tcp_dialer_fini(d->dialer);\n+\t\td->dialer = NULL;\n+\t}\n+\tif (!nni_list_empty(&ep->pipes)) {\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t\treturn;\n \t}\n-\tnni_aio_fini(d->aio);\n-\tif (d->ep.cfg != NULL) {\n-\t\tnni_tls_config_fini(d->ep.cfg);\n+\tnni_mtx_unlock(&ep->mtx);\n+\tif (ep->cfg != NULL) {\n+\t\tnni_tls_config_fini(ep->cfg);\n \t}\n-\tnni_mtx_fini(&d->ep.mtx);\n+\tnni_mtx_fini(&ep->mtx);\n+\n \tNNI_FREE_STRUCT(d);\n }\n \n@@ -627,8 +740,8 @@ tlstran_dialer_close(void *arg)\n {\n \ttlstran_dialer *d = arg;\n \n-\tnni_aio_close(d->aio);\n \tnni_tcp_dialer_close(d->dialer);\n+\ttlstran_ep_close(&d->ep);\n }\n \n static int\n@@ -664,110 +777,48 @@ tlstran_dialer_init(void **dp, nni_url *url, nni_sock *sock)\n \t}\n \n \tnni_mtx_init(&d->ep.mtx);\n+\tNNI_LIST_INIT(&d->ep.pipes, tlstran_pipe, node);\n \td->ep.authmode  = NNG_TLS_AUTH_MODE_REQUIRED;\n \td->ep.url       = url;\n \td->ep.proto     = nni_sock_proto_id(sock);\n \td->ep.nodelay   = true;\n \td->ep.keepalive = false;\n+\td->ep.dtor      = tlstran_dialer_fini;\n+\td->af           = af;\n \n \tif (((rv = nni_tcp_dialer_init(&d->dialer)) != 0) ||\n \t    ((rv = nni_tls_config_init(&d->ep.cfg, NNG_TLS_MODE_CLIENT)) !=\n \t        0) ||\n \t    ((rv = nng_tls_config_auth_mode(d->ep.cfg, d->ep.authmode)) !=\n \t        0) ||\n-\t    ((rv = nng_tls_config_server_name(d->ep.cfg, host)) != 0) ||\n-\t    ((rv = nni_aio_init(&d->aio, tlstran_dialer_cb, d)) != 0)) {\n+\t    ((rv = nng_tls_config_server_name(d->ep.cfg, host)) != 0)) {\n \t\ttlstran_dialer_fini(d);\n \t\treturn (rv);\n \t}\n-\td->af = af;\n \n \t*dp = d;\n \treturn (0);\n }\n \n static void\n-tlstran_dialer_cb(void *arg)\n+tlstran_pipe_conn_cancel(nni_aio *aio, int rv)\n {\n-\ttlstran_dialer *d = arg;\n-\ttlstran_pipe *  p;\n-\tnni_tcp_conn *  conn;\n-\tnni_tls *       tls;\n-\tnni_aio *       aio;\n-\tint             rv;\n-\n-\tnni_mtx_lock(&d->ep.mtx);\n-\taio = d->user_aio;\n-\trv  = nni_aio_result(d->aio);\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tif ((rv == 0) && !d->resolving) {\n-\t\t\tconn = nni_aio_get_output(d->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\tif (rv != 0) {\n-\t\td->user_aio = NULL;\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tif (d->resolving) {\n-\t\t// Name resolution complete.  Now go to next step.\n-\t\td->resolving = false;\n-\t\tnni_tcp_dialer_dial(d->dialer, &d->sa, d->aio);\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tconn        = nni_aio_get_output(d->aio, 0);\n-\tNNI_ASSERT(conn != NULL);\n-\n-\tif ((rv = nni_tls_init(&tls, d->ep.cfg, conn)) != 0) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n+\ttlstran_pipe *p = nni_aio_get_prov_data(aio);\n \n-\tif ((rv = tlstran_pipe_init(&p, tls)) != 0) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\tnni_tls_fini(tls);\n-\t\tnni_aio_finish_error(aio, rv);\n+\tnni_mtx_lock(&p->ep->mtx);\n+\tif (p->useraio != aio) {\n+\t\tnni_mtx_unlock(&p->ep->mtx);\n \t\treturn;\n \t}\n \n-\tp->proto     = d->ep.proto;\n-\tp->rcvmax    = d->ep.rcvmax;\n-\tp->nodelay   = d->ep.nodelay;\n-\tp->keepalive = d->ep.keepalive;\n-\tnni_mtx_unlock(&d->ep.mtx);\n-\n-\t(void) nni_tls_set_nodelay(tls, p->nodelay);\n-\t(void) nni_tls_set_keepalive(tls, p->keepalive);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n+\t// Close the underlying AIOs.  This will abort the operation.\n+\t// The pipe is removed from pending list at completion callback.\n+\tp->useraio = NULL;\n+\tnni_aio_close(p->negoaio);\n+\tnni_aio_close(p->connaio);\n+\tnni_aio_close(p->rslvaio);\n+\tnni_mtx_unlock(&p->ep->mtx);\n \n-static void\n-tlstran_dialer_cancel(nni_aio *aio, int rv)\n-{\n-\ttlstran_dialer *d = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&d->ep.mtx);\n-\tif (d->user_aio != aio) {\n-\t\tnni_mtx_unlock(&d->ep.mtx);\n-\t\treturn;\n-\t}\n-\td->user_aio = NULL;\n-\tnni_mtx_unlock(&d->ep.mtx);\n-\n-\tnni_aio_abort(d->aio, rv);\n \tnni_aio_finish_error(aio, rv);\n }\n \n@@ -775,45 +826,52 @@ static void\n tlstran_dialer_connect(void *arg, nni_aio *aio)\n {\n \ttlstran_dialer *d = arg;\n+\ttlstran_pipe *  p = NULL;\n \tint             rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n \tnni_mtx_lock(&d->ep.mtx);\n-\tNNI_ASSERT(d->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tlstran_dialer_cancel, d)) != 0) {\n+\tif (((rv = tlstran_pipe_init(&p, &d->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tlstran_pipe_conn_cancel, p)) != 0)) {\n \t\tnni_mtx_unlock(&d->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttlstran_pipe_reap(p);\n \t\treturn;\n \t}\n-\td->user_aio = aio;\n+\tp->useraio = aio;\n+\tp->dialer  = d->dialer;\n \n-\td->resolving = true;\n-\n-\t// Start the name resolution.  Callback will see resolving, and then\n-\t// switch to doing actual connect.\n-\tnni_aio_set_input(d->aio, 0, &d->sa);\n+\t// Start the name resolution.\n+\tnni_aio_set_input(p->rslvaio, 0, &p->sa);\n \tnni_tcp_resolv(\n-\t    d->ep.url->u_hostname, d->ep.url->u_port, d->af, 0, d->aio);\n+\t    d->ep.url->u_hostname, d->ep.url->u_port, d->af, 0, p->rslvaio);\n \tnni_mtx_unlock(&d->ep.mtx);\n }\n \n static void\n tlstran_listener_fini(void *arg)\n {\n-\ttlstran_listener *l = arg;\n+\ttlstran_listener *l  = arg;\n+\ttlstran_ep *      ep = &l->ep;\n \n-\tnni_aio_stop(l->aio);\n+\tnni_mtx_lock(&ep->mtx);\n+\tl->ep.fini = true;\n \tif (l->listener != NULL) {\n \t\tnni_tcp_listener_fini(l->listener);\n+\t\tl->listener = NULL;\n \t}\n-\tnni_aio_fini(l->aio);\n-\tif (l->ep.cfg != NULL) {\n-\t\tnni_tls_config_fini(l->ep.cfg);\n+\tif (!nni_list_empty(&ep->pipes)) {\n+\t\tnni_mtx_unlock(&ep->mtx);\n+\t\treturn;\n+\t}\n+\tnni_mtx_unlock(&ep->mtx);\n+\tif (ep->cfg != NULL) {\n+\t\tnni_tls_config_fini(ep->cfg);\n \t}\n-\tnni_mtx_fini(&l->ep.mtx);\n+\tnni_mtx_fini(&ep->mtx);\n+\n \tNNI_FREE_STRUCT(l);\n }\n \n@@ -822,7 +880,7 @@ tlstran_listener_close(void *arg)\n {\n \ttlstran_listener *l = arg;\n \n-\tnni_aio_close(l->aio);\n+\ttlstran_ep_close(&l->ep);\n \tnni_tcp_listener_close(l->listener);\n }\n \n@@ -859,11 +917,13 @@ tlstran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \t\treturn (NNG_ENOMEM);\n \t}\n \tnni_mtx_init(&l->ep.mtx);\n+\tNNI_LIST_INIT(&l->ep.pipes, tlstran_pipe, node);\n \tl->ep.url       = url;\n \tl->ep.authmode  = NNG_TLS_AUTH_MODE_NONE;\n \tl->ep.keepalive = false;\n \tl->ep.nodelay   = true;\n \tl->ep.proto     = nni_sock_proto_id(sock);\n+\tl->ep.dtor      = tlstran_listener_fini;\n \n \tif (strlen(host) == 0) {\n \t\thost = NULL;\n@@ -896,8 +956,7 @@ tlstran_listener_init(void **lp, nni_url *url, nni_sock *sock)\n \t    ((rv = nni_tls_config_init(&l->ep.cfg, NNG_TLS_MODE_SERVER)) !=\n \t        0) ||\n \t    ((rv = nng_tls_config_auth_mode(l->ep.cfg, l->ep.authmode)) !=\n-\t        0) ||\n-\t    ((rv = nni_aio_init(&l->aio, tlstran_listener_cb, l)) != 0)) {\n+\t        0)) {\n \t\ttlstran_listener_fini(l);\n \t\treturn (rv);\n \t}\n@@ -921,99 +980,27 @@ tlstran_listener_bind(void *arg)\n \treturn (rv);\n }\n \n-static void\n-tlstran_listener_cb(void *arg)\n-{\n-\ttlstran_listener *l = arg;\n-\tnni_aio *         aio;\n-\tint               rv;\n-\ttlstran_pipe *    p = NULL;\n-\tnni_tcp_conn *    conn;\n-\tnni_tls *         tls;\n-\n-\tnni_mtx_lock(&l->ep.mtx);\n-\trv          = nni_aio_result(l->aio);\n-\taio         = l->user_aio;\n-\tl->user_aio = NULL;\n-\n-\tif (aio == NULL) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tif (rv == 0) {\n-\t\t\tconn = nni_aio_get_output(l->aio, 0);\n-\t\t\tnni_tcp_conn_fini(conn);\n-\t\t}\n-\t\treturn;\n-\t}\n-\tif (rv != 0) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\n-\tconn = nni_aio_get_output(l->aio, 0);\n-\tif ((rv = nni_tls_init(&tls, l->ep.cfg, conn)) != 0) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tnni_tcp_conn_fini(conn);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tif ((rv = tlstran_pipe_init(&p, tls)) != 0) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\tnni_tls_fini(tls);\n-\t\tnni_aio_finish_error(aio, rv);\n-\t\treturn;\n-\t}\n-\tp->proto     = l->ep.proto;\n-\tp->rcvmax    = l->ep.rcvmax;\n-\tp->nodelay   = l->ep.nodelay;\n-\tp->keepalive = l->ep.keepalive;\n-\n-\t(void) nni_tls_set_nodelay(tls, p->nodelay);\n-\t(void) nni_tls_set_keepalive(tls, p->keepalive);\n-\n-\tnni_mtx_unlock(&l->ep.mtx);\n-\n-\tnni_aio_set_output(aio, 0, p);\n-\tnni_aio_finish(aio, 0, 0);\n-}\n-\n-static void\n-tlstran_listener_cancel(nni_aio *aio, int rv)\n-{\n-\ttlstran_listener *l = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&l->ep.mtx);\n-\tif (l->user_aio != aio) {\n-\t\tnni_mtx_unlock(&l->ep.mtx);\n-\t\treturn;\n-\t}\n-\tl->user_aio = NULL;\n-\tnni_mtx_unlock(&l->ep.mtx);\n-\n-\tnni_aio_abort(l->aio, rv);\n-\tnni_aio_finish_error(aio, rv);\n-}\n-\n static void\n tlstran_listener_accept(void *arg, nni_aio *aio)\n {\n \ttlstran_listener *l = arg;\n+\ttlstran_pipe *    p = NULL;\n \tint               rv;\n \n \tif (nni_aio_begin(aio) != 0) {\n \t\treturn;\n \t}\n \tnni_mtx_lock(&l->ep.mtx);\n-\tNNI_ASSERT(l->user_aio == NULL);\n-\n-\tif ((rv = nni_aio_schedule(aio, tlstran_listener_cancel, l)) != 0) {\n+\tif (((rv = tlstran_pipe_init(&p, &l->ep)) != 0) ||\n+\t    ((rv = nni_aio_schedule(aio, tlstran_pipe_conn_cancel, p)) != 0)) {\n \t\tnni_mtx_unlock(&l->ep.mtx);\n \t\tnni_aio_finish_error(aio, rv);\n+\t\ttlstran_pipe_reap(p);\n \t\treturn;\n \t}\n-\tl->user_aio = aio;\n+\tp->useraio = aio;\n \n-\tnni_tcp_listener_accept(l->listener, l->aio);\n+\tnni_tcp_listener_accept(l->listener, p->connaio);\n \tnni_mtx_unlock(&l->ep.mtx);\n }\n \n@@ -1306,7 +1293,6 @@ static nni_tran_option tlstran_pipe_options[] = {\n \n static nni_tran_pipe_ops tlstran_pipe_ops = {\n \t.p_fini    = tlstran_pipe_fini,\n-\t.p_start   = tlstran_pipe_start,\n \t.p_stop    = tlstran_pipe_stop,\n \t.p_send    = tlstran_pipe_send,\n \t.p_recv    = tlstran_pipe_recv,\ndiff --git a/src/transport/zerotier/zerotier.c b/src/transport/zerotier/zerotier.c\nindex a2163e3f6..d10729315 100644\n--- a/src/transport/zerotier/zerotier.c\n+++ b/src/transport/zerotier/zerotier.c\n@@ -183,27 +183,28 @@ struct zt_fraglist {\n };\n \n struct zt_pipe {\n-\tnni_list_node zp_link;\n-\tconst char *  zp_addr;\n-\tzt_node *     zp_ztn;\n-\tuint64_t      zp_nwid;\n-\tuint64_t      zp_laddr;\n-\tuint64_t      zp_raddr;\n-\tuint16_t      zp_peer;\n-\tuint16_t      zp_proto;\n-\tuint16_t      zp_next_msgid;\n-\tsize_t        zp_rcvmax;\n-\tsize_t        zp_mtu;\n-\tint           zp_closed;\n-\tnni_aio *     zp_user_rxaio;\n-\tnni_time      zp_last_recv;\n-\tzt_fraglist   zp_recvq[zt_recvq];\n-\tint           zp_ping_try;\n-\tint           zp_ping_tries;\n-\tint           zp_ping_active;\n-\tnni_duration  zp_ping_time;\n-\tnni_aio *     zp_ping_aio;\n-\tuint8_t *     zp_send_buf;\n+\tnni_list_node   zp_link;\n+\tconst char *    zp_addr;\n+\tzt_node *       zp_ztn;\n+\tuint64_t        zp_nwid;\n+\tuint64_t        zp_laddr;\n+\tuint64_t        zp_raddr;\n+\tuint16_t        zp_peer;\n+\tuint16_t        zp_proto;\n+\tuint16_t        zp_next_msgid;\n+\tsize_t          zp_rcvmax;\n+\tsize_t          zp_mtu;\n+\tnni_aio *       zp_user_rxaio;\n+\tnni_time        zp_last_recv;\n+\tzt_fraglist     zp_recvq[zt_recvq];\n+\tint             zp_ping_try;\n+\tint             zp_ping_tries;\n+\tbool            zp_closed;\n+\tnni_duration    zp_ping_time;\n+\tnni_aio *       zp_ping_aio;\n+\tuint8_t *       zp_send_buf;\n+\tnni_atomic_flag zp_reaped;\n+\tnni_reap_item   zp_reap;\n };\n \n typedef struct zt_creq zt_creq;\n@@ -280,6 +281,7 @@ static void zt_fraglist_free(zt_fraglist *);\n static void zt_virtual_recv(ZT_Node *, void *, void *, uint64_t, void **,\n     uint64_t, uint64_t, unsigned int, unsigned int, const void *,\n     unsigned int);\n+static void zt_pipe_start_ping(zt_pipe *);\n \n static int64_t\n zt_now(void)\n@@ -805,10 +807,8 @@ zt_pipe_close_err(zt_pipe *p, int err, uint8_t code, const char *msg)\n \t\tp->zp_user_rxaio = NULL;\n \t\tnni_aio_finish_error(aio, err);\n \t}\n-\tif ((aio = p->zp_ping_aio) != NULL) {\n-\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n-\t}\n-\tp->zp_closed = 1;\n+\tnni_aio_close(p->zp_ping_aio);\n+\tp->zp_closed = true;\n \tif (msg != NULL) {\n \t\tzt_pipe_send_err(p, code, msg);\n \t}\n@@ -974,7 +974,7 @@ zt_pipe_recv_disc_req(zt_pipe *p, const uint8_t *data, size_t len)\n \t// Don't bother to check the length, going to disconnect anyway.\n \tif ((aio = p->zp_user_rxaio) != NULL) {\n \t\tp->zp_user_rxaio = NULL;\n-\t\tp->zp_closed     = 1;\n+\t\tp->zp_closed     = true;\n \t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n \t}\n }\n@@ -990,7 +990,7 @@ zt_pipe_recv_error(zt_pipe *p, const uint8_t *data, size_t len)\n \t// the day, the details are just not that interesting.\n \tif ((aio = p->zp_user_rxaio) != NULL) {\n \t\tp->zp_user_rxaio = NULL;\n-\t\tp->zp_closed     = 1;\n+\t\tp->zp_closed     = true;\n \t\tnni_aio_finish_error(aio, NNG_ETRANERR);\n \t}\n }\n@@ -1627,7 +1627,8 @@ zt_pipe_close(void *arg)\n \tnni_aio *aio;\n \n \tnni_mtx_lock(&zt_lk);\n-\tp->zp_closed = 1;\n+\tp->zp_closed = true;\n+\tnni_aio_close(p->zp_ping_aio);\n \tif ((aio = p->zp_user_rxaio) != NULL) {\n \t\tp->zp_user_rxaio = NULL;\n \t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n@@ -1659,6 +1660,14 @@ zt_pipe_fini(void *arg)\n \tNNI_FREE_STRUCT(p);\n }\n \n+static void\n+zt_pipe_reap(zt_pipe *p)\n+{\n+\tif (!nni_atomic_flag_test_and_set(&p->zp_reaped)) {\n+\t\tnni_reap(&p->zp_reap, zt_pipe_fini, p);\n+\t}\n+}\n+\n static int\n zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n {\n@@ -1687,6 +1696,7 @@ zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n \tp->zp_ping_time  = ep->ze_ping_time;\n \tp->zp_next_msgid = (uint16_t) nni_random();\n \tp->zp_ping_try   = 0;\n+\tnni_atomic_flag_reset(&p->zp_reaped);\n \n \tif (ep->ze_mode == NNI_EP_MODE_DIAL) {\n \t\trv = nni_idhash_insert(ztn->zn_lpipes, laddr, p);\n@@ -1696,7 +1706,8 @@ zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n \tif ((rv != 0) ||\n \t    ((rv = nni_idhash_insert(ztn->zn_peers, p->zp_raddr, p)) != 0) ||\n \t    ((rv = nni_aio_init(&p->zp_ping_aio, zt_pipe_ping_cb, p)) != 0)) {\n-\t\tzt_pipe_fini(p);\n+\t\tzt_pipe_reap(p);\n+\t\treturn (rv);\n \t}\n \n \t// The largest fragment we can accept on this pipe. The MTU is\n@@ -1717,7 +1728,7 @@ zt_pipe_init(zt_pipe **pipep, zt_ep *ep, uint64_t raddr, uint64_t laddr)\n \t\tfl->fl_missingsz = (maxfrags + 7) / 8;\n \t\tfl->fl_missing   = nni_alloc(fl->fl_missingsz);\n \t\tif (fl->fl_missing == NULL) {\n-\t\t\tzt_pipe_fini(p);\n+\t\t\tzt_pipe_reap(p);\n \t\t\treturn (NNG_ENOMEM);\n \t\t}\n \t}\n@@ -2015,97 +2026,51 @@ zt_pipe_get_node(void *arg, void *buf, size_t *szp, nni_opt_type t)\n \treturn (nni_copyout_u64(p->zp_laddr >> 24, buf, szp, t));\n }\n \n-static void\n-zt_pipe_cancel_ping(nni_aio *aio, int rv)\n-{\n-\tzt_pipe *p = nni_aio_get_prov_data(aio);\n-\n-\tnni_mtx_lock(&zt_lk);\n-\tif (p->zp_ping_active) {\n-\t\tp->zp_ping_active = 0;\n-\t\tnni_aio_finish_error(aio, rv);\n-\t}\n-\tnni_mtx_unlock(&zt_lk);\n-}\n-\n static void\n zt_pipe_ping_cb(void *arg)\n {\n \tzt_pipe *p   = arg;\n \tnni_aio *aio = p->zp_ping_aio;\n+\tint      rv;\n \n+\tif ((rv = nni_aio_result(aio)) != 0) {\n+\t\t// We were canceled.  That means we're done.\n+\t\treturn;\n+\t}\n \tnni_mtx_lock(&zt_lk);\n-\n-\tp->zp_ping_active = 0;\n \tif (p->zp_closed || aio == NULL || (p->zp_ping_tries == 0) ||\n \t    (p->zp_ping_time == NNG_DURATION_INFINITE) ||\n \t    (p->zp_ping_time == NNG_DURATION_ZERO)) {\n \t\tnni_mtx_unlock(&zt_lk);\n \t\treturn;\n \t}\n-\tif (nni_aio_result(aio) != NNG_ETIMEDOUT) {\n-\t\tnni_mtx_unlock(&zt_lk);\n-\t\treturn;\n-\t}\n-\tif (p->zp_ping_try < p->zp_ping_tries) {\n-\t\tnni_time now = nni_clock();\n-\t\tnni_aio_set_timeout(aio, p->zp_ping_time);\n-\t\t// We want pings.  We only send one if needed, but we\n-\t\t// use the the timer to wake us up even if we aren't\n-\t\t// going to send a ping.  (We don't increment the try count\n-\t\t// unless we actually do send one though.)\n-\t\tif (nni_aio_begin(aio) == 0) {\n-\t\t\tint rv;\n-\t\t\trv = nni_aio_schedule(aio, zt_pipe_cancel_ping, p);\n-\t\t\tif (rv != 0) {\n-\t\t\t\tnni_mtx_unlock(&zt_lk);\n-\t\t\t\tnni_aio_finish_error(aio, rv);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tp->zp_ping_active = 1;\n-\t\t\tif (now > (p->zp_last_recv + p->zp_ping_time)) {\n-\t\t\t\tp->zp_ping_try++;\n-\t\t\t\tzt_pipe_send_ping(p);\n-\t\t\t}\n-\t\t}\n-\t} else {\n+\tif (p->zp_ping_try >= p->zp_ping_tries) {\n \t\t// Ping count exceeded; the other side is AFK.\n \t\t// Close the pipe, but no need to send a reason to the peer.\n \t\tzt_pipe_close_err(p, NNG_ECLOSED, 0, NULL);\n+\t\tnni_mtx_unlock(&zt_lk);\n+\t\treturn;\n+\t}\n+\n+\tif (nni_clock() > (p->zp_last_recv + p->zp_ping_time)) {\n+\t\tp->zp_ping_try++;\n+\t\tzt_pipe_send_ping(p);\n \t}\n+\n+\tnni_sleep_aio(p->zp_ping_time, aio); // Schedule a recheck.\n \tnni_mtx_unlock(&zt_lk);\n }\n \n static void\n-zt_pipe_start(void *arg, nni_aio *aio)\n+zt_pipe_start_ping(zt_pipe *p)\n {\n-\tzt_pipe *p = arg;\n-\n-\tif (nni_aio_begin(aio) != 0) {\n-\t\treturn;\n-\t}\n-\tnni_mtx_lock(&zt_lk);\n-\tp->zp_ping_active = 0;\n \t// send a gratuitous ping, and start the ping interval timer.\n \tif ((p->zp_ping_tries > 0) && (p->zp_ping_time != NNG_DURATION_ZERO) &&\n-\t    (p->zp_ping_time != NNG_DURATION_INFINITE) &&\n-\t    (p->zp_ping_aio != NULL)) {\n+\t    (p->zp_ping_time != NNG_DURATION_INFINITE)) {\n \t\tp->zp_ping_try = 0;\n-\t\tnni_aio_set_timeout(aio, p->zp_ping_time);\n-\t\tif (nni_aio_begin(p->zp_ping_aio) == 0) {\n-\t\t\tint rv;\n-\t\t\trv = nni_aio_schedule(\n-\t\t\t    p->zp_ping_aio, zt_pipe_cancel_ping, p);\n-\t\t\tif (rv != 0) {\n-\t\t\t\tnni_aio_finish_error(p->zp_ping_aio, rv);\n-\t\t\t} else {\n-\t\t\t\tp->zp_ping_active = 1;\n-\t\t\t\tzt_pipe_send_ping(p);\n-\t\t\t}\n-\t\t}\n+\t\tzt_pipe_send_ping(p);\n+\t\tnni_sleep_aio(p->zp_ping_time, p->zp_ping_aio);\n \t}\n-\tnni_aio_finish(aio, 0, 0);\n-\tnni_mtx_unlock(&zt_lk);\n }\n \n static void\n@@ -2425,6 +2390,7 @@ zt_ep_doaccept(zt_ep *ep)\n \t\t}\n \t\tp->zp_peer = creq.cr_proto;\n \t\tzt_pipe_send_conn_ack(p);\n+\t\tzt_pipe_start_ping(p);\n \t\tnni_aio_set_output(aio, 0, p);\n \t\tnni_aio_finish(aio, 0, 0);\n \t}\n@@ -2484,6 +2450,7 @@ zt_ep_conn_req_cb(void *arg)\n \t\t// Already canceled, or already handled?\n \t\tif ((uaio = nni_list_first(&ep->ze_aios)) != NULL) {\n \t\t\tnni_aio_list_remove(uaio);\n+\t\t\tzt_pipe_start_ping(p);\n \t\t\tnni_aio_set_output(uaio, 0, p);\n \t\t\tnni_aio_finish(uaio, 0, 0);\n \t\t} else {\n@@ -2991,7 +2958,6 @@ static nni_tran_option zt_pipe_options[] = {\n \n static nni_tran_pipe_ops zt_pipe_ops = {\n \t.p_fini    = zt_pipe_fini,\n-\t.p_start   = zt_pipe_start,\n \t.p_send    = zt_pipe_send,\n \t.p_recv    = zt_pipe_recv,\n \t.p_close   = zt_pipe_close,\n",
  "test_patch": "diff --git a/tests/tls.c b/tests/tls.c\nindex 1f1f244c6..01e49aa74 100644\n--- a/tests/tls.c\n+++ b/tests/tls.c\n@@ -265,7 +265,6 @@ init_listener_tls_file(nng_listener l)\n }\n \n TestMain(\"TLS Transport\", {\n-\n \tstatic trantest tt;\n \n \ttt.dialer_init   = init_dialer_tls;\n@@ -291,28 +290,39 @@ TestMain(\"TLS Transport\", {\n \t});\n \n \tConvey(\"We can bind to wild card\", {\n-\t\tnng_socket s1;\n-\t\tnng_socket s2;\n-\t\tchar       addr[NNG_MAXADDRLEN];\n+\t\tnng_socket   s1;\n+\t\tnng_socket   s2;\n+\t\tchar         addr[NNG_MAXADDRLEN];\n+\t\tnng_listener l;\n+\t\tnng_dialer   d;\n \n \t\tSo(nng_tls_register() == 0);\n+\n \t\tSo(nng_pair_open(&s1) == 0);\n \t\tSo(nng_pair_open(&s2) == 0);\n+\n \t\tReset({\n \t\t\tnng_close(s2);\n \t\t\tnng_close(s1);\n \t\t});\n \t\ttrantest_next_address(addr, \"tls+tcp://*:%u\");\n-\t\tSo(nng_listen(s1, addr, NULL, 0) == 0);\n-\t\t// reset port back one\n+\t\tSo(nng_listener_create(&l, s1, addr) == 0);\n+\t\tSo(init_listener_tls(l) == 0);\n \t\ttrantest_prev_address(addr, \"tls+tcp://127.0.0.1:%u\");\n-\t\tSo(nng_dial(s2, addr, NULL, 0) == 0);\n+\t\tSo(nng_dialer_create(&d, s2, addr) == 0);\n+\t\tSo(init_dialer_tls(d) == 0);\n+\t\tSo(nng_dialer_setopt_int(\n+\t\t       d, NNG_OPT_TLS_AUTH_MODE, NNG_TLS_AUTH_MODE_NONE) == 0);\n+\n+\t\tSo(nng_listener_start(l, 0) == 0);\n+\t\tSo(nng_dialer_start(d, 0) == 0);\n \t});\n \n \tConvey(\"We can bind to port zero\", {\n \t\tnng_socket   s1;\n \t\tnng_socket   s2;\n \t\tnng_listener l;\n+\t\tnng_dialer   d;\n \t\tchar *       addr;\n \t\tsize_t       sz;\n \n@@ -323,10 +333,16 @@ TestMain(\"TLS Transport\", {\n \t\t\tnng_close(s2);\n \t\t\tnng_close(s1);\n \t\t});\n-\t\tSo(nng_listen(s1, \"tls+tcp://127.0.0.1:0\", &l, 0) == 0);\n+\t\tSo(nng_listener_create(&l, s1, \"tls+tcp://127.0.0.1:0\") == 0);\n+\t\tSo(init_listener_tls(l) == 0);\n+\t\tSo(nng_listener_start(l, 0) == 0);\n \t\tsz = NNG_MAXADDRLEN;\n \t\tSo(nng_listener_getopt_string(l, NNG_OPT_URL, &addr) == 0);\n-\t\tSo(nng_dial(s2, addr, NULL, 0) == 0);\n+\t\tSo(nng_dialer_create(&d, s2, addr) == 0);\n+\t\tSo(init_dialer_tls(d) == 0);\n+\t\tSo(nng_dialer_setopt_int(\n+\t\t       d, NNG_OPT_TLS_AUTH_MODE, NNG_TLS_AUTH_MODE_NONE) == 0);\n+\t\tSo(nng_dialer_start(d, 0) == 0);\n \t\tnng_strfree(addr);\n \t});\n \n@@ -572,5 +588,4 @@ TestMain(\"TLS Transport\", {\n \t\tSo(nng_dialer_getopt_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);\n \t\tSo(v == true);\n \t});\n-\n })\n",
  "problem_statement": "Race condition closing between header & body\nFor some protocols (TCP, IPC, and TLS stream transports), if the pipe is closed, we\r\ncan wind up closing the pipe, but rescheduling a transfer of data which won't fail\r\nas the underlying aio is closed.\r\n\r\nFor this to occur, the close has to occur between receiving the message header\r\nand the message body.\r\n\n",
  "hints_text": "",
  "created_at": "2018-08-01T01:50:11Z"
}